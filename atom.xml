<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>JoeRay61</title>
  <subtitle>make things make sense</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://joeray61.com/"/>
  <updated>2017-05-21T06:18:46.000Z</updated>
  <id>http://joeray61.com/</id>
  
  <author>
    <name>JoeRay61</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>rollup 初体验</title>
    <link href="http://joeray61.com/2017/05/21/rollup-%E5%88%9D%E4%BD%93%E9%AA%8C/"/>
    <id>http://joeray61.com/2017/05/21/rollup-初体验/</id>
    <published>2017-05-21T06:16:27.000Z</published>
    <updated>2017-05-21T06:18:46.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>rollup 是 JavaScript 模块打包工具，能够将多个具有引用依赖关系的脚本文件打包成一个文件，并且能够做到只引入使用到的代码，如果使用 ES6 的模块系统的话。举个简单的栗子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">// foo.js</div><div class="line">export let a = &apos;hello world!&apos;;</div><div class="line">export let b = &apos;hello rollup!&apos;;</div><div class="line"></div><div class="line">// main.js</div><div class="line">import &#123;a&#125; from &apos;./foo&apos;;</div><div class="line"></div><div class="line">export default () =&gt; &#123;</div><div class="line">  console.log(`the string is $&#123;a&#125;`);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以<code>main.js</code>作为程序入口，使用<code>rollup</code>打包后的代码是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">// bundle.js</div><div class="line">&apos;use strict&apos;;</div><div class="line"></div><div class="line">var a = &apos;hello world!&apos;;</div><div class="line"></div><div class="line">var main = (function () &#123;</div><div class="line">  console.log(&apos;the string is &apos; + a);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">module.exports = main;</div></pre></td></tr></table></figure>
<p>可以看到，<code>foo.js</code>和<code>main.js</code>被打包到<code>bundle.js</code>中，并且只引入了<code>foo.js</code>中使用到的<code>export let a = &#39;hello world!&#39;;</code></p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>局部安装</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm i rollup</div></pre></td></tr></table></figure>
<p>全局安装（可能需要<code>sudo</code>）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm i -g rollup</div></pre></td></tr></table></figure>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="CLI"><a href="#CLI" class="headerlink" title="CLI"></a>CLI</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line">$ rollup</div><div class="line"></div><div class="line">rollup 版本 0.41.6</div><div class="line">=====================================</div><div class="line"></div><div class="line">用法: rollup [选项] &lt;入口文件&gt;</div><div class="line"></div><div class="line">基础选项:</div><div class="line"></div><div class="line">-v, --version            显示版本号</div><div class="line">-h, --help               显示帮助信息</div><div class="line">-c, --config             使用这个配置文件 （如果使用了该参数，但是并没有指定具体的配置文</div><div class="line">                            p.config.js`）</div><div class="line">-w, --watch              观察要打包文件的变动，并且在有变动时重新打包</div><div class="line">-i, --input              输入 （另一种指定&lt;入口文件&gt;的方式）</div><div class="line">-o, --output &lt;output&gt;    输出 （如果缺省，则输出到控制台）</div><div class="line">-f, --format [es]        输出类型 (amd, cjs, es, iife, umd)</div><div class="line">-e, --external           用逗号分隔的不需要打包的模块 ID 列表</div><div class="line">-g, --globals            用逗号分隔的`module ID:Global`键值对</div><div class="line">                            任何在这里定义的模块 ID 都会被加入到 external 选项中</div><div class="line">-n, --name               UMD 输出的命名</div><div class="line">-u, --id                 AMD 模块的 ID （默认是匿名的）</div><div class="line">-m, --sourcemap          生成 sourcemap (`-m inline`用于生成内联map)</div><div class="line">--no-strict              不要在生成的模块中声明`use strict;`</div><div class="line">--no-indent              不要缩进结果</div><div class="line">--environment &lt;values&gt;   传给配置文件的设置 (见示例)</div><div class="line">--no-conflict            为 UMD 模块生成一个 noConflict 方法</div><div class="line">--silent                 不要打印警告</div><div class="line">--intro                  需要插入到包顶部的内容（在 amd/umd/iife 包装函数的内部）</div><div class="line">--outro                  需要插入到包底部的内容（在 amd/umd/iife 包装函数的内部）</div><div class="line">--banner                 需要插入到包顶部的内容（在 amd/umd/iife 包装函数的外部）</div><div class="line">--footer                 需要插入到包底部的内容（在 amd/umd/iife 包装函数的外部）</div><div class="line"></div><div class="line">示例：</div><div class="line"></div><div class="line"># 在配置文件中使用设置</div><div class="line">rollup -c</div><div class="line"></div><div class="line"># 在配置文件中, process.env.INCLUDE_DEPS === &apos;true&apos;</div><div class="line"># 并且 process.env.BUILD === &apos;production&apos;</div><div class="line">rollup -c --environment INCLUDE_DEPS,BUILD:production</div><div class="line"></div><div class="line"># 从 src/main.js 创建 CommonJS 类型的包 bundle.js</div><div class="line">rollup --format=cjs --output=bundle.js -- src/main.js</div><div class="line"></div><div class="line"># 创建一个使用`window.jQuery`和`window._`这两个全局变量的自执行的函数</div><div class="line">rollup -f iife --globals jquery:jQuery,lodash:_ \</div><div class="line">  -i src/app.js -o build/app.js -m build/app.js.map</div><div class="line"></div><div class="line">注意：</div><div class="line"></div><div class="line">* 当输出到控制台时，只允许使用内联 sourcemaps</div><div class="line"></div><div class="line">访问 https://github.com/rollup/rollup/wiki 获取更多信息</div></pre></td></tr></table></figure>
<h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>跟 webpack 一样，rollup 也可以使用配置文件，通过 cli 的<code>-c</code>参数来指定配置文件，默认为当前目录下的<code>rollup.config.js</code>。</p>
<p>使用配置文件有几点好处：</p>
<ul>
<li>重复编译时，不需要重复输入大段的 CLI 配置参数</li>
<li>配置文件中我们可以进行编程，这样能够完成一些纯靠 CLI 参数无法完成的配置</li>
</ul>
<p>配置文件需要输出一个配置对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// rollup.config.js</div><div class="line">export default &#123;</div><div class="line">    // write config key: value pair here</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>常用的配置项其实跟 CLI 大同小异，具体如下：</p>
<ul>
<li><code>entry</code>: String，入口文件路径</li>
<li><code>format</code>: String，输出类型 (<code>amd</code>, <code>cjs</code>, <code>es</code>, <code>iife</code>, <code>umd</code>)</li>
<li><code>plugins</code>: Array，插件声明</li>
<li><code>external</code>: Array，不需要打包的文件</li>
<li><code>dest</code>: String，输出的打包文件</li>
<li><code>sourceMap</code>: Boolean，是否要支持 sourcemap</li>
</ul>
<h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><p>rollup 的插件一般以 npm 包的形式引入，在配置文件中 plugins 里面声明。下面我介绍几个常用的 rollup 插件</p>
<h4 id="rollup-plugin-json"><a href="#rollup-plugin-json" class="headerlink" title="rollup-plugin-json"></a>rollup-plugin-json</h4><p>需要加载 json 文件的数据时，可以通过<code>rollup-plugin-json</code>这个插件</p>
<h4 id="rollup-plugin-node-resolve"><a href="#rollup-plugin-node-resolve" class="headerlink" title="rollup-plugin-node-resolve"></a>rollup-plugin-node-resolve</h4><p>这个插件可以让 rollup 更加智能地找到各个需要打包的文件路径</p>
<h4 id="rollup-plugin-commonjs"><a href="#rollup-plugin-commonjs" class="headerlink" title="rollup-plugin-commonjs"></a>rollup-plugin-commonjs</h4><p>目前大多数的 npm 包还是以 CommonJS 模块的形式对外 export，rollup 本身无法解析他们，需要用<code>rollup-plugin-commonjs</code>先把他们转换成 ES6 的模块</p>
<h4 id="rollup-plugin-babel"><a href="#rollup-plugin-babel" class="headerlink" title="rollup-plugin-babel"></a>rollup-plugin-babel</h4><p>熟悉 babel 的人大概已经猜到了，这个插件能让 rollup 具有 babel 的能力，可以用来转换 ES6 的代码，在使用前需要先配置<code>.babelrc&#39;，要注意的是不能用 babel 转换 ES6 的模块，因为 rollup 的打包是依赖于 ES6 模块的。</code>.babelrc`配置如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;presets&quot;: [</div><div class="line">    [&quot;latest&quot;, &#123;</div><div class="line">      &quot;es2015&quot;: &#123;</div><div class="line">        &quot;modules&quot;: false</div><div class="line">      &#125;</div><div class="line">    &#125;]</div><div class="line">  ]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><p>rollup 可以作为一个包引入到 js 程序中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var rollup = require(&apos;rollup&apos;);</div></pre></td></tr></table></figure>
<p>他提供了几个 API:</p>
<h4 id="rollup-rollup-options"><a href="#rollup-rollup-options" class="headerlink" title="rollup.rollup(options)"></a>rollup.rollup(options)</h4><p>根据 options 选项执行打包过程，返回一个 Promise 对象，该对象在调用 resolve 时会传入打包后的<code>bundle</code>对象</p>
<h4 id="bundle-generate-options"><a href="#bundle-generate-options" class="headerlink" title="bundle.generate(options)"></a>bundle.generate(options)</h4><p>根据 options 生成代码，返回一个<code>{code, sourcemap}</code>对象</p>
<h4 id="bundle-write-options"><a href="#bundle-write-options" class="headerlink" title="bundle.write(options)"></a>bundle.write(options)</h4><p>与<code>bundle.generate</code>类似，但是可以直接将编译结果写入到文件中。</p>
<p>以上只对 API 的功能做了简要介绍，具体可以参考<a href="https://github.com/rollup/rollup/wiki/JavaScript-API" target="_blank" rel="external">官方wiki</a></p>
<h2 id="Tree-Shaking"><a href="#Tree-Shaking" class="headerlink" title="Tree-Shaking"></a>Tree-Shaking</h2><p>rollup 中的 Tree-Shaking 又叫<code>live code inclusion</code>，能够做到只引入使用的代码，减少打包后的文件大小，这与我们常说的<code>DCE( Dead Code Elimination)</code>目的一致，但是做法相反，DCE 的思路是提出不用的代码，从语义上来说，DCE 更符合 Tree-Shaking 的表述（想象熊孩子在摇晃一棵树，树上一些枯死的枝芽都被晃掉下来了）。</p>
<p>其实 rollup 的 Tree-Shaking 也只是处理了顶层的 AST，所以 rollup 处理后的代码仍然可能存在冗余，另外，Tree-Shaking 也不是代码压缩，所以也需要在这之后使用代码压缩工具进一步缩小文件大小。</p>
<p>Tree-Shaking的实现主要归功于 ES6 的模块，ES6 的模块是静态的 import 和 export，基于这个特性才能够进行模块的静态分析，这是在动态的 CommonJS 和 AMD 模块里无法做到的。这也是为什么 rollup 要求使用 ES6 模块的原因。</p>
<p>推荐大家阅读一下 Rich Harris 的这篇文章：<a href="https://medium.com/@Rich_Harris/tree-shaking-versus-dead-code-elimination-d3765df85c80" target="_blank" rel="external">Tree-shaking versus dead code elimination</a>（需要翻墙）</p>
<h2 id="rollup-vs-webpack"><a href="#rollup-vs-webpack" class="headerlink" title="rollup vs webpack"></a>rollup vs webpack</h2><p>同样是打包工具，我们自然要将 rollup 和 webpack 比较一番，以下是我认为的几点区别，不一定对，欢迎留言讨论</p>
<ol>
<li>rollup 一般用于 JavaScript 库的开发，而 webpack 一般用于 web 应用的开发</li>
<li>rollup 希望打包后的代码还是像人写的代码，而不是机器生成的代码，所以 rollup 不会给每个模块包上一层 function，也不会在打包后的文件顶部加上一个模块加载器，而 webpack 相反</li>
<li>基于第 2 点，rollup 打包后的文件比 webpack 打包后的文件更小</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;rollup 是 JavaScript 模块打包工具，能够将多个具有引用依赖关系的脚本文件打包成一个文件，并且能够做到只引入使用到的代码，如
    
    </summary>
    
      <category term="技术" scheme="http://joeray61.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="rollup" scheme="http://joeray61.com/tags/rollup/"/>
    
      <category term="打包" scheme="http://joeray61.com/tags/%E6%89%93%E5%8C%85/"/>
    
      <category term="webpack" scheme="http://joeray61.com/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>Vue原理解析之observer模块</title>
    <link href="http://joeray61.com/2017/02/16/Vue%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90%E4%B9%8Bobserver%E6%A8%A1%E5%9D%97/"/>
    <id>http://joeray61.com/2017/02/16/Vue原理解析之observer模块/</id>
    <published>2017-02-16T15:26:10.000Z</published>
    <updated>2017-04-04T10:04:14.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>本文是针对<code>Vue@2.1.8</code>进行分析</p>
</blockquote>
<p><code>observer</code>是Vue核心中最重要的一个模块（个人认为），能够实现视图与数据的响应式更新，底层全凭<code>observer</code>的支持。</p>
<p><code>observer</code>模块在Vue项目中的代码位置是<code>src/core/observer</code>，模块共分为这几个部分：</p>
<ul>
<li><code>Observer</code>: 数据的观察者，让数据对象的读写操作都处于自己的监管之下</li>
<li><code>Watcher</code>: 数据的订阅者，数据的变化会通知到<code>Watcher</code>，然后由<code>Watcher</code>进行相应的操作，例如更新视图</li>
<li><code>Dep</code>: <code>Observer</code>与<code>Watcher</code>的纽带，当数据变化时，会被<code>Observer</code>观察到，然后由<code>Dep</code>通知到<code>Watcher</code></li>
</ul>
<p>示意图如下：</p>
<img src="/2017/02/16/Vue原理解析之observer模块/flow.png" alt="flow.png" title="">
<h2 id="Observer"><a href="#Observer" class="headerlink" title="Observer"></a>Observer</h2><p><code>Observer</code>类定义在<code>src/core/observer/index.js</code>中，先来看一下<code>Observer</code>的构造函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">constructor (value: any) &#123;</div><div class="line">  this.value = value</div><div class="line">  this.dep = new Dep()</div><div class="line">  this.vmCount = 0</div><div class="line">  def(value, &apos;__ob__&apos;, this)</div><div class="line">  if (Array.isArray(value)) &#123;</div><div class="line">      const augment = hasProto</div><div class="line">      ? protoAugment</div><div class="line">      : copyAugment</div><div class="line">    augment(value, arrayMethods, arrayKeys)</div><div class="line">    this.observeArray(value)</div><div class="line">  &#125; else &#123;</div><div class="line">    this.walk(value)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>value</code>是需要被观察的数据对象，在构造函数中，会给<code>value</code>增加<code>__ob__</code>属性，作为数据已经被<code>Observer</code>观察的标志。如果<code>value</code>是数组，就使用<code>observeArray</code>遍历<code>value</code>，对<code>value</code>中每一个元素调用<code>observe</code>分别进行观察。如果<code>value</code>是对象，则使用<code>walk</code>遍历<code>value</code>上每个key，对每个key调用<code>defineReactive</code>来获得该key的<code>set/get</code>控制权。</p>
<p>解释下上面用到的几个函数的功能：</p>
<ul>
<li><code>observeArray</code>: 遍历数组，对数组的每个元素调用<code>observe</code></li>
<li><code>observe</code>: 检查对象上是否有<code>__ob__</code>属性，如果存在，则表明该对象已经处于<code>Observer</code>的观察中，如果不存在，则<code>new Observer</code>来观察对象（其实还有一些判断逻辑，为了便于理解就不赘述了）</li>
<li><code>walk</code>: 遍历对象的每个key，对对象上每个key的数据调用<code>defineReactive</code></li>
<li><code>defineReactive</code>: 通过<code>Object.defineProperty</code>设置对象的key属性，使得能够捕获到该属性值的<code>set/get</code>动作。一般是由<code>Watcher</code>的实例对象进行<code>get</code>操作，此时<code>Watcher</code>的实例对象将被自动添加到<code>Dep</code>实例的依赖数组中，在外部操作触发了<code>set</code>时，将通过<code>Dep</code>实例的<code>notify</code>来通知所有依赖的<code>watcher</code>进行更新。</li>
</ul>
<p>如果不太理解上面的文字描述可以看一下图：</p>
<img src="/2017/02/16/Vue原理解析之observer模块/flow2.png" alt="flow2.png" title="">
<h2 id="Dep"><a href="#Dep" class="headerlink" title="Dep"></a>Dep</h2><p><code>Dep</code>是<code>Observer</code>与<code>Watcher</code>之间的纽带，也可以认为<code>Dep</code>是服务于<code>Observer</code>的订阅系统。<code>Watcher</code>订阅某个<code>Observer</code>的<code>Dep</code>，当<code>Observer</code>观察的数据发生变化时，通过<code>Dep</code>通知各个已经订阅的<code>Watcher</code>。</p>
<p><code>Dep</code>提供了几个接口：</p>
<ul>
<li><code>addSub</code>: 接收的参数为<code>Watcher</code>实例，并把<code>Watcher</code>实例存入记录依赖的数组中</li>
<li><code>removeSub</code>: 与<code>addSub</code>对应，作用是将<code>Watcher</code>实例从记录依赖的数组中移除</li>
<li><code>depend</code>: <code>Dep.target</code>上存放这当前需要操作的<code>Watcher</code>实例，调用<code>depend</code>会调用该<code>Watcher</code>实例的<code>addDep</code>方法，<code>addDep</code>的功能可以看下面对<code>Watcher</code>的介绍</li>
<li><code>notify</code>: 通知依赖数组中所有的<code>watcher</code>进行更新操作</li>
</ul>
<h2 id="Watcher"><a href="#Watcher" class="headerlink" title="Watcher"></a>Watcher</h2><p><code>Watcher</code>是用来订阅数据的变化的并执行相应操作（例如更新视图）的。<code>Watcher</code>的构造器函数定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">constructor (vm, expOrFn, cb, options) &#123;</div><div class="line">  this.vm = vm</div><div class="line">  vm._watchers.push(this)</div><div class="line">  // options</div><div class="line">  if (options) &#123;</div><div class="line">    this.deep = !!options.deep</div><div class="line">    this.user = !!options.user</div><div class="line">    this.lazy = !!options.lazy</div><div class="line">    this.sync = !!options.sync</div><div class="line">  &#125; else &#123;</div><div class="line">    this.deep = this.user = this.lazy = this.sync = false</div><div class="line">  &#125;</div><div class="line">  this.cb = cb</div><div class="line">  this.id = ++uid // uid for batching</div><div class="line">  this.active = true</div><div class="line">  this.dirty = this.lazy // for lazy watchers</div><div class="line">  this.deps = []</div><div class="line">  this.newDeps = []</div><div class="line">  this.depIds = new Set()</div><div class="line">  this.newDepIds = new Set()</div><div class="line">  this.expression = process.env.NODE_ENV !== &apos;production&apos;</div><div class="line">    ? expOrFn.toString()</div><div class="line">    : &apos;&apos;</div><div class="line">  if (typeof expOrFn === &apos;function&apos;) &#123;</div><div class="line">    this.getter = expOrFn</div><div class="line">  &#125; else &#123;</div><div class="line">    this.getter = parsePath(expOrFn)</div><div class="line">    if (!this.getter) &#123;</div><div class="line">      this.getter = function () &#123;&#125;</div><div class="line">      process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; warn(</div><div class="line">        `Failed watching path: &quot;$&#123;expOrFn&#125;&quot; ` +</div><div class="line">        &apos;Watcher only accepts simple dot-delimited paths. &apos; +</div><div class="line">        &apos;For full control, use a function instead.&apos;,</div><div class="line">        vm</div><div class="line">      )</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  this.value = this.lazy</div><div class="line">    ? undefined</div><div class="line">    : this.get()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>参数中，<code>vm</code>表示组件实例，<code>expOrFn</code>表示要订阅的数据字段（字符串表示，例如<code>a.b.c</code>）或是一个要执行的函数，<code>cb</code>表示watcher运行后的回调函数，<code>options</code>是选项对象，包含<code>deep</code>、<code>user</code>、<code>lazy</code>等配置。</p>
<p><code>watcher</code>实例上有这些方法：</p>
<ul>
<li><code>get</code>: 将<code>Dep.target</code>设置为当前<code>watcher</code>实例，在内部调用<code>this.getter</code>，如果此时某个被<code>Observer</code>观察的数据对象被取值了，那么当前<code>watcher</code>实例将会自动订阅数据对象的<code>Dep</code>实例</li>
<li><code>addDep</code>: 接收参数<code>dep</code>(Dep实例)，让当前<code>watcher</code>订阅<code>dep</code></li>
<li><code>cleanupDeps</code>: 清除<code>newDepIds</code>和<code>newDep</code>上记录的对dep的订阅信息</li>
<li><code>update</code>: 立刻运行<code>watcher</code>或者将<code>watcher</code>加入队列中等待统一flush</li>
<li><code>run</code>: 运行<code>watcher</code>，调用<code>this.get()</code>求值，然后触发回调</li>
<li><code>evaluate</code>: 调用<code>this.get()</code>求值</li>
<li><code>depend</code>: 遍历<code>this.deps</code>，让当前<code>watcher</code>实例订阅所有<code>dep</code></li>
<li><code>teardown</code>: 去除当前<code>watcher</code>实例所有的订阅</li>
</ul>
<h2 id="Array-methods"><a href="#Array-methods" class="headerlink" title="Array methods"></a>Array methods</h2><p>在<code>src/core/observer/array.js</code>中，Vue框架对数组的<code>push</code>、<code>pop</code>、<code>shift</code>、<code>unshift</code>、<code>sort</code>、<code>splice</code>、<code>reverse</code>方法进行了改造，在调用数组的这些方法时，自动触发<code>dep.notify()</code>，解决了调用这些函数改变数组后无法触发更新的问题。在Vue的官方文档中对这个也有说明：<a href="http://cn.vuejs.org/v2/guide/list.html#变异方法" target="_blank" rel="external">http://cn.vuejs.org/v2/guide/list.html#变异方法</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文是针对&lt;code&gt;Vue@2.1.8&lt;/code&gt;进行分析&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;observer&lt;/code&gt;是Vue核心中最重要的一个模块（个人认为），能够实现视图与数据的响应式更新，底层全凭&lt;code&gt;ob
    
    </summary>
    
      <category term="技术" scheme="http://joeray61.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="vue.js" scheme="http://joeray61.com/tags/vue-js/"/>
    
  </entry>
  
  <entry>
    <title>Vue原理解析之Virtual Dom</title>
    <link href="http://joeray61.com/2017/02/08/Vue%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90%E4%B9%8BVirtual-Dom/"/>
    <id>http://joeray61.com/2017/02/08/Vue原理解析之Virtual-Dom/</id>
    <published>2017-02-08T09:54:55.000Z</published>
    <updated>2017-04-04T10:04:04.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>DOM</code>是文档对象模型(<code>Document Object Model</code>)的简写，在浏览器中我们可以通过js来操作<code>DOM</code>，但是这样的操作性能很差，于是<code>Virtual Dom</code>应运而生。我的理解，<code>Virtual Dom</code>就是在js中模拟<code>DOM</code>对象树来优化<code>DOM</code>操作的一种技术或思路。</p>
<p>本文将对于Vue框架2.1.8版本中使用的<code>Virtual Dom</code>进行分析。</p>
<h2 id="VNode对象"><a href="#VNode对象" class="headerlink" title="VNode对象"></a>VNode对象</h2><p>一个VNode的实例对象包含了以下属性</p>
<ul>
<li><code>tag</code>: 当前节点的标签名</li>
<li><code>data</code>: 当前节点的数据对象，具体包含哪些字段可以参考vue源码<code>types/vnode.d.ts</code>中对<code>VNodeData</code>的定义<img src="/2017/02/08/Vue原理解析之Virtual-Dom/img1.png" alt="img1.png" title=""></li>
<li><code>children</code>: 数组类型，包含了当前节点的子节点</li>
<li><code>text</code>: 当前节点的文本，一般文本节点或注释节点会有该属性</li>
<li><code>elm</code>: 当前虚拟节点对应的真实的dom节点</li>
<li><code>ns</code>: 节点的namespace</li>
<li><code>context</code>: 编译作用域</li>
<li><code>functionalContext</code>: 函数化组件的作用域</li>
<li><code>key</code>: 节点的key属性，用于作为节点的标识，有利于patch的优化</li>
<li><code>componentOptions</code>: 创建组件实例时会用到的选项信息</li>
<li><code>child</code>: 当前节点对应的组件实例</li>
<li><code>parent</code>: 组件的占位节点</li>
<li><code>raw</code>: raw html</li>
<li><code>isStatic</code>: 静态节点的标识</li>
<li><code>isRootInsert</code>: 是否作为根节点插入，被<code>&lt;transition&gt;</code>包裹的节点，该属性的值为<code>false</code></li>
<li><code>isComment</code>: 当前节点是否是注释节点</li>
<li><code>isCloned</code>: 当前节点是否为克隆节点</li>
<li><code>isOnce</code>: 当前节点是否有<code>v-once</code>指令</li>
</ul>
<h2 id="VNode分类"><a href="#VNode分类" class="headerlink" title="VNode分类"></a>VNode分类</h2><img src="/2017/02/08/Vue原理解析之Virtual-Dom/img2.png" alt="img2.png" title="">
<p><code>VNode</code>可以理解为vue框架的虚拟dom的基类，通过<code>new</code>实例化的<code>VNode</code>大致可以分为几类</p>
<ul>
<li><code>EmptyVNode</code>: 没有内容的注释节点</li>
<li><code>TextVNode</code>: 文本节点</li>
<li><code>ElementVNode</code>: 普通元素节点</li>
<li><code>ComponentVNode</code>: 组件节点</li>
<li><code>CloneVNode</code>: 克隆节点，可以是以上任意类型的节点，唯一的区别在于<code>isCloned</code>属性为<code>true</code></li>
<li><code>...</code></li>
</ul>
<h2 id="createElement解析"><a href="#createElement解析" class="headerlink" title="createElement解析"></a>createElement解析</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div></pre></td><td class="code"><pre><div class="line">const SIMPLE_NORMALIZE = 1</div><div class="line">const ALWAYS_NORMALIZE = 2</div><div class="line"></div><div class="line">function createElement (context, tag, data, children, normalizationType, alwaysNormalize) &#123;</div><div class="line">  // 兼容不传data的情况</div><div class="line">  if (Array.isArray(data) || isPrimitive(data)) &#123;</div><div class="line">    normalizationType = children</div><div class="line">    children = data</div><div class="line">    data = undefined</div><div class="line">  &#125;</div><div class="line">  // 如果alwaysNormalize是true</div><div class="line">  // 那么normalizationType应该设置为常量ALWAYS_NORMALIZE的值</div><div class="line">  if (alwaysNormalize) normalizationType = ALWAYS_NORMALIZE</div><div class="line">  // 调用_createElement创建虚拟节点</div><div class="line">  return _createElement(context, tag, data, children, normalizationType)</div><div class="line">&#125;</div><div class="line"></div><div class="line">function _createElement (context, tag, data, children, normalizationType) &#123;</div><div class="line">  /**</div><div class="line">   * 如果存在data.__ob__，说明data是被Observer观察的数据</div><div class="line">   * 不能用作虚拟节点的data</div><div class="line">   * 需要抛出警告，并返回一个空节点</div><div class="line">   * </div><div class="line">   * 被监控的data不能被用作vnode渲染的数据的原因是：</div><div class="line">   * data在vnode渲染过程中可能会被改变，这样会触发监控，导致不符合预期的操作</div><div class="line">   */</div><div class="line">  if (data &amp;&amp; data.__ob__) &#123;</div><div class="line">    process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; warn(</div><div class="line">      `Avoid using observed data object as vnode data: $&#123;JSON.stringify(data)&#125;\n` +</div><div class="line">      &apos;Always create fresh vnode data objects in each render!&apos;,</div><div class="line">      context</div><div class="line">    )</div><div class="line">    return createEmptyVNode()</div><div class="line">  &#125;</div><div class="line">  // 当组件的is属性被设置为一个falsy的值</div><div class="line">  // Vue将不会知道要把这个组件渲染成什么</div><div class="line">  // 所以渲染一个空节点</div><div class="line">  if (!tag) &#123;</div><div class="line">    return createEmptyVNode()</div><div class="line">  &#125;</div><div class="line">  // 作用域插槽</div><div class="line">  if (Array.isArray(children) &amp;&amp;</div><div class="line">      typeof children[0] === &apos;function&apos;) &#123;</div><div class="line">    data = data || &#123;&#125;</div><div class="line">    data.scopedSlots = &#123; default: children[0] &#125;</div><div class="line">    children.length = 0</div><div class="line">  &#125;</div><div class="line">  // 根据normalizationType的值，选择不同的处理方法</div><div class="line">  if (normalizationType === ALWAYS_NORMALIZE) &#123;</div><div class="line">    children = normalizeChildren(children)</div><div class="line">  &#125; else if (normalizationType === SIMPLE_NORMALIZE) &#123;</div><div class="line">    children = simpleNormalizeChildren(children)</div><div class="line">  &#125;</div><div class="line">  let vnode, ns</div><div class="line">  // 如果标签名是字符串类型</div><div class="line">  if (typeof tag === &apos;string&apos;) &#123;</div><div class="line">    let Ctor</div><div class="line">    // 获取标签名的命名空间</div><div class="line">    ns = config.getTagNamespace(tag)</div><div class="line">    // 判断是否为保留标签</div><div class="line">    if (config.isReservedTag(tag)) &#123;</div><div class="line">      // 如果是保留标签,就创建一个这样的vnode</div><div class="line">      vnode = new VNode(</div><div class="line">        config.parsePlatformTagName(tag), data, children,</div><div class="line">        undefined, undefined, context</div><div class="line">      )</div><div class="line">      // 如果不是保留标签，那么我们将尝试从vm的components上查找是否有这个标签的定义</div><div class="line">    &#125; else if ((Ctor = resolveAsset(context.$options, &apos;components&apos;, tag))) &#123;</div><div class="line">      // 如果找到了这个标签的定义，就以此创建虚拟组件节点</div><div class="line">      vnode = createComponent(Ctor, data, context, children, tag)</div><div class="line">    &#125; else &#123;</div><div class="line">      // 兜底方案，正常创建一个vnode</div><div class="line">      vnode = new VNode(</div><div class="line">        tag, data, children,</div><div class="line">        undefined, undefined, context</div><div class="line">      )</div><div class="line">    &#125;</div><div class="line">    // 当tag不是字符串的时候，我们认为tag是组件的构造类</div><div class="line">    // 所以直接创建</div><div class="line">  &#125; else &#123;</div><div class="line">    vnode = createComponent(tag, data, context, children)</div><div class="line">  &#125;</div><div class="line">  // 如果有vnode</div><div class="line">  if (vnode) &#123;</div><div class="line">    // 如果有namespace，就应用下namespace，然后返回vnode</div><div class="line">    if (ns) applyNS(vnode, ns)</div><div class="line">    return vnode</div><div class="line">  // 否则，返回一个空节点</div><div class="line">  &#125; else &#123;</div><div class="line">    return createEmptyVNode()</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>简单的梳理了一个流程图，可以参考下</p>
<img src="/2017/02/08/Vue原理解析之Virtual-Dom/img3.png" alt="img3.png" title="">
<h2 id="patch原理"><a href="#patch原理" class="headerlink" title="patch原理"></a>patch原理</h2><p><code>patch</code>函数的定义在<code>src/core/vdom/patch.js</code>中，我们先来看下这个函数的逻辑</p>
<p><code>patch</code>函数接收6个参数：</p>
<ul>
<li><code>oldVnode</code>: 旧的虚拟节点或旧的真实dom节点</li>
<li><code>vnode</code>: 新的虚拟节点</li>
<li><code>hydrating</code>: 是否要跟真是dom混合</li>
<li><code>removeOnly</code>: 特殊flag，用于<code>&lt;transition-group&gt;</code>组件</li>
<li><code>parentElm</code>: 父节点</li>
<li><code>refElm</code>: 新节点将插入到<code>refElm</code>之前</li>
</ul>
<p><code>patch</code>的策略是：</p>
<ol>
<li>如果<code>vnode</code>不存在但是<code>oldVnode</code>存在，说明意图是要销毁老节点，那么就调用<code>invokeDestroyHook(oldVnode)</code>来进行销毁</li>
<li>如果<code>oldVnode</code>不存在但是<code>vnode</code>存在，说明意图是要创建新节点，那么就调用<code>createElm</code>来创建新节点</li>
<li>当<code>vnode</code>和<code>oldVnode</code>都存在时<ul>
<li>如果<code>oldVnode</code>和<code>vnode</code>是同一个节点，就调用<code>patchVnode</code>来进行<code>patch</code></li>
<li>当<code>vnode</code>和<code>oldVnode</code>不是同一个节点时，如果<code>oldVnode</code>是真实dom节点或<code>hydrating</code>设置为<code>true</code>，需要用<code>hydrate</code>函数将虚拟dom和真是dom进行映射，然后将<code>oldVnode</code>设置为对应的虚拟dom，找到<code>oldVnode.elm</code>的父节点，根据vnode创建一个真实dom节点并插入到该父节点中<code>oldVnode.elm</code>的位置</li>
</ul>
</li>
</ol>
<p>这里面值得一提的是<code>patchVnode</code>函数，因为真正的patch算法是由它来实现的（patchVnode中更新子节点的算法其实是在<code>updateChildren</code>函数中实现的，为了便于理解，我统一放到<code>patchVnode</code>中来解释）。</p>
<p><code>patchVnode</code>算法是：</p>
<ol>
<li>如果<code>oldVnode</code>跟<code>vnode</code>完全一致，那么不需要做任何事情</li>
<li>如果<code>oldVnode</code>跟<code>vnode</code>都是静态节点，且具有相同的<code>key</code>，当<code>vnode</code>是克隆节点或是<code>v-once</code>指令控制的节点时，只需要把<code>oldVnode.elm</code>和<code>oldVnode.child</code>都复制到<code>vnode</code>上，也不用再有其他操作</li>
<li>否则，如果<code>vnode</code>不是文本节点或注释节点<ul>
<li>如果<code>oldVnode</code>和<code>vnode</code>都有子节点，且2方的子节点不完全一致，就执行更新子节点的操作（这一部分其实是在<code>updateChildren</code>函数中实现），算法如下<ul>
<li>分别获取<code>oldVnode</code>和<code>vnode</code>的<code>firstChild</code>、<code>lastChild</code>，赋值给<code>oldStartVnode</code>、<code>oldEndVnode</code>、<code>newStartVnode</code>、<code>newEndVnode</code></li>
<li>如果<code>oldStartVnode</code>和<code>newStartVnode</code>是同一节点，调用<code>patchVnode</code>进行<code>patch</code>，然后将<code>oldStartVnode</code>和<code>newStartVnode</code>都设置为下一个子节点，重复上述流程<img src="/2017/02/08/Vue原理解析之Virtual-Dom/img4.png" alt="img4.png" title=""></li>
<li>如果<code>oldEndVnode</code>和<code>newEndVnode</code>是同一节点，调用<code>patchVnode</code>进行<code>patch</code>，然后将<code>oldEndVnode</code>和<code>newEndVnode</code>都设置为上一个子节点，重复上述流程<img src="/2017/02/08/Vue原理解析之Virtual-Dom/img5.png" alt="img5.png" title=""></li>
<li>如果<code>oldStartVnode</code>和<code>newEndVnode</code>是同一节点，调用<code>patchVnode</code>进行<code>patch</code>，如果<code>removeOnly</code>是<code>false</code>，那么可以把<code>oldStartVnode.elm</code>移动到<code>oldEndVnode.elm</code>之后，然后把<code>oldStartVnode</code>设置为下一个节点，<code>newEndVnode</code>设置为上一个节点，重复上述流程<img src="/2017/02/08/Vue原理解析之Virtual-Dom/img6.png" alt="img6.png" title=""></li>
<li>如果<code>newStartVnode</code>和<code>oldEndVnode</code>是同一节点，调用<code>patchVnode</code>进行<code>patch</code>，如果<code>removeOnly</code>是<code>false</code>，那么可以把<code>oldEndVnode.elm</code>移动到<code>oldStartVnode.elm</code>之前，然后把<code>newStartVnode</code>设置为下一个节点，<code>oldEndVnode</code>设置为上一个节点，重复上述流程<img src="/2017/02/08/Vue原理解析之Virtual-Dom/img7.png" alt="img7.png" title=""></li>
<li>如果以上都不匹配，就尝试在<code>oldChildren</code>中寻找跟<code>newStartVnode</code>具有相同<code>key</code>的节点，如果找不到相同<code>key</code>的节点，说明<code>newStartVnode</code>是一个新节点，就创建一个，然后把<code>newStartVnode</code>设置为下一个节点</li>
<li>如果上一步找到了跟<code>newStartVnode</code>相同<code>key</code>的节点，那么通过其他属性的比较来判断这2个节点是否是同一个节点，如果是，就调用<code>patchVnode</code>进行<code>patch</code>，如果<code>removeOnly</code>是<code>false</code>，就把<code>newStartVnode.elm</code>插入到<code>oldStartVnode.elm</code>之前，把<code>newStartVnode</code>设置为下一个节点，重复上述流程<img src="/2017/02/08/Vue原理解析之Virtual-Dom/img8.png" alt="img8.png" title=""></li>
<li>如果在<code>oldChildren</code>中没有寻找到<code>newStartVnode</code>的同一节点，那就创建一个新节点，把<code>newStartVnode</code>设置为下一个节点，重复上述流程</li>
<li>如果<code>oldStartVnode</code>跟<code>oldEndVnode</code>重合了，并且<code>newStartVnode</code>跟<code>newEndVnode</code>也重合了，这个循环就结束了</li>
</ul>
</li>
<li>如果只有<code>oldVnode</code>有子节点，那就把这些节点都删除</li>
<li>如果只有<code>vnode</code>有子节点，那就创建这些子节点</li>
<li>如果<code>oldVnode</code>和<code>vnode</code>都没有子节点，但是<code>oldVnode</code>是文本节点或注释节点，就把<code>vnode.elm</code>的文本设置为空字符串</li>
</ul>
</li>
<li>如果<code>vnode</code>是文本节点或注释节点，但是<code>vnode.text != oldVnode.text</code>时，只需要更新<code>vnode.elm</code>的文本内容就可以</li>
</ol>
<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p><code>patch</code>提供了5个生命周期钩子，分别是</p>
<ul>
<li><code>create</code>: 创建patch时</li>
<li><code>activate</code>: 激活组件时</li>
<li><code>update</code>: 更新节点时</li>
<li><code>remove</code>: 移除节点时</li>
<li><code>destroy</code>: 销毁节点时</li>
</ul>
<p>这些钩子是提供给Vue内部的<code>directives</code>/<code>ref</code>/<code>attrs</code>/<code>style</code>等模块使用的，方便这些模块在patch的不同阶段进行相应的操作，这里模块定义在<code>src/core/vdom/modules</code>和<code>src/platforms/web/runtime/modules</code>2个目录中</p>
<p><code>vnode</code>也提供了生命周期钩子，分别是</p>
<ul>
<li><code>init</code>: vdom初始化时</li>
<li><code>create</code>: vdom创建时</li>
<li><code>prepatch</code>: patch之前</li>
<li><code>insert</code>: vdom插入后</li>
<li><code>update</code>: vdom更新前</li>
<li><code>postpatch</code>: patch之后</li>
<li><code>remove</code>: vdom移除时</li>
<li><code>destroy</code>: vdom销毁时</li>
</ul>
<p>vue组件的生命周期底层其实就依赖于vnode的生命周期，在<code>src/core/vdom/create-component.js</code>中我们可以看到，vue为自己的组件vnode已经写好了默认的<code>init</code>/<code>prepatch</code>/<code>insert</code>/<code>destroy</code>，而vue组件的<code>mounted</code>/<code>activated</code>就是在<code>insert</code>中触发的，<code>deactivated</code>就是在<code>destroy</code>中触发的</p>
<h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><p>在Vue里面，<code>Vue.prototype.$createElement</code>对应vdom的<code>createElement</code>方法，<code>Vue.prototype.__patch__</code>对应<code>patch</code>方法，我写了个简单的demo来验证下功能</p>
<p></p><p data-height="265" data-theme-id="0" data-slug-hash="rjZKZz" data-default-tab="html,result" data-user="JoeRay" data-embed-version="2" data-pen-title="Vue Virtual Dom" class="codepen">See the Pen <a href="http://codepen.io/JoeRay/pen/rjZKZz/" target="_blank" rel="external">Vue Virtual Dom</a> by zhulei (<a href="http://codepen.io/JoeRay" target="_blank" rel="external">@JoeRay</a>) on <a href="http://codepen.io" target="_blank" rel="external">CodePen</a>.</p><p></p>
<script async src="https://production-assets.codepen.io/assets/embed/ei.js"></script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;DOM&lt;/code&gt;是文档对象模型(&lt;code&gt;Document Object Model&lt;/code&gt;)的简写，在浏览器中我们可以通过js来操作&lt;code&gt;DOM&lt;/code&gt;，但是这样的操作性能很差，于是&lt;code&gt;Virtual Dom&lt;/code&gt;应运而
    
    </summary>
    
      <category term="技术" scheme="http://joeray61.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="vue.js" scheme="http://joeray61.com/tags/vue-js/"/>
    
  </entry>
  
  <entry>
    <title>git常用命令速查表</title>
    <link href="http://joeray61.com/2016/12/18/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E9%80%9F%E6%9F%A5%E8%A1%A8/"/>
    <id>http://joeray61.com/2016/12/18/git常用命令速查表/</id>
    <published>2016-12-18T10:03:40.000Z</published>
    <updated>2017-04-04T10:06:13.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文主要是用来记录一些在git管理的项目中常见的场景及其对应的命令，方便自己和他人使用的时候快速查询。如有不对，敬请指正。</p>
<h3 id="查看某个git命令的帮助文档"><a href="#查看某个git命令的帮助文档" class="headerlink" title="查看某个git命令的帮助文档"></a>查看某个git命令的帮助文档</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git help [command]</div></pre></td></tr></table></figure>
<h3 id="查看各个文件的状态"><a href="#查看各个文件的状态" class="headerlink" title="查看各个文件的状态"></a>查看各个文件的状态</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git status</div></pre></td></tr></table></figure>
<h3 id="clone一个仓库"><a href="#clone一个仓库" class="headerlink" title="clone一个仓库"></a>clone一个仓库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git clone [url]</div></pre></td></tr></table></figure>
<h3 id="初始化一个仓库"><a href="#初始化一个仓库" class="headerlink" title="初始化一个仓库"></a>初始化一个仓库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git init</div></pre></td></tr></table></figure>
<h3 id="将文件放到暂存区"><a href="#将文件放到暂存区" class="headerlink" title="将文件放到暂存区"></a>将文件放到暂存区</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git add [file-name]</div></pre></td></tr></table></figure>
<h3 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git commit</div></pre></td></tr></table></figure>
<h3 id="停止跟踪文件并删除文件"><a href="#停止跟踪文件并删除文件" class="headerlink" title="停止跟踪文件并删除文件"></a>停止跟踪文件并删除文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git rm [file-name]</div></pre></td></tr></table></figure>
<h3 id="停止跟踪并删除已修改且添加到暂存区的文件"><a href="#停止跟踪并删除已修改且添加到暂存区的文件" class="headerlink" title="停止跟踪并删除已修改且添加到暂存区的文件"></a>停止跟踪并删除已修改且添加到暂存区的文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git rm -f [file-name]</div></pre></td></tr></table></figure>
<h3 id="停止跟踪但不删除文件"><a href="#停止跟踪但不删除文件" class="headerlink" title="停止跟踪但不删除文件"></a>停止跟踪但不删除文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git rm --cached [file-name]</div></pre></td></tr></table></figure>
<h3 id="移动文件或修改文件名"><a href="#移动文件或修改文件名" class="headerlink" title="移动文件或修改文件名"></a>移动文件或修改文件名</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git mv [old-name] [new-name]</div></pre></td></tr></table></figure>
<h3 id="显示已经放到暂存区的文件的修改"><a href="#显示已经放到暂存区的文件的修改" class="headerlink" title="显示已经放到暂存区的文件的修改"></a>显示已经放到暂存区的文件的修改</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git diff --cached</div></pre></td></tr></table></figure>
<h3 id="显示未放到暂存区的文件的修改"><a href="#显示未放到暂存区的文件的修改" class="headerlink" title="显示未放到暂存区的文件的修改"></a>显示未放到暂存区的文件的修改</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git diff [path/to/file]</div></pre></td></tr></table></figure>
<h3 id="显示当前仓库的所有本地分支"><a href="#显示当前仓库的所有本地分支" class="headerlink" title="显示当前仓库的所有本地分支"></a>显示当前仓库的所有本地分支</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git branch</div></pre></td></tr></table></figure>
<h3 id="显示当前仓库的所有远程分支"><a href="#显示当前仓库的所有远程分支" class="headerlink" title="显示当前仓库的所有远程分支"></a>显示当前仓库的所有远程分支</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git branch -r</div></pre></td></tr></table></figure>
<h3 id="显示当前仓库的所有分支（包括本地和远程）"><a href="#显示当前仓库的所有分支（包括本地和远程）" class="headerlink" title="显示当前仓库的所有分支（包括本地和远程）"></a>显示当前仓库的所有分支（包括本地和远程）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git branch -a</div></pre></td></tr></table></figure>
<h3 id="创建一个本地分支"><a href="#创建一个本地分支" class="headerlink" title="创建一个本地分支"></a>创建一个本地分支</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git branch [branch-name]</div></pre></td></tr></table></figure>
<h3 id="切换到某个本地分支"><a href="#切换到某个本地分支" class="headerlink" title="切换到某个本地分支"></a>切换到某个本地分支</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git checkout [branch-name]</div></pre></td></tr></table></figure>
<h3 id="将某个分支合并到当前分支"><a href="#将某个分支合并到当前分支" class="headerlink" title="将某个分支合并到当前分支"></a>将某个分支合并到当前分支</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git merge [branch-name]</div></pre></td></tr></table></figure>
<h3 id="删除已经被合并的分支"><a href="#删除已经被合并的分支" class="headerlink" title="删除已经被合并的分支"></a>删除已经被合并的分支</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git branch -d [branch-name]</div></pre></td></tr></table></figure>
<h3 id="删除还未被合并的分支"><a href="#删除还未被合并的分支" class="headerlink" title="删除还未被合并的分支"></a>删除还未被合并的分支</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git branch -D [branch-name]</div></pre></td></tr></table></figure>
<h3 id="合并代码后还未提交，此时希望撤销合并"><a href="#合并代码后还未提交，此时希望撤销合并" class="headerlink" title="合并代码后还未提交，此时希望撤销合并"></a>合并代码后还未提交，此时希望撤销合并</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git reset --hard HEAD</div></pre></td></tr></table></figure>
<h3 id="查看所有的提交"><a href="#查看所有的提交" class="headerlink" title="查看所有的提交"></a>查看所有的提交</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git log</div></pre></td></tr></table></figure>
<h3 id="查看所有提交及每个提交对应的代码diff"><a href="#查看所有提交及每个提交对应的代码diff" class="headerlink" title="查看所有提交及每个提交对应的代码diff"></a>查看所有提交及每个提交对应的代码diff</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git log -p</div></pre></td></tr></table></figure>
<h3 id="查看所有提交，以及每个提交涉及的文件，以及这些文件删除-添加了多少行"><a href="#查看所有提交，以及每个提交涉及的文件，以及这些文件删除-添加了多少行" class="headerlink" title="查看所有提交，以及每个提交涉及的文件，以及这些文件删除/添加了多少行"></a>查看所有提交，以及每个提交涉及的文件，以及这些文件删除/添加了多少行</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git log --stat</div></pre></td></tr></table></figure>
<h3 id="查看当前工作目录与某个分支的差别"><a href="#查看当前工作目录与某个分支的差别" class="headerlink" title="查看当前工作目录与某个分支的差别"></a>查看当前工作目录与某个分支的差别</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git diff [branch-name]</div></pre></td></tr></table></figure>
<h3 id="查看当前工作目录下的某个目录与某个分支的差别"><a href="#查看当前工作目录下的某个目录与某个分支的差别" class="headerlink" title="查看当前工作目录下的某个目录与某个分支的差别"></a>查看当前工作目录下的某个目录与某个分支的差别</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git diff [branch-name] -- [path]</div></pre></td></tr></table></figure>
<h3 id="修改最后一次提交"><a href="#修改最后一次提交" class="headerlink" title="修改最后一次提交"></a>修改最后一次提交</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git commit --amend</div></pre></td></tr></table></figure>
<h3 id="撤销已暂存的文件"><a href="#撤销已暂存的文件" class="headerlink" title="撤销已暂存的文件"></a>撤销已暂存的文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git reset HEAD [file-name]</div></pre></td></tr></table></figure>
<h3 id="撤销对文件的修改"><a href="#撤销对文件的修改" class="headerlink" title="撤销对文件的修改"></a>撤销对文件的修改</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git checkout -- [file-name]</div></pre></td></tr></table></figure>
<h3 id="查看当前配置的远程仓库"><a href="#查看当前配置的远程仓库" class="headerlink" title="查看当前配置的远程仓库"></a>查看当前配置的远程仓库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git remote</div></pre></td></tr></table></figure>
<h3 id="查看当前配置的远程仓库和对应的地址"><a href="#查看当前配置的远程仓库和对应的地址" class="headerlink" title="查看当前配置的远程仓库和对应的地址"></a>查看当前配置的远程仓库和对应的地址</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git remote -v</div></pre></td></tr></table></figure>
<h3 id="添加远程仓库"><a href="#添加远程仓库" class="headerlink" title="添加远程仓库"></a>添加远程仓库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git remote add [remote-name] [url]</div></pre></td></tr></table></figure>
<h3 id="从远程仓库抓去数据"><a href="#从远程仓库抓去数据" class="headerlink" title="从远程仓库抓去数据"></a>从远程仓库抓去数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git fetch [remote-name] [branch-name]</div></pre></td></tr></table></figure>
<h3 id="推送数据到远程仓库"><a href="#推送数据到远程仓库" class="headerlink" title="推送数据到远程仓库"></a>推送数据到远程仓库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git push [remote-name] [branch-name]</div></pre></td></tr></table></figure>
<h3 id="查看某个远程仓库信息"><a href="#查看某个远程仓库信息" class="headerlink" title="查看某个远程仓库信息"></a>查看某个远程仓库信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git remote show [remote-name]</div></pre></td></tr></table></figure>
<h3 id="重命名远程仓库"><a href="#重命名远程仓库" class="headerlink" title="重命名远程仓库"></a>重命名远程仓库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git remote rename [old-name] [new-name]</div></pre></td></tr></table></figure>
<h3 id="删除某个远程仓库"><a href="#删除某个远程仓库" class="headerlink" title="删除某个远程仓库"></a>删除某个远程仓库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git remote rm [remote-name]</div></pre></td></tr></table></figure>
<h3 id="显示已有的标签"><a href="#显示已有的标签" class="headerlink" title="显示已有的标签"></a>显示已有的标签</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git tag</div></pre></td></tr></table></figure>
<h3 id="搜索特定tag"><a href="#搜索特定tag" class="headerlink" title="搜索特定tag"></a>搜索特定tag</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git tag -l [keyword]</div></pre></td></tr></table></figure>
<h3 id="创建轻量级标签"><a href="#创建轻量级标签" class="headerlink" title="创建轻量级标签"></a>创建轻量级标签</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git tag [tag-name]</div></pre></td></tr></table></figure>
<h3 id="创建含附注标签"><a href="#创建含附注标签" class="headerlink" title="创建含附注标签"></a>创建含附注标签</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git tag -a [tag-name] -m [msg]</div></pre></td></tr></table></figure>
<h3 id="给之前的某个提交加标签"><a href="#给之前的某个提交加标签" class="headerlink" title="给之前的某个提交加标签"></a>给之前的某个提交加标签</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git tag -a [tag-name] [hash]</div></pre></td></tr></table></figure>
<h3 id="查看某个标签的信息"><a href="#查看某个标签的信息" class="headerlink" title="查看某个标签的信息"></a>查看某个标签的信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git show [tag-name]</div></pre></td></tr></table></figure>
<h3 id="将标签推送到远程仓库"><a href="#将标签推送到远程仓库" class="headerlink" title="将标签推送到远程仓库"></a>将标签推送到远程仓库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git push [remote-name] [tag-name]</div></pre></td></tr></table></figure>
<h3 id="将所有本地标签一次推送到远程仓库"><a href="#将所有本地标签一次推送到远程仓库" class="headerlink" title="将所有本地标签一次推送到远程仓库"></a>将所有本地标签一次推送到远程仓库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git push [remote-name] --tags</div></pre></td></tr></table></figure>
<h3 id="将分支b衍合入分支a"><a href="#将分支b衍合入分支a" class="headerlink" title="将分支b衍合入分支a"></a>将分支b衍合入分支a</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git checkout b</div><div class="line">git rebase a</div></pre></td></tr></table></figure>
<h3 id="切换到另一个分支前，你并不想把当前分支上的修改提交的话，可以使用储藏功能"><a href="#切换到另一个分支前，你并不想把当前分支上的修改提交的话，可以使用储藏功能" class="headerlink" title="切换到另一个分支前，你并不想把当前分支上的修改提交的话，可以使用储藏功能"></a>切换到另一个分支前，你并不想把当前分支上的修改提交的话，可以使用储藏功能</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git stash</div></pre></td></tr></table></figure>
<h3 id="显示所有储藏"><a href="#显示所有储藏" class="headerlink" title="显示所有储藏"></a>显示所有储藏</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git stash list</div></pre></td></tr></table></figure>
<h3 id="应用你的储藏"><a href="#应用你的储藏" class="headerlink" title="应用你的储藏"></a>应用你的储藏</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git stash apply [stash-name]</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本文主要是用来记录一些在git管理的项目中常见的场景及其对应的命令，方便自己和他人使用的时候快速查询。如有不对，敬请指正。&lt;/p&gt;
&lt;h3 
    
    </summary>
    
      <category term="技术" scheme="http://joeray61.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="git" scheme="http://joeray61.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>webpack入门指南</title>
    <link href="http://joeray61.com/2016/09/25/webpack%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/"/>
    <id>http://joeray61.com/2016/09/25/webpack入门指南/</id>
    <published>2016-09-25T10:06:23.000Z</published>
    <updated>2017-04-04T10:10:57.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>本文是一个简单的webpack入门教程，希望能够帮助webpack初学者快速上手。如有错误，敬请斧正。<br>本文所有的demo都可以在<a href="https://github.com/Joe3Ray/webpack-demo/tree/master" target="_blank" rel="external">webpack-demo</a>里找到，<code>git clone</code>之后需要执行<code>npm install</code>安装所有依赖包。</p>
</blockquote>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><code>webpack</code>是一个模块打包工具，出自德国开发者<code>Tobias Koppers</code>之手，处理速度很快。在<code>webpack</code>看来，一切资源都可以是一个模块，不仅限于js文件。正是由于这些特点，使得<code>webpack</code>可以替代<code>Grunt</code>和<code>Gulp</code>，成为了目前业内最火的前端构建工具。</p>
<img src="/2016/09/25/webpack入门指南/img1.png" alt="img1.png" title="">
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>webpack可以安装到全局，也可以作为项目的依赖工具安装到项目中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">// 全局安装</div><div class="line">$ npm install -g webpack</div><div class="line">$ npm install -g webpack-dev-server</div></pre></td></tr></table></figure>
<p>如果报没有权限的话，在命令前面加上<code>sudo</code>就可以了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">// 局部安装</div><div class="line">$ npm install --save-dev webpack</div><div class="line">$ npm install --save-dev webpack-dev-server</div></pre></td></tr></table></figure>
<p>可以看到，我们在安装<code>webpack</code>的同时，也安装了<code>webpack-dev-server</code>。那么<code>webpack-dev-server</code>是什么呢？它是一个轻量级的基于<code>express</code>的<code>node.js</code>服务器，用来服务资源文件。不是必须的，但是建议一起安装。</p>
<h1 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ webpack main.js bundle.js</div></pre></td></tr></table></figure>
<p>以上是直接使用<code>webpack</code>命令行来进行打包的命令，把<code>main.js</code>构建成<code>bundle.js</code>，具体示例可以查看<a href="https://github.com/Joe3Ray/webpack-demo/tree/master/demo1" target="_blank" rel="external">demo1</a>，在文件夹中执行上方的命令即可。</p>
<p><code>webpack</code>有一些参数是我们应该要知道的</p>
<ul>
<li><code>webpack</code>: 构建一次开发版本</li>
<li><code>webpack -p</code>: 构建一次产品版本，与开发版本的区别是会对文件进行压缩</li>
<li><code>webpack -d</code>: 添加<code>source map</code></li>
<li><code>webpack --watch</code>: 监听文件的改动，持续增量构建</li>
<li><code>webpack --colors</code>: 让命令行的输出更好看一点（实际使用<code>zsh</code>的命令行时发现并没有区别）</li>
</ul>
<h1 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h1><p><code>webpack</code>还有很多强大的功能，这些都可以在命令行使用，但是如果都写在命令行，既不方便使用，也不能直观地反映各个配置项，这时候，就需要配置文件登场了。</p>
<p><code>webpack</code>默认使用的配置文件名是<code>webpack.config.js</code>，也可以通过<code>--config</code>参数在命令行指定另一个命名的配置文件。配置文件其实也是一个模块，所有的构建信息都放在<code>module.exports</code>中。下面我们就来讲一讲各个重要的配置项。</p>
<blockquote>
<p>以下各个示例请在各demo文件夹中执行<code>webpack-dev-server</code>进行查看</p>
</blockquote>
<h2 id="入口文件"><a href="#入口文件" class="headerlink" title="入口文件"></a>入口文件</h2><p>入口文件的配置项名称是<code>entry</code>，代表了<code>webpack</code>给整个项目进行打包的一个主入口，可以搭配<code>output</code>属性指定的输出文件来使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">// webpack.config.js</div><div class="line"></div><div class="line">module.exports = &#123;</div><div class="line">    entry: &apos;main.js&apos;,</div><div class="line">    output: &#123;</div><div class="line">        filename: &apos;bundle.js&apos;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// index.html</div><div class="line"></div><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html lang=&quot;en&quot;&gt;</div><div class="line">&lt;head&gt;</div><div class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</div><div class="line">    &lt;title&gt;Demo2&lt;/title&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">    &lt;script src=&quot;bundle.js&quot;&gt;&lt;/script&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div><div class="line"></div><div class="line">// main.js</div><div class="line"></div><div class="line">document.write(&apos;&lt;h1&gt;Hello Webpack!&lt;/h1&gt;&apos;);</div></pre></td></tr></table></figure>
<p>示例见<a href="https://github.com/Joe3Ray/webpack-demo/tree/master/demo2" target="_blank" rel="external">demo2</a></p>
<h2 id="多入口文件"><a href="#多入口文件" class="headerlink" title="多入口文件"></a>多入口文件</h2><p>在多页的应用中，我们需要有多个入口文件，这在<code>webpack</code>中也是可以支持的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">// webpack.config.js</div><div class="line"></div><div class="line">module.exports = &#123;</div><div class="line">    entry: &#123;</div><div class="line">        profile: &apos;./profile.js&apos;,</div><div class="line">        feed: &apos;./feed.js&apos;</div><div class="line">    &#125;,</div><div class="line">    output: &#123;</div><div class="line">        filename: &apos;[name].bundle.js&apos;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// feed.html</div><div class="line"></div><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html lang=&quot;en&quot;&gt;</div><div class="line">&lt;head&gt;</div><div class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</div><div class="line">    &lt;title&gt;Demo3-Feed&lt;/title&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">    &lt;script src=&quot;feed.bundle.js&quot;&gt;&lt;/script&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div><div class="line"></div><div class="line">// feed.js</div><div class="line"></div><div class="line">document.write(&apos;&lt;h1&gt;Hello Feed!&lt;/h1&gt;&apos;);</div><div class="line"></div><div class="line">// profile.html</div><div class="line"></div><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html lang=&quot;en&quot;&gt;</div><div class="line">&lt;head&gt;</div><div class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</div><div class="line">    &lt;title&gt;Demo3-Profile&lt;/title&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">    &lt;script src=&quot;profile.bundle.js&quot;&gt;&lt;/script&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div><div class="line"></div><div class="line">// profile.js</div><div class="line"></div><div class="line">document.write(&apos;&lt;h1&gt;Hello Profile!&lt;/h1&gt;&apos;);</div></pre></td></tr></table></figure>
<p>示例见<a href="https://github.com/Joe3Ray/webpack-demo/tree/master/demo3" target="_blank" rel="external">demo3</a>，在demo3文件夹中启动<code>webpack-dev-server</code>，访问<code>localhost:8080/profile.html</code>和<code>localhost:8080/feed.html</code>查看效果。</p>
<h2 id="Loaders"><a href="#Loaders" class="headerlink" title="Loaders"></a>Loaders</h2><p><code>Loaders</code>顾名思义就是加载器，用于加载各种格式的文件，例如<code>React</code>使用的<code>JSX</code>，<code>ES6</code>和<code>ES7</code>，图片、<code>CSS</code>、<code>JSON</code>文件等，可谓是<code>webpack</code>中最核心的功能之一。官方文档中列出了所有可用的<a href="http://webpack.github.io/docs/list-of-loaders.html" target="_blank" rel="external">loaders</a>。</p>
<p><code>loaders</code>配置在<code>module.exports</code>中的<code>module</code>字段下（说起来有点绕，待会儿看代码就懂了），是一个数组，代表<code>loader</code>的集合，每一个<code>loader</code>有几个配置项：</p>
<ul>
<li><code>test</code>: 正则表达式，用于匹配文件的路径，一般都直接用来匹配文件后缀，在复杂的场景下，可以针对同一类型的不同文件做不同处理</li>
<li><code>loader</code>: <code>loader</code>的名称，实际使用时可以省略<code>-loader</code>的后缀（例如<code>css-loader</code>，可以写成<code>css</code>）</li>
<li><code>include</code>: 必须包含的文件路径</li>
<li><code>exclude</code>: 不需要处理的文件路径</li>
<li><code>query</code>: <code>loader</code>的额外设置选项</li>
</ul>
<p>下面我介绍几个常用的loader。</p>
<h3 id="CSS-Loader"><a href="#CSS-Loader" class="headerlink" title="CSS Loader"></a>CSS Loader</h3><p>先安装<code>style-loader</code>和<code>css-loader</code>。其中，<code>style-loader</code>用来向 HTML 页面中插入<code>&lt;style&gt;</code>，<code>css-loader</code>用来读取 css 文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install --save-dev style-loader css-loader</div></pre></td></tr></table></figure>
<p>然后在<code>webpack.config.js</code>中配置<code>loader</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">module.exports = &#123;</div><div class="line">    entry: &apos;./main.js&apos;,</div><div class="line">    output: &#123;</div><div class="line">        filename: &apos;bundle.js&apos;</div><div class="line">    &#125;,</div><div class="line">    module: &#123;</div><div class="line">        loaders: [</div><div class="line">            &#123;</div><div class="line">                test: /\.css$/,</div><div class="line">                loader: &apos;style!css&apos;</div><div class="line">            &#125;</div><div class="line">        ]</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// index.html</div><div class="line"></div><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html lang=&quot;en&quot;&gt;</div><div class="line">&lt;head&gt;</div><div class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</div><div class="line">    &lt;title&gt;Demo4&lt;/title&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">    &lt;h1&gt;Hello World!&lt;/h1&gt;</div><div class="line">    &lt;script src=&quot;bundle.js&quot;&gt;&lt;/script&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div><div class="line"></div><div class="line">// a.css</div><div class="line"></div><div class="line">h1 &#123;color: red;&#125;</div><div class="line"></div><div class="line">// main.js</div><div class="line"></div><div class="line">require(&apos;./a.css&apos;);</div></pre></td></tr></table></figure>
<p>示例见<a href="https://github.com/Joe3Ray/webpack-demo/tree/master/demo4" target="_blank" rel="external">demo4</a>，可以看到，多个<code>loader</code>之间用<code>!</code>连接。在本地用<code>webpack-dev-server</code>启动服务，访问<code>localhost:8080</code>可以看到<code>h1</code>中的字体颜色如<code>a.css</code>定义的那样显示红色</p>
<img src="/2016/09/25/webpack入门指南/img2.png" alt="img2.png" title="">
<p>这个 demo 中的 css 是对全局生效的，如果需要只对当前模块生效，就要用到我们下面介绍的<code>css module</code>。</p>
<h3 id="CSS-Module"><a href="#CSS-Module" class="headerlink" title="CSS Module"></a>CSS Module</h3><p>近几年，模块化这个概念在前端被不断地被提及。模块化使得代码被分割成一个个更小的、独立的、可维护性更高的独立单元。相比于<code>JS</code>，<code>CSS</code>的模块化发展的相对慢一点。最近出现了一个叫做<code>css modules</code>的技术，在css模块中，所有的类名和动画名默认只对向前模块生效。<code>webpack</code>对<code>css module</code>提供了不错的支持，只需要在<code>css-loader</code>后面加上<code>?module</code>即可使用。如果要对全局生效，可以使用<code>:global()</code>，把选择器作为参数传入。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">// webpack.config.js</div><div class="line"></div><div class="line">module.exports = &#123;</div><div class="line">    entry: &apos;./main.js&apos;,</div><div class="line">    output: &#123;</div><div class="line">        filename: &apos;bundle.js&apos;</div><div class="line">    &#125;,</div><div class="line">    module: &#123;</div><div class="line">        loaders: [</div><div class="line">            &#123;</div><div class="line">                test: /\.css$/,</div><div class="line">                loader: &apos;style!css?module&apos;</div><div class="line">            &#125;</div><div class="line">        ]</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// index.html</div><div class="line"></div><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html lang=&quot;en&quot;&gt;</div><div class="line">&lt;head&gt;</div><div class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</div><div class="line">    &lt;title&gt;Demo5&lt;/title&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">    &lt;div class=&quot;foo&quot;&gt;Foo&lt;/div&gt;</div><div class="line">    &lt;div class=&quot;bar&quot;&gt;Bar&lt;/div&gt;</div><div class="line">    &lt;script src=&quot;bundle.js&quot;&gt;&lt;/script&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div><div class="line"></div><div class="line">// a.css</div><div class="line"></div><div class="line">.foo &#123;color: red;&#125;</div><div class="line">:global(.bar) &#123;</div><div class="line">    color: green;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// main.js</div><div class="line"></div><div class="line">var style = require(&apos;./a.css&apos;);</div><div class="line"></div><div class="line">document.write(&apos;&lt;div class=&apos; + style.foo + &apos;&gt;Module - Foo&lt;/div&gt;&apos;);</div><div class="line">document.write(&apos;&lt;div class=&quot;bar&quot;&gt;Module - Bar&lt;/div&gt;&apos;);</div></pre></td></tr></table></figure>
<p>需要注意的是，在<code>main.js</code>中使用时，必须用变量<code>style.foo</code>，直接写成<code>class=&quot;foo&quot;</code>是不会生效的，因为<code>a.css</code>中的<code>.foo</code>的类名被编译了，所以导出的<code>style.foo</code>将不等于<code>foo</code>。</p>
<p>示例代码见<a href="https://github.com/Joe3Ray/webpack-demo/tree/master/demo5" target="_blank" rel="external">demo5</a>。在 demo5 的目录下执行<code>webpack-dev-server</code>，在浏览器中打开<code>localhost:8080</code>，可以看到对应的效果。</p>
<img src="/2016/09/25/webpack入门指南/img3.png" alt="img3.png" title="">
<h3 id="Url-Loader"><a href="#Url-Loader" class="headerlink" title="Url Loader"></a>Url Loader</h3><p>先安装<code>url-loader</code>和<code>file-loader</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install --save-dev url-loader file-loader</div></pre></td></tr></table></figure>
<blockquote>
<p>注意，<code>url-loader</code>对<code>file-loader</code>有依赖，但是安装<code>url-loader</code>时不会自动安装<code>file-loader</code>，这里我暂时没有花时间去了解原因，先都手动安装吧。如果不安装<code>file-loader</code>，超过<code>limit</code>大小的文件将无法加载。</p>
</blockquote>
<p><code>url-loader</code>是一个文件加载器，我们可以给他设定一个<code>limit</code>，用来限定文件大小，文件小于这个大小时会被转换成一个<code>Data Url</code>，反之转换成普通url表示资源路径。我们常用<code>url-loader</code>来加载图片。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">// webpack.config.js</div><div class="line"></div><div class="line">module.exports = &#123;</div><div class="line">    entry: &apos;./main.js&apos;,</div><div class="line">    output: &#123;</div><div class="line">        filename: &apos;bundle.js&apos;</div><div class="line">    &#125;,</div><div class="line">    module: &#123;</div><div class="line">        loaders: [</div><div class="line">            &#123;</div><div class="line">                test: /\.(png|jpg)$/,</div><div class="line">                loader: &apos;url-loader?limit=8192&apos;</div><div class="line">            &#125;</div><div class="line">        ]</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// index.html</div><div class="line"></div><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html lang=&quot;en&quot;&gt;</div><div class="line">&lt;head&gt;</div><div class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</div><div class="line">    &lt;title&gt;Demo6&lt;/title&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">    &lt;script src=&quot;bundle.js&quot;&gt;&lt;/script&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div><div class="line"></div><div class="line">// main.js</div><div class="line"></div><div class="line">var img1 = new Image();</div><div class="line">img1.src = require(&apos;./webpack.png&apos;);</div><div class="line">document.body.appendChild(img1);</div><div class="line"></div><div class="line">var img2 = new Image();</div><div class="line">img2.src = require(&apos;./wade.jpg&apos;);</div><div class="line">document.body.appendChild(img2);</div></pre></td></tr></table></figure>
<p>示例代码见<a href="https://github.com/Joe3Ray/webpack-demo/tree/master/demo6" target="_blank" rel="external">demo6</a>。在demo6目录下运行<code>webpack-dev-server</code>，在浏览器中访问<code>localhost:8080</code>，审查元素可以看到，8k以下的图片使用了<code>Data Url</code>，8k以上的图片使用的是资源地址。</p>
<img src="/2016/09/25/webpack入门指南/img4.png" alt="img4.png" title="">
<h3 id="Babel-Loader"><a href="#Babel-Loader" class="headerlink" title="Babel Loader"></a>Babel Loader</h3><p>现如今，<code>ES6</code>、<code>React</code>可谓是红透半边天，说起<code>ES6</code>、<code>React</code>，就不得不提<code>Babel</code>了。<code>Babel</code>是一个 Javascript 编译工具，可以让你现在就能使用目前还未被浏览器完全支持的下一代JS（ES6/ES7）,或是基于 JS 进行扩展的 JSX 等。</p>
<p>我们先安装需要的包</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install --save-dev babel-core babel-loader babel-preset-es2015 babel-preset-react react react-dom</div></pre></td></tr></table></figure>
<p>其中，<code>babel-core</code>是<code>babel</code>的核心功能，<code>babel-loader</code>是<code>webpack</code>使用的<code>babel</code>加载器，<code>babel-preset-es2015</code>和<code>babel-preset-react</code>是<code>babel</code>用来解析<code>ES6</code>和<code>JSX</code>的包，<code>react</code>和<code>react-dom</code>是开发<code>react</code>的依赖包。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">// webpack.config.js</div><div class="line"></div><div class="line">module.exports = &#123;</div><div class="line">    entry: &apos;./main.jsx&apos;,</div><div class="line">    output: &#123;</div><div class="line">        filename: &apos;bundle.js&apos;</div><div class="line">    &#125;,</div><div class="line">    module: &#123;</div><div class="line">        loaders: [</div><div class="line">            &#123;</div><div class="line">                test: /\.js[x]?$/,</div><div class="line">                exclude: /node_modules/,</div><div class="line">                loader: &apos;babel-loader&apos;,</div><div class="line">                query: &#123;</div><div class="line">                    presets: [&apos;es2015&apos;, &apos;react&apos;]</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        ]</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// index.html</div><div class="line"></div><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html lang=&quot;en&quot;&gt;</div><div class="line">&lt;head&gt;</div><div class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</div><div class="line">    &lt;title&gt;Demo7&lt;/title&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">    &lt;div id=&quot;root&quot;&gt;&lt;/div&gt;</div><div class="line">    &lt;script src=&quot;bundle.js&quot;&gt;&lt;/script&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div><div class="line"></div><div class="line">// main.jsx</div><div class="line"></div><div class="line">import React from &apos;react&apos;;</div><div class="line">import &#123;render&#125; from &apos;react-dom&apos;;</div><div class="line"></div><div class="line">render(</div><div class="line">    &lt;h1&gt;Hello world!&lt;/h1&gt;,</div><div class="line">    document.querySelector(&apos;#root&apos;)</div><div class="line">);</div></pre></td></tr></table></figure>
<p>可以看到，在这个配置中，我们把<code>babel-loader</code>的配置写在<code>query</code>字段中。其实也可以直接写在<code>loader</code>字段中，<code>loader: &#39;babel-loader?presets[]=es2015&amp;presets[]=react&#39;</code>，但是这样就不是太清晰了，建议配置比较长时拿出来放到<code>query</code>字段中去。</p>
<p>示例代码见<a href="https://github.com/Joe3Ray/webpack-demo/tree/master/demo7" target="_blank" rel="external">demo7</a>，在demo7目录下执行<code>webpack-dev-server</code>，在浏览器中访问<code>localhost:8080</code>查看效果。</p>
<h2 id="Plugins"><a href="#Plugins" class="headerlink" title="Plugins"></a>Plugins</h2><p><code>plugins</code>是<code>webpack</code>中另一个非常重要且又用的配置，它与<code>loaders</code>的区别在于，<code>loader</code>是用来加载文件的，会逐个文件处理，而<code>plugins</code>是作为<code>webpack</code>功能的补充，整个构建过程都在持续发挥作用。下面我来给大家介绍几个常用的插件。</p>
<h3 id="UglifyJS-Plugin"><a href="#UglifyJS-Plugin" class="headerlink" title="UglifyJS Plugin"></a>UglifyJS Plugin</h3><p>这个插件估计很多人看名字就猜出来了，是用于压缩 JS 代码的。它是<code>webpack</code>的内置插件，不需要安装就可以使用。</p>
<p>直接上代码吧:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">// webpack.config.js</div><div class="line"></div><div class="line">var webpack = require(&apos;webpack&apos;);</div><div class="line">var UglifyJsPlugin = webpack.optimize.UglifyJsPlugin;</div><div class="line"></div><div class="line">module.exports = &#123;</div><div class="line">    entry: &apos;./main.js&apos;,</div><div class="line">    output: &#123;</div><div class="line">        filename: &apos;bundle.js&apos;</div><div class="line">    &#125;,</div><div class="line">    plugins: [</div><div class="line">        new UglifyJsPlugin()</div><div class="line">    ]</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// index.html</div><div class="line"></div><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html lang=&quot;en&quot;&gt;</div><div class="line">&lt;head&gt;</div><div class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</div><div class="line">    &lt;title&gt;Demo8&lt;/title&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">    &lt;script src=&quot;bundle.js&quot;&gt;&lt;/script&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div><div class="line"></div><div class="line">// main.js</div><div class="line"></div><div class="line">var name = &apos;JoeRay61&apos;;</div><div class="line">var age = 24;</div><div class="line">document.write(&apos;My name is &apos; + name + &apos;, I\&apos;m &apos; + age + &apos; years old.&apos;);</div></pre></td></tr></table></figure>
<p>示例代码见<a href="https://github.com/Joe3Ray/webpack-demo/tree/master/demo8" target="_blank" rel="external">demo8</a>。在demo8目录下执行<code>webpack-dev-server</code>，在浏览器中访问<code>localhost:8080</code>，打开开发这工具，可以看到bundle.js的代码被压缩成了一行，变量名也被替换了，说明插件生效了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">!function(r)&#123;function e(t)&#123;if(o[t])return o[t].exports;var n=o[t]=&#123;exports:&#123;&#125;,id:t,loaded:!1&#125;;return r[t].call(n.exports,n,n.exports,e),n.loaded=!0,n.exports&#125;var o=&#123;&#125;;return e.m=r,e.c=o,e.p=&quot;&quot;,e(0)&#125;([function(r,e)&#123;var o=&quot;JoeRay61&quot;,t=24;document.write(&quot;My name is &quot;+o+&quot;, I&apos;m &quot;+t+&quot; years old.&quot;)&#125;]);</div></pre></td></tr></table></figure>
<h3 id="Feature-Flags"><a href="#Feature-Flags" class="headerlink" title="Feature Flags"></a>Feature Flags</h3><p>想象这样一种场景，我们希望在开发环境中在代码中输出一些调试信息，那么如何在<code>webpack</code>中实现呢。这时候就需要用上<code>Feature Flags</code>。它是借由<code>webpack</code>的自定义插件机制实现的全局环境变量，我们可以在代码中判这些全局变量的值来实现定制化的功能。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">// webpack.config.js</div><div class="line"></div><div class="line">var webpack = require(&apos;webpack&apos;);</div><div class="line">var flags = new webpack.DefinePlugin(&#123;</div><div class="line">    __PROD__: JSON.stringify(JSON.parse(process.env.PROD || &apos;false&apos;))</div><div class="line">&#125;);</div><div class="line"></div><div class="line">module.exports = &#123;</div><div class="line">    entry: &apos;./main.js&apos;,</div><div class="line">    output: &#123;</div><div class="line">        filename: &apos;bundle.js&apos;</div><div class="line">    &#125;,</div><div class="line">    plugins: [flags]</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// index.html</div><div class="line"></div><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html lang=&quot;en&quot;&gt;</div><div class="line">&lt;head&gt;</div><div class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</div><div class="line">    &lt;title&gt;Demo9&lt;/title&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">    &lt;script src=&quot;bundle.js&quot;&gt;&lt;/script&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div><div class="line"></div><div class="line">// main.js</div><div class="line"></div><div class="line">document.write(&apos;&lt;h1&gt;Hello world!&lt;/h1&gt;&apos;);</div><div class="line">if (!__PROD__) &#123;</div><div class="line">    document.write(&apos;&lt;p&gt;it is dev version&lt;/p&gt;&apos;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>示例代码见<a href="https://github.com/Joe3Ray/webpack-demo/tree/master/demo9" target="_blank" rel="external">demo9</a>。进入demo9目录，分别执行<code>PROD=1 webpack-dev-server</code>和<code>webpack-dev-server</code>，在浏览器中访问<code>localhost:8080</code>，可以看到区别。</p>
<img src="/2016/09/25/webpack入门指南/img5.png" alt="img5.png" title="">
<img src="/2016/09/25/webpack入门指南/img6.png" alt="img6.png" title="">
<h3 id="Hot-Module-Replacement"><a href="#Hot-Module-Replacement" class="headerlink" title="Hot Module Replacement"></a>Hot Module Replacement</h3><p><code>HMR</code>是<code>webpack</code>中一个激动人心的功能，中文直译叫<code>模块热替换</code>，是指配合<code>webpack-dev-server</code>的服务器，在你修改了项目的模块之后，不需要手动刷新页面，即可以看到更新后的效果，有效地提升了开发效率。</p>
<p>配合<code>webpack-dev-server</code>，我们有2种方式可以启用该功能：</p>
<ol>
<li><p>在命令中中<code>webpack-dev-server</code>命令后面追加<code>--hot</code>和<code>--inline</code>参数</p>
<ul>
<li><code>--hot</code>: 添加HMR插件，将服务器切换到 hot 模式</li>
<li><code>--inline</code>: 将<code>webpack-dev-server</code>的 runtime 加入到打包后的文件中</li>
<li><code>--hot --inline</code>: 当这两个参数并存时，会额外添加一个<code>webpack/hot/dev-server</code>的<code>entry</code></li>
</ul>
</li>
<li><p>配置<code>webpack.config.js</code></p>
<ul>
<li>添加<code>new webpack.HotModuleReplacementPlugin()</code>插件</li>
<li>添加<code>webpack/hot/dev-server</code>和<code>webpack-dev-server/client?http://localhost:8080</code>这2个<code>entry</code></li>
</ul>
</li>
</ol>
<p>针对第2中方式我们来测试一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">// webpack.config.js</div><div class="line"></div><div class="line">var webpack = require(&apos;webpack&apos;);</div><div class="line"></div><div class="line">module.exports = &#123;</div><div class="line">    entry: [</div><div class="line">        &apos;webpack/hot/dev-server&apos;,</div><div class="line">        &apos;webpack-dev-server/client?http://localhost:8080&apos;,</div><div class="line">        &apos;./main.js&apos;</div><div class="line">    ],</div><div class="line">    output: &#123;</div><div class="line">        filename: &apos;bundle.js&apos;</div><div class="line">    &#125;,</div><div class="line">    plugins: [</div><div class="line">        new webpack.HotModuleReplacementPlugin()</div><div class="line">    ]</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// index.html</div><div class="line"></div><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html lang=&quot;en&quot;&gt;</div><div class="line">&lt;head&gt;</div><div class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</div><div class="line">    &lt;title&gt;Demo10&lt;/title&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">    &lt;script src=&quot;bundle.js&quot;&gt;&lt;/script&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div><div class="line"></div><div class="line">// main.js</div><div class="line"></div><div class="line">document.write(&apos;&lt;h1&gt;Hello world!&lt;/h1&gt;&apos;);</div></pre></td></tr></table></figure>
<blockquote>
<p>注意，测试过程中我发现，如果原来是全局安装的<code>webpack-dev-server</code>，必须要在项目中局部安装<code>webpack-dev-server</code>，否则启动服务器时会报错<br>安装命令<code>$ npm install --save-dev webpack-dev-server</code></p>
</blockquote>
<p>示例代码见<a href="https://github.com/Joe3Ray/webpack-demo/tree/master/demo10" target="_blank" rel="external">demo10</a>。在demo10目录下，执行<code>webpack-dev-server</code>，在浏览器中查看<code>localhost:8080</code>，发现输出<code>Hello world!</code>，这时候不要关闭服务器，直接修改<code>main.js</code>的代码，保存后查看浏览器效果，发现虽然没有手动刷新页面，但是效果已经出来了。</p>
<h3 id="Commons-Chunk-Plugin"><a href="#Commons-Chunk-Plugin" class="headerlink" title="Commons Chunk Plugin"></a>Commons Chunk Plugin</h3><p>当几个不同的脚本有公共的部分时，我们可以把公共部分抽出来放到一个单独的文件中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">// webpack.config.js</div><div class="line"></div><div class="line">var webpack = require(&apos;webpack&apos;);</div><div class="line"></div><div class="line">module.exports = &#123;</div><div class="line">    entry: &#123;</div><div class="line">        index: &apos;./index.js&apos;,</div><div class="line">        main: &apos;./main.js&apos;</div><div class="line">    &#125;,</div><div class="line">    output: &#123;</div><div class="line">        filename: &apos;[name].bundle.js&apos;</div><div class="line">    &#125;,</div><div class="line">    plugins: [</div><div class="line">        new webpack.optimize.CommonsChunkPlugin(&apos;common.js&apos;)</div><div class="line">    ]</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// index.html</div><div class="line"></div><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html lang=&quot;en&quot;&gt;</div><div class="line">&lt;head&gt;</div><div class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</div><div class="line">    &lt;title&gt;Demo11&lt;/title&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">    &lt;script src=&quot;common.js&quot;&gt;&lt;/script&gt;</div><div class="line">    &lt;script src=&quot;index.bundle.js&quot;&gt;&lt;/script&gt;</div><div class="line">    &lt;script src=&quot;main.bundle.js&quot;&gt;&lt;/script&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div><div class="line"></div><div class="line">// index.js</div><div class="line"></div><div class="line">var data = require(&apos;./data&apos;);</div><div class="line">document.write(&apos;&lt;p&gt;foo is &apos; + data.foo + &apos;&lt;/p&gt;&apos;);</div><div class="line"></div><div class="line">// main.js</div><div class="line"></div><div class="line">var data = require(&apos;./data&apos;);</div><div class="line">document.write(&apos;&lt;p&gt;bar is &apos; + data.bar + &apos;&lt;/p&gt;&apos;);</div><div class="line"></div><div class="line">// data.js</div><div class="line"></div><div class="line">var data = &#123;</div><div class="line">    foo: 123,</div><div class="line">    bar: 456</div><div class="line">&#125;;</div><div class="line"></div><div class="line">module.exports = data;</div></pre></td></tr></table></figure>
<p>具体示例见<a href="https://github.com/Joe3Ray/webpack-demo/tree/master/demo11" target="_blank" rel="external">demo11</a>。在demo11目录下执行<code>webpack-dev-server</code>，在浏览器中访问<code>localhost:8080</code>，打开开发者工具，发现<code>data.js</code>被抽出单独放到了<code>common.js</code>中。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文是我自己学习<code>webpack</code>的一个笔记，我把它记录下来，希望能给其他的<code>webpack</code>初学者提供一点帮助，谢谢观看，欢迎交流！</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文是一个简单的webpack入门教程，希望能够帮助webpack初学者快速上手。如有错误，敬请斧正。&lt;br&gt;本文所有的demo都可以在&lt;a href=&quot;https://github.com/Joe3Ray/webpack-demo/tree/ma
    
    </summary>
    
      <category term="技术" scheme="http://joeray61.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="webpack" scheme="http://joeray61.com/tags/webpack/"/>
    
      <category term="构建" scheme="http://joeray61.com/tags/%E6%9E%84%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>ES6学习笔记之模块</title>
    <link href="http://joeray61.com/2016/06/29/ES6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E6%A8%A1%E5%9D%97/"/>
    <id>http://joeray61.com/2016/06/29/ES6学习笔记之模块/</id>
    <published>2016-06-29T10:11:48.000Z</published>
    <updated>2017-04-04T10:12:51.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在当今的<code>Javascript</code>程序中，模块的作用不言而喻，目前广泛应用的主要有<code>AMD</code>（浏览器端）和<code>CommonJS</code>（服务器端）。但是<code>Javascript</code>一直没有在语言层面支持模块，直到<code>ES6</code>的出现。相信在不久的将来，<code>ES6</code>的模块一定会全面取代<code>AMD</code>和<code>CommonJS</code>。</p>
<h2 id="export"><a href="#export" class="headerlink" title="export"></a>export</h2><p><code>ES6</code>的模块提供了2个新的语法，分别是<code>export</code>和<code>import</code>。<code>export</code>就是模块用来对外暴露数据的接口，具体用法如下。</p>
<pre><code>export let a = 1;
export class A {};
export let b = () =&gt; {};
</code></pre><p>输出多个数据时不必分别<code>export</code>，可以用一个<code>export</code>统一输出</p>
<pre><code>let a = 1;
class A {};
let b = () =&gt; {};
export {a, A, b};
</code></pre><h2 id="import"><a href="#import" class="headerlink" title="import"></a>import</h2><p>与<code>export</code>对应，<code>import</code>就是<code>ES6</code>的模块用来引入数据的命令。</p>
<p>我们先来建立一个数据数据的文件<code>a.js</code>:</p>
<pre><code>// a.js
let a = 1;
export {a};
</code></pre><p>然后再创建一个<code>b.js</code>用来导入<code>a.js</code>暴露的数据</p>
<pre><code>// b.js
import {a} from &apos;./a&apos;;
console.log(a);    // 1
</code></pre><p>如果要导入的模块暴露了很多变量，而你又不想一个一个地去写要<code>import</code>的数据时，可以使用<code>*</code></p>
<pre><code>// b.js
import * as obj from &apos;./a&apos;;
console.log(obj.a);    // 1
</code></pre><p>需要注意的是，<code>import</code>使用的变量名必须跟<code>export</code>使用的变量名一致</p>
<h2 id="rename"><a href="#rename" class="headerlink" title="rename"></a>rename</h2><p><code>import</code>和<code>export</code>的时候都是可以对变量进行重命名的</p>
<pre><code>// a.js，用于export变量a，但是导出时将a改名为aa
let a = 1;
export {a as aa};


// b.js用于import从a.js导出的数据aa，但是在导入时将aa改名为b
import {aa as b} from &apos;./a&apos;;
console.log(a);   // undefined
console.log(aa);  // undefined
console.log(b);   // 1
</code></pre><h2 id="default"><a href="#default" class="headerlink" title="default"></a>default</h2><p><code>export</code>时可以指定要默认导出的数据</p>
<pre><code>// a.js
let a = 1;
let aa = 2;
export default a;
export {aa};
// 也可以写成
export {a as default, aa};
</code></pre><p>导入默认数据时需要这样写：</p>
<pre><code>// b.js
import x from &apos;./a&apos;;
console.log(x);  // 1
</code></pre><p>细心的同学可能发现了，这里<code>import</code>的时候使用的变量名是<code>x</code>，这就是<code>default</code>的特权了，导入时使用的变量名可以随便取，不需要跟导出时的变量名一致。</p>
<p>另外，如果同时要导入<code>default</code>和其他数据时该怎么写呢？</p>
<pre><code>// b.js
import x, {aa} from &apos;./a&apos;;
console.log(x);    // 1
console.log(aa);   // 2
</code></pre><h2 id="ES6模块加载实质"><a href="#ES6模块加载实质" class="headerlink" title="ES6模块加载实质"></a>ES6模块加载实质</h2><p><code>CommonJS</code>加载模块时，加载的是值的副本，而<code>ES6</code>的模块加载，加载的是值的引用。还是直接上代码吧</p>
<pre><code>// lib.js
export let x = 1;
export let changeX = () =&gt; {
    x++;
};


// a.js
import {x, changeX} from &apos;./lib&apos;;
changeX();
console.log(x);


// b.js
import {x, changeX} from &apos;./lib&apos;;
changeX();
console.log(x);


// index.js
import &apos;./a&apos;;
import &apos;./b&apos;;
</code></pre><p>执行<code>index.js</code>输出的值是<code>2</code>和<code>3</code>，这就说明<code>a.js</code>和<code>b.js</code>执行的时候改变的都是<code>lib.js</code>里的<code>x</code>，而不是各自操作了一份副本</p>
<h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><ol>
<li><code>ES6</code>的模块采用严格模式，无论你是否申明<code>use strict;</code></li>
<li><code>import</code>具有提升效果，即使写在文件的后面，也会被提到头部首先执行</li>
</ol>
<p>本文为学习过程中整理，如有问题欢迎交流~</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;在当今的&lt;code&gt;Javascript&lt;/code&gt;程序中，模块的作用不言而喻，目前广泛应用的主要有&lt;code&gt;AMD&lt;/code&gt;（浏览
    
    </summary>
    
      <category term="技术" scheme="http://joeray61.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="es6" scheme="http://joeray61.com/tags/es6/"/>
    
      <category term="javascript" scheme="http://joeray61.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>ES6学习笔记之Classes</title>
    <link href="http://joeray61.com/2016/06/16/ES6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8BClasses/"/>
    <id>http://joeray61.com/2016/06/16/ES6学习笔记之Classes/</id>
    <published>2016-06-16T10:13:24.000Z</published>
    <updated>2017-04-04T10:13:58.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><code>ES6</code>的<code>Classes</code>是在原型链继承的基础上，由语言本身提供的语法糖，并非是一种全新的继承模式。这使得Javascript有一种更加简洁清晰的方式来实现类的创建和继承。</p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>话不多说，直接上代码。</p>
<h3 id="定义Class"><a href="#定义Class" class="headerlink" title="定义Class"></a>定义Class</h3><pre><code>class Person {
    constructor(name, age) {
        this.name = name;
        this.age = age;
    }
}
</code></pre><h3 id="继承Class"><a href="#继承Class" class="headerlink" title="继承Class"></a>继承Class</h3><pre><code>class Student extends Person {
    constructor(name, age, grade) {
        super(name, age);
        this.grade = grade;
    }
}
</code></pre><h3 id="原型链方法"><a href="#原型链方法" class="headerlink" title="原型链方法"></a>原型链方法</h3><pre><code>class Person {
    constructor(name, age) {
        this.name = name;
        this.age = age;
    }

    speak() {
        console.log(&apos;something...&apos;);
    }
}
</code></pre><p><code>speak</code>就是原型链方法，不需要再繁琐地使用<code>prototype</code>来定义，直接定义在<code>class</code>内部即可。</p>
<h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><pre><code>class Person {
    constructor(name, age) {
        this.name = name;
        this.age = age;
    }

    static getClassName() {
        return &apos;Person&apos;;
    }
}
console.log(Person.getClassName());    // Person
</code></pre><p>静态方法直接用类名来调用就可以了，熟悉面向对象编程的同学应该都不陌生。</p>
<h3 id="Species"><a href="#Species" class="headerlink" title="Species"></a>Species</h3><p>某些情况下，类里面有一个方法返回的是类的实例，但是你可能希望返回父类的示例，这时候可以使用<code>species pattern</code>来达到目的。</p>
<p>举个栗子，你实现了一个类叫做<code>MyArray</code>，继承自<code>Array</code>，如果你不使用<code>species pattern</code>，那么调用<code>map</code>方法将会返回<code>MyArray</code>的实例，如果使用了<code>species pattern</code>则能够返回<code>Array</code>的实例。</p>
<pre><code>class MyArray extends Array {
    static get [Symbol.species]() {
        return Array;
    }
}

var a = new MyArray(1,2,3);
var mapped = a.map(x =&gt; x * x);

console.log(mapped instanceof MyArray); // false
console.log(mapped instanceof Array);   // true
</code></pre><h3 id="Mixin"><a href="#Mixin" class="headerlink" title="Mixin"></a>Mixin</h3><p>mixin是类的模板。在EcmaScript中，一个类不能继承多个类。这样有些需求就不是很方便。为了解决这个问题，可以使用mixin。</p>
<pre><code>var Bar = Sub =&gt; class extends Sub {
    bar() {}
};

var Baz = Sub =&gt; class extends Sub {
    baz() {}
};

class Person {
    speak() {}
}

class Student extends Bar(Baz(Person)) {}
</code></pre><p>这样，<code>Student</code>就可以继承<code>Bar</code>、<code>Baz</code>和<code>Person</code>3个基类了。</p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><h3 id="提升"><a href="#提升" class="headerlink" title="提升"></a>提升</h3><p>以前使用<code>function</code>来定义类的时候，我们可以在定以前先使用<code>new</code>，由于JS语言的变量提升特性，这样写不会有任何问题，示例如下：</p>
<pre><code>var joe = new Person(&apos;joe&apos;, 23);
function Person(name, age) {
    this.name = name;
    this.age = age;
}
</code></pre><p>如果使用<code>class</code>来定义类，则必须在定义后才能使用<code>new</code>来进行对象的实例化，如果先<code>new</code>则会报错</p>
<pre><code>var joe = new Person(&apos;joe&apos;, 23);    // ReferenceError
class Person {
    constructor(name, age) {
        this.name = name;
        this.age = age;
    }
}
</code></pre><h3 id="严格模式（strict-mode）"><a href="#严格模式（strict-mode）" class="headerlink" title="严格模式（strict mode）"></a>严格模式（strict mode）</h3><p>类声明和类表达式都是在严格模式下执行的。</p>
<h3 id="类表达式"><a href="#类表达式" class="headerlink" title="类表达式"></a>类表达式</h3><p>跟<code>function</code>一样，<code>class</code>也可以使用表达式来定义。类表达式可以命名也可以匿名。当类表达式有命名时，该命名仅作为类内部使用。</p>
<pre><code>var Person = class Man {
    getName() {
        return Man.name;
    }
};
var p = new Person();
console.log(p.getName());    // Man
console.log(Man);    // ReferenceError: Man is not defined
</code></pre><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes" target="_blank" rel="external">Classes</a></li>
<li><a href="http://exploringjs.com/es6/ch_classes.html" target="_blank" rel="external">http://exploringjs.com/es6/ch_classes.html</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;&lt;code&gt;ES6&lt;/code&gt;的&lt;code&gt;Classes&lt;/code&gt;是在原型链继承的基础上，由语言本身提供的语法糖，并非是一种全新的继
    
    </summary>
    
      <category term="技术" scheme="http://joeray61.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="es6" scheme="http://joeray61.com/tags/es6/"/>
    
      <category term="javascript" scheme="http://joeray61.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>ES6学习笔记之箭头函数</title>
    <link href="http://joeray61.com/2016/04/26/ES6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/"/>
    <id>http://joeray61.com/2016/04/26/ES6学习笔记之箭头函数/</id>
    <published>2016-04-26T10:14:24.000Z</published>
    <updated>2017-04-04T10:15:08.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JS中的箭头"><a href="#JS中的箭头" class="headerlink" title="JS中的箭头"></a>JS中的箭头</h2><p>箭头在JS里并不算是个新鲜的玩意儿，一直以来，JS都支持<code>--&gt;</code>这样的箭头。</p>
<p>很早的时候有些浏览器还不支持JS，当时的人们为了兼容这些浏览器，需要这样写JS:</p>
<pre><code>&lt;script language=&quot;javascript&quot;&gt;
&lt;!--
    alert(&apos;Joe&apos;);
// --&gt;
&lt;/script&gt;
</code></pre><p>这段代码在不支持JS的浏览器里会被解读成2个未知标签和一段html注释。在支持JS的浏览器里，JS引擎会把<code>&lt;!--</code>和<code>--&gt;</code>看成是单行注释的开始。需要说明的是，<code>--&gt;</code>仅仅是在一行的开头才能表示这一行是注释，其余情况<code>--&gt;</code>是一个操作符，表示goes to的含义。</p>
<pre><code>function countdown(n) {
    while (n --&gt; 0) {
        alert(n);
    }
}
</code></pre><p>这段代码确实能够正常运行哦。当你给<code>countdown</code>函数传入一个大于0的参数时，这个循环能够一直运行，直到n变为0为止。</p>
<p>此箭头非彼箭头，以上讲述的<code>--&gt;</code>并不是我们今天要讲的主角，大家权当拓展下JS知识，下面让我们进入正题。</p>
<h2 id="特性介绍"><a href="#特性介绍" class="headerlink" title="特性介绍"></a>特性介绍</h2><p>箭头函数是ES6新增的特性之一，它为JS这门语言提供了一种全新的书写函数的语法。</p>
<pre><code>// ES5
var double = nums.map(function (v) {
    return 2 * n;
});

// ES6
var double = nums.map(v =&gt; 2 * n);
</code></pre><p>箭头函数简化了原先的函数语法，不需要再写<code>function</code>，如果函数体只有一行代码的话连<code>return</code>都不用写，这个特性对于热衷于简化流程和工作的程序员来说相当对胃口。</p>
<p>使用箭头函数有几个注意点：</p>
<h3 id="函数体"><a href="#函数体" class="headerlink" title="函数体"></a>函数体</h3><p>箭头函数支持两种模式的函数体写法，我们姑且叫他简洁函数体和块级函数体。</p>
<pre><code>// 简洁函数体
var fn = x =&gt; x * x;

// 块级函数体
var fn = (x, y) =&gt; {return x + y;};
</code></pre><p>简介函数体默认会把表达式的结果返回，块级函数体需要手动<code>return</code>。如果想要返回一个对象又想使用简洁函数体的话，需要这么写：</p>
<pre><code>var fn = () =&gt; ({});
fn();   // {}
</code></pre><p>如果写成<code>var fn = () =&gt; {};</code>，那么执行<code>fn()</code>只能返回<code>undefined</code>。</p>
<h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><p>用function生成的函数会定义一个自己的<code>this</code>，而箭头函数没有自己的<code>this</code>，而是会和上一层的作用域共享<code>this</code>。</p>
<pre><code>function Person() {
    this.age = 0;
    var self = this;
    setTimeout(function () {
        self.age++;
        console.log(self.age);
    }, 1000);
}
var p = new Person();
</code></pre><p>这段代码里，<code>setTimeout</code>的参数<code>function</code>中需要操作外层的<code>age</code>属性，必须要把<code>this</code>赋值给<code>self</code>，然后通过<code>self</code>来获取到<code>age</code></p>
<p>如果使用箭头函数则省事很多，代码如下：</p>
<pre><code>function Person() {
    this.age = 0;
    setTimeout(() =&gt; {
        this.age++;
        console.log(this.age);
    }, 1000);
}
var p = new Person();
</code></pre><h3 id="apply-amp-call"><a href="#apply-amp-call" class="headerlink" title="apply &amp; call"></a>apply &amp; call</h3><p>由于箭头函数已经绑定了<code>this</code>的值，即使使用<code>apply</code>或者<code>call</code>也不能只能起到传参数的作用，并不能强行改变箭头函数里的<code>this</code>。</p>
<pre><code>var adder = {
    x: 1,
    add1: function (y) {
        var fn = v =&gt; v + this.x;
        return fn(y);
    },
    add2: function (y) {
        var fn = v =&gt; v + this.x;
        var whatever = {
            x: 2
        };
        return fn.call(whatever, y);
    }
};

adder.add1(1);    // 2
adder.add2(1);    // 仍然是2
</code></pre><h3 id="arguments"><a href="#arguments" class="headerlink" title="arguments"></a>arguments</h3><p>普通函数里<code>arguments</code>代表了调用时传入的参数，但是箭头函数不然，在箭头函数中无法使用<code>arguments</code></p>
<p>当然，<code>ES6</code>中也有办法可以让箭头函数像普通函数一样使用类似于<code>arguments</code>这样的类数组对象</p>
<pre><code>var fn = (...rest) =&gt; rest[0];
fn(2);    // 2
</code></pre><p><code>...rest</code>也是<code>ES6</code>的一个新特性，之后会介绍。</p>
<h3 id="不能被new"><a href="#不能被new" class="headerlink" title="不能被new"></a>不能被new</h3><p>箭头函数不能与<code>new</code>关键字一起使用，会报错</p>
<pre><code>var Fn = () =&gt; {
    this.a = 1;
};
var f = new Fn();    // Error
</code></pre><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>在我看来，箭头函数几乎可以完全取代<code>function</code>，除非是函数需要进行递归或者需要可变的<code>this</code>对象，其他场景我认为都可以使用箭头函数。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://hacks.mozilla.org/2015/06/es6-in-depth-arrow-functions/" target="_blank" rel="external">ES6 In Depth: Arrow functions</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions" target="_blank" rel="external">Arrow functions</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;JS中的箭头&quot;&gt;&lt;a href=&quot;#JS中的箭头&quot; class=&quot;headerlink&quot; title=&quot;JS中的箭头&quot;&gt;&lt;/a&gt;JS中的箭头&lt;/h2&gt;&lt;p&gt;箭头在JS里并不算是个新鲜的玩意儿，一直以来，JS都支持&lt;code&gt;--&amp;gt;&lt;/code&gt;这样的箭头。&lt;
    
    </summary>
    
      <category term="技术" scheme="http://joeray61.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="es6" scheme="http://joeray61.com/tags/es6/"/>
    
      <category term="javascript" scheme="http://joeray61.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>初探WebRTC</title>
    <link href="http://joeray61.com/2015/04/08/%E5%88%9D%E6%8E%A2WebRTC/"/>
    <id>http://joeray61.com/2015/04/08/初探WebRTC/</id>
    <published>2015-04-08T10:16:10.000Z</published>
    <updated>2017-04-04T10:22:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>##简介</p>
<blockquote>
<p>WebRTC is a new front in the long war for an open and unencumbered web.    </p>
</blockquote>
<p>这句话是JavaScript之父<em>Brendan Eich</em>对于WebRTC的评价，大致意思是『WebRTC是争取开放和无阻碍Web的漫长战争中一条新战线』。</p>
<p>那么WebRTC到底是一种什么样的技术呢？WebRTC是一个免费的开放项目，提供了几个简单的API让浏览器、手机平台还有其他设备通过一个通用的协议进行实时通信，帮助开发者开发出丰富而且高质量的跨平台实时通信应用。</p>
<p>本文的目的就是通过简洁的介绍和引导让开发者了解WebRTC的工作流程并能够快速上手开发WebRTC应用。</p>
<p>##API</p>
<ul>
<li><p><strong>MediaStream(getUserMedia)</strong>    </p>
<p>  MediaStream表示一段多媒体流，获取多媒体流的一个简单方式就是通过        <strong>getUserMedia</strong>函数，该函数可以调用设备的摄像头和麦克风，并拿到这些硬件生成的多媒体流。这些多媒体流可以输出到<code>video</code>标签或者一个<strong>RTCPeerConnection</strong>。</p>
<p>  <strong>getUserMedia</strong>接受3个参数：</p>
<ol>
<li>一个限制对象，用于指定接受的流</li>
<li>获取stream成功后的回调函数，被调用时能获取到对应的流</li>
<li><p>获取stream失败后的回调函数，被调用时能获取到一个错误对象</p>
<p>具体用法如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">var getUserMedia = navigator.getUserMedia || </div><div class="line">                      navigator.webkitGetUserMedia ||</div><div class="line">                      navigator.mozGetUserMedia;</div><div class="line">   var constraints = &#123;video: true&#125;;</div><div class="line">   getUserMedia(constraints, function (stream) &#123;</div><div class="line">       var video = document.querySelector(&quot;video&quot;);</div><div class="line">       //URL.createObjectURL方法把stream转换成blob，作为video的src属性进行播放</div><div class="line">       video.src = window.URL.createObjectURL(stream);</div><div class="line">       video.play();</div><div class="line">   &#125;, function (error) &#123;</div><div class="line">       console.log(error);</div><div class="line">   &#125;);</div></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
<ul>
<li><strong>RTCPeerConnection</strong></li>
</ul>
<p>RTCPeerConnection帮我们做了很多事情，我们只需要把RTCPeerConnection理解成一种p2p传输音视频数据的通道，但是我们仍然还需要服务器来为我们传递消息，因为在建立p2p之前需要先互相交换session、网络配置、媒体适配等信息。另外，WebRTC还需要服务器帮助完成NAT穿越，以及在p2p建立失败的时候作为中转服务器。具体用法将在流程讲解中说明。</p>
<ul>
<li><p><strong>RTCDataChannel</strong></p>
<p>  WebRTC除了支持视频和音频流之外，还支持其他类型的数据。RTCDataChannel用于点到点的任意数据交换，具有低延迟和高吞吐量的特点。RTCDataChannel必须建立在RTCPeerConnnection之上，没办法单独工作。</p>
<p>  这个API潜在的应用场景很多，例如：</p>
<ul>
<li>游戏</li>
<li>远程桌面应用</li>
<li>实时文字聊天</li>
<li><p>文件传输</p>
<p>创建一个RTCDataChannel的方式如下：    </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">   var RTCPeerConnection = webkitRTCPeerConnection || mozRTCPeerConnection;</div><div class="line">var peerConn = new RTCPeerConnection();</div><div class="line">   var dc = peerConn.createDataChannel(&quot;label&quot;);</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<p>##流程讲解</p>
<p>看完上面的内容，大家应该还是处于云里雾里的状态，不知道WebRTC应用要如何开发，3个API如何配合使用。没关系，这里才是重点，看完这一段，相信你的所有疑惑就都解开了。</p>
<p>要用WebRTC建立一个p2p通道需要经历2个步骤：</p>
<ol>
<li><p>获得本机SDP描述符并交换</p>
<ul>
<li>A、B均实例化一个RTCPeerConnection(以下简称rpcA和rpcB),调用rpcA的<code>createOffer()</code>方法建立一个offer信令，并且拿到A的SDP</li>
<li>通过rpcA的<code>setLocalDescription()</code>方法设置A机器的本地描述</li>
<li>A通过服务器将offer信令发给B</li>
<li>B接收到A的offer信令，通过rpcB的<code>setRemoteDescription()</code>方法设置远程机器（即A）的描述</li>
<li>B调用rpcB的<code>createAnswer()</code>方法建立一个answer信令，并且拿到B的SDP</li>
<li>通过rpcB的<code>setLocalDescription()</code>方法设置B机器的本地描述</li>
<li>B通过服务器将answer信令发送给A</li>
<li><p>A接收到B的answer信令，通过rpcA的<code>setRemoteDescription()</code>方法设置远程机器B的描述</p>
<p>这个过程完成后，A和B就都拿到各自的SDP描述符了</p>
</li>
</ul>
</li>
<li><p>通过ICE框架连接两段主机的网络地址</p>
<p> ICE框架具体内容我不清楚，咱们姑且先了解在WebRTC中如何使用，对ICE感兴趣的同学可以自行谷歌。</p>
<p> 在实例化RTCPeerConnection对象的时候可以传入ICE服务器的地址，我们可以使用谷歌提供的『stun:stun.l.google.com:19302』或者Mozilla提供的『stun:stun.services.mozilla.com』，代码如下：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var configuration = &#123;iceServers: [&#123;url: &quot;stun:stun.l.google.com:19302&quot;&#125;]&#125;;</div><div class="line">var rpc = new RTCPeerConnection(configuration);</div></pre></td></tr></table></figure>
<p> 在rpc上绑定onicecandidate事件的回调函数，当网络候选可用时这个函数会被调用，在这个回调函数中，本机可以拿到ice candidate信令，然后通过服务器发给远程机器，远程机器通过自己的rpc实例的<code>addIceCandidate()</code>方法添加，同样地，远程机器也应该将自己的ice candidate信令通过服务器发送给本机。</p>
<p> 当双方的ice candidate交换完成时，连接就建立成功了，可以在rpc示例上调用<code>addStream()</code>来添加流，另一边通过绑定onaddstream事件就可以获取到传过去的流。</p>
<p> 服务器通信部分，没有规定必须要用某种协议，所以只要能在两边传输消息的技术可以使用，例如<em>WebSocket</em>、<em>XHR</em>等，大家自行选择即可。<br>##示例</p>
</li>
</ol>
<p>本来想自己写个例子给大家参考的，后来发现网上有个非常棒的实例教程，我就直接上地址了<a href="https://bitbucket.org/webrtc/codelab" target="_blank" rel="external">https://bitbucket.org/webrtc/codelab</a></p>
<p>##小结</p>
<p>写这篇文章的目的是为了让学习WebRTC的同学能够快速上手，对WebRTC技术有个整体的概念，所以文章写的比较简短，专注于讲解WebRTC的运作流程，对一些相关技术，比如ICE、SDP等没有深入探讨（当然我也不太懂）。如果你想快速上手制作WebRTC应用，看完这篇文章再对着<a href="https://bitbucket.org/webrtc/codelab" target="_blank" rel="external">codelab</a>提供的例子一步一步跟着做应该就没问题了。Good luck!</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://www.html5rocks.com/en/tutorials/webrtc/basics/" target="_blank" rel="external">http://www.html5rocks.com/en/tutorials/webrtc/basics/</a></li>
<li><a href="http://www.webrtc.org/" target="_blank" rel="external">http://www.webrtc.org/</a></li>
<li><a href="http://www.w3.org/TR/webrtc/" target="_blank" rel="external">http://www.w3.org/TR/webrtc/</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Glossary/WebRTC" target="_blank" rel="external">https://developer.mozilla.org/en-US/docs/Glossary/WebRTC</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;##简介&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;WebRTC is a new front in the long war for an open and unencumbered web.    &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这句话是JavaScript之
    
    </summary>
    
      <category term="技术" scheme="http://joeray61.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="webrtc" scheme="http://joeray61.com/tags/webrtc/"/>
    
  </entry>
  
  <entry>
    <title>Javascript实现图片的预加载功能</title>
    <link href="http://joeray61.com/2014/09/21/Javascript%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E7%9A%84%E9%A2%84%E5%8A%A0%E8%BD%BD%E5%8A%9F%E8%83%BD/"/>
    <id>http://joeray61.com/2014/09/21/Javascript实现图片的预加载功能/</id>
    <published>2014-09-21T10:18:24.000Z</published>
    <updated>2017-04-04T10:20:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近要用<code>javascript</code>做一个动画功能，为了确保动画在播放的时候能够顺利和平滑，我需要对所用到的图片素材进行<strong><em>预加载</em></strong>，下面跟大家分享一下我实现这个功能的过程</p>
<p>##单图片预加载##<br>目前最常见的一种实现方式如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">function preloadImg(url) &#123;</div><div class="line">	var img = new Image();</div><div class="line">    img.src = url;</div><div class="line">    if(img.complete) &#123;</div><div class="line">    	//接下来可以使用图片了</div><div class="line">        //do something here</div><div class="line">    &#125;</div><div class="line">    else &#123;</div><div class="line">    	img.onload = function() &#123;</div><div class="line">        	//接下来可以使用图片了</div><div class="line">        	//do something here</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>首先实例化一个<code>Image</code>对象赋值给<code>img</code>，然后设置<code>img.src</code>为参数<code>url</code>指定的图片地址,接着判断<code>img</code>的<code>complete</code>属性，如果本地有这张图片的缓存，则该值为<code>true</code>，此时我们可以直接操作这张图片，如果本地没有缓存，则该值为<code>false</code>，此时我们需要监听<code>img</code>的<code>onload</code>事件，把对<code>img</code>的操作放在<code>onload</code>的回调函数里面，经过测试，这种方案基本能够兼容目前所有浏览器</p>
<p>##多图片预加载##<br>很多场景下，单图片预加载并不能满足我们的需求，因为像动画这种功能通常都会有很多的图片素材，接下来我们就在原来单图片预加载的基础上来改进我们的函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">function preloadImg(list) &#123;</div><div class="line">	var imgs = arguments[1] || [],	//用于存储预加载好的图片资源</div><div class="line">    	fn = arguments.cal	lee;</div><div class="line">    if(list.length == 0) &#123;</div><div class="line">    	return imgs;</div><div class="line">    &#125;</div><div class="line">	var img = new Image();</div><div class="line">    img.src = list[0];</div><div class="line">    if(img.complete) &#123;</div><div class="line">    	imgs.push(img);</div><div class="line">        list.shift();</div><div class="line">        fn(list, imgs);</div><div class="line">    &#125;</div><div class="line">    else &#123;</div><div class="line">    	img.onload = function() &#123;</div><div class="line">        	imgs.push(img);</div><div class="line">            list.shift();</div><div class="line">            fn(list, imgs);</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">var list = [......],	//此处省略一万个字符</div><div class="line">	imgs = preloadImg();</div></pre></td></tr></table></figure></p>
<p>因为帧动画可能需要保证每一帧动画所用的图片的顺序，所以我在这段代码中使用递归的方式，在上一张加载完成之后再去加载下一张图片，每加载一张图片，就把这张图片资源存储到<code>imgs</code>数组中，并且把这张图片的地址从地址数组<code>list</code>中去掉，当<code>list</code>中已经没有地址的时候跳出递归，并返回<code>imgs</code>数组<br>设想很美好，现实很残酷，这段代码有2个不能忍受的问题</p>
<ol>
<li>首先，我很有可能拿不到最后返回的<code>imgs</code>数组，因为只要有图片在本地没有缓存，<code>imgs</code>的存储操作都会放到<code>onload</code>的回调事件中，而<strong>事件监听</strong>也属于<code>javascript</code>中异步操作的一种，在绑定完<code>onload</code>事件的回调函数后，<code>preloadImg</code>函数就执行结束了，没有任何返回值，外部<code>imgs</code>变量接收到的值为<code>undefined</code>，只有在所有图片都有本地缓存的情况下，外部<code>imgs</code>变量才能顺利拿到存储了全部预加载图片资源的数组</li>
<li>在加载完一张图片之后才去加载下一张，整个预加载图片的过程所需要的时间相对会比较长，用户体验会降低，而且本来异步操作具体速度快的特性，这样的实现方式等于完全弃置了<code>onload</code>异步的这个特性<br>##多图片预加载（改进版）##<br>这次我们直接把一个空数组作为参数传进函数，图片全部存储到这个数组里面，下面是改进后的函数代码（假设我们可以使用<code>jQuery</code>）<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">function preloadImg(list,imgs) &#123;</div><div class="line">	var def = $.Deferred(),</div><div class="line">        len = list.length;</div><div class="line">    $(list).each(function(i,e) &#123;</div><div class="line">        var img = new Image();</div><div class="line">        img.src = e;</div><div class="line">        if(img.complete) &#123;</div><div class="line">            imgs[i] = img;</div><div class="line">            len--;</div><div class="line">            if(len == 0) &#123;</div><div class="line">                def.resolve();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        else &#123;</div><div class="line">            img.onload = (function(j) &#123;</div><div class="line">                return function() &#123;</div><div class="line">                    imgs[j] = img</div><div class="line">                    len--;</div><div class="line">                    if(len == 0) &#123;</div><div class="line">                        def.resolve();</div><div class="line">                    &#125;</div><div class="line">                &#125;;</div><div class="line">            &#125;)(i);</div><div class="line">            img.onerror = function() &#123;</div><div class="line">                len--;</div><div class="line">                console.log(&apos;fail to load image&apos;);</div><div class="line">            &#125;;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">    return def.promise();</div><div class="line">&#125;</div><div class="line">var list = [......],	//此处省略一万个字符</div><div class="line">	imgs = [];</div><div class="line">$.when(preloadImg(list, imgs)).done(</div><div class="line">	function() &#123;</div><div class="line">    	//预加载结束</div><div class="line">        //do something here</div><div class="line">    &#125;</div><div class="line">);</div></pre></td></tr></table></figure>
</li>
</ol>
<p>在分别给每一个<code>img</code>绑定<code>onload</code>的回调函数时采用了闭包的方式，目的是为了保存住当前的递增变量<code>i</code>，要是不这么做，结果将会是<code>list</code>地址中没有本地缓存的图片都存储到<code>imgs</code>的最后一个元素上<br>这次每载入一张图片，我们并没有把这张图片的地址从<code>list</code>数组中去掉，这样后续需要使用<code>list</code>数组的数据时就能够顺利获取到</p>
<p>thx for reading, hope u enjoy</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近要用&lt;code&gt;javascript&lt;/code&gt;做一个动画功能，为了确保动画在播放的时候能够顺利和平滑，我需要对所用到的图片素材进行&lt;strong&gt;&lt;em&gt;预加载&lt;/em&gt;&lt;/strong&gt;，下面跟大家分享一下我实现这个功能的过程&lt;/p&gt;
&lt;p&gt;##单图片预加载##&lt;
    
    </summary>
    
      <category term="技术" scheme="http://joeray61.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="javascript" scheme="http://joeray61.com/tags/javascript/"/>
    
      <category term="性能" scheme="http://joeray61.com/tags/%E6%80%A7%E8%83%BD/"/>
    
      <category term="预加载" scheme="http://joeray61.com/tags/%E9%A2%84%E5%8A%A0%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>浅谈Javascript中Promise对象的实现</title>
    <link href="http://joeray61.com/2014/09/20/%E6%B5%85%E8%B0%88Javascript%E4%B8%ADPromise%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>http://joeray61.com/2014/09/20/浅谈Javascript中Promise对象的实现/</id>
    <published>2014-09-20T10:23:01.000Z</published>
    <updated>2017-04-04T10:23:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>很多做前端的朋友应该都听说过<code>Promise</code>（或者<code>Deferred</code>）对象，今天我就讲一下我对<code>Promise</code>的认识</p>
<p>##What？##<br><code>Promise</code>是<code>CommonJS</code>的规范之一，拥有<code>resolve</code>、<code>reject</code>、<code>done</code>、<code>fail</code>、<code>then</code>等方法，能够帮助我们控制代码的流程，避免函数的多层嵌套。如今异步在web开发中越来越重要，对于开发人员来说，这种非线性执行的编程会让开发者觉得难以掌控，而<code>Promise</code>可以让我们更好地掌控代码的执行流程,<code>jQuery</code>等流行的js库都已经实现了这个对象，年底即将发布的<code>ES6</code>也将原生实现<code>Promise</code></p>
<p>##Why##<br>想象这样一个场景，两个异步请求，第二个需要用到第一个请求成功的数据，那么我们代码可以这样写<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">ajax(&#123;</div><div class="line">   	url: url1,</div><div class="line">       success: function(data) &#123;</div><div class="line">       	ajax(&#123;</div><div class="line">           	url: url2,</div><div class="line">               data: data,</div><div class="line">               success: function() &#123;</div><div class="line">               &#125;</div><div class="line">           &#125;);</div><div class="line">       &#125;</div><div class="line">   &#125;);</div></pre></td></tr></table></figure></p>
<p>如果继续下去在回调函数中进行下一步操作，嵌套的层数会越来越多。我们可以进行适当的改进，把回调函数写到外面<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">function A() &#123;</div><div class="line">   	ajax(&#123;</div><div class="line">       	url: url1,</div><div class="line">           success: function(data) &#123;</div><div class="line">           	B(data);</div><div class="line">           &#125;</div><div class="line">       &#125;);</div><div class="line">   &#125;</div><div class="line">   function B(data) &#123;</div><div class="line">   	ajax(&#123;</div><div class="line">       	url: url2,</div><div class="line">           success: function(data) &#123;</div><div class="line">           	......</div><div class="line">           &#125;</div><div class="line">       &#125;);</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>即使是改写成这样，代码还是不够直观，但是如果有了Promise对象，代码就可以写得非常清晰，一目了然，请看</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">new Promise(A).done(B);</div></pre></td></tr></table></figure>
<p>这样函数B就不用写在A的回调中了</p>
<p>##How##<br>目前的<code>ES</code>标准中还未支持<code>Promise</code>对象，那么我们就自己动手，丰衣足食吧。思路大致是这样的，用2个数组(<code>doneList</code>和<code>failList</code>)分别存储成功时的回调函数队列和失败时的回调队列</p>
<ul>
<li><code>state</code>: 当前执行状态，有<code>pending</code>、<code>resolved</code>、<code>rejected</code>3种取值</li>
<li><code>done</code>: 向<code>doneList</code>中添加一个成功回调函数</li>
<li><code>fail</code>: 向<code>failList</code>中添加一个失败回调函数</li>
<li><code>then</code>: 分别向<code>doneList</code>和<code>failList</code>中添加回调函数</li>
<li><code>always</code>: 添加一个无论成功还是失败都会调用的回调函数</li>
<li><code>resolve</code>: 将状态更改为<code>resolved</code>,并触发绑定的所有成功的回调函数</li>
<li><code>reject</code>: 将状态更改为<code>rejected</code>,并触发绑定的所有失败的回调函数</li>
<li><code>when</code>: 参数是多个异步或者延迟函数，返回值是一个Promise兑现，当所有函数都执行成功的时候执行该对象的<code>resolve</code>方法，反之执行该对象的<code>reject</code>方法<br>下面是我的具体实现过程：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line">var Promise = function() &#123;</div><div class="line">    this.doneList = [];</div><div class="line">    this.failList = [];</div><div class="line">    this.state = &apos;pending&apos;;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">Promise.prototype = &#123;</div><div class="line">    constructor: &apos;Promise&apos;,</div><div class="line">    resolve: function() &#123;</div><div class="line">        this.state = &apos;resolved&apos;;</div><div class="line">        var list = this.doneList;</div><div class="line">        for(var i = 0, len = list.length; i &lt; len; i++) &#123;</div><div class="line">            list[0].call(this);</div><div class="line">            list.shift();</div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    reject: function() &#123;</div><div class="line">        this.state = &apos;rejected&apos;;</div><div class="line">        var list = this.failList;</div><div class="line">        for(var i = 0, len = list.length; i &lt; len; i++)&#123;</div><div class="line">            list[0].call(this);</div><div class="line">            list.shift();</div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    done: function(func) &#123;</div><div class="line">        if(typeof func === &apos;function&apos;) &#123;</div><div class="line">            this.doneList.push(func);</div><div class="line">        &#125;</div><div class="line">        return this;</div><div class="line">    &#125;,</div><div class="line">    fail: function(func) &#123;</div><div class="line">        if(typeof func === &apos;function&apos;) &#123;</div><div class="line">            this.failList.push(func);</div><div class="line">        &#125;</div><div class="line">        return this;</div><div class="line">    &#125;,</div><div class="line">    then: function(doneFn, failFn) &#123;</div><div class="line">        this.done(doneFn).fail(failFn);</div><div class="line">        return this;</div><div class="line">    &#125;,</div><div class="line">    always: function(fn) &#123;</div><div class="line">        this.done(fn).fail(fn);</div><div class="line">        return this;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">function when() &#123;</div><div class="line">    var p = new Promise();</div><div class="line">    var success = true;</div><div class="line">    var len = arguments.length;</div><div class="line">    for(var i = 0; i &lt; len; i++) &#123;</div><div class="line">        if(!(arguments[i] instanceof Promise)) &#123;</div><div class="line">            return false;</div><div class="line">        &#125;</div><div class="line">        else &#123;</div><div class="line">            arguments[i].always(function() &#123;</div><div class="line">                if(this.state != &apos;resolved&apos;)&#123;</div><div class="line">                    success = false;</div><div class="line">                &#125;</div><div class="line">                len--;</div><div class="line">                if(len == 0) &#123;</div><div class="line">                    success ? p.resolve() : p.reject();</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return p;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>##Improve##<br>目前只是实现了<code>Promise</code>的基础功能，但仍然还有无法处理的情况，例如要实现3个或3个以上的异步请求的串行，目前我的<code>Promise</code>没有办法支持<code>new Promise(A).then(B).then(C)</code>这样的形式，<code>jQuery</code>在1.7的版本中为<code>Deferred</code>(<code>Promise</code>)对象实现了<code>pipe</code>函数，可以通过这个函数实现上述功能，代码为<code>$.Deferred(A).pipe(B).then(C)</code>，我尝试去读了<code>jQuery</code>这部分的代码，但是没能读懂，希望有大神能够给一些实现思路</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;很多做前端的朋友应该都听说过&lt;code&gt;Promise&lt;/code&gt;（或者&lt;code&gt;Deferred&lt;/code&gt;）对象，今天我就讲一下我对&lt;code&gt;Promise&lt;/code&gt;的认识&lt;/p&gt;
&lt;p&gt;##What？##&lt;br&gt;&lt;code&gt;Promise&lt;/code&gt;是&lt;
    
    </summary>
    
      <category term="技术" scheme="http://joeray61.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="javascript" scheme="http://joeray61.com/tags/javascript/"/>
    
      <category term="promise" scheme="http://joeray61.com/tags/promise/"/>
    
      <category term="deferred" scheme="http://joeray61.com/tags/deferred/"/>
    
  </entry>
  
  <entry>
    <title>Underscore源码解析（四）</title>
    <link href="http://joeray61.com/2014/06/07/Underscore%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
    <id>http://joeray61.com/2014/06/07/Underscore源码解析（四）/</id>
    <published>2014-06-07T10:24:24.000Z</published>
    <updated>2017-04-04T10:43:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>我在这个系列的第一篇文章说过，我学underscore是为了在学backbone的时候少一些阻碍，从第一篇的写作时间到今天，大概也有个十几二十天，感觉拖得有点久，所以今天将会是underscore源码解析系列的最后一篇文章，我会在这篇文章中介绍underscore剩下的所有函数。<br>先附上前三篇文章的地址：<a href="/2014/05/21/Underscore源码解析（一）/">Underscore源码解析（一）</a>、<a href="/2014/06/03/Underscore源码解析（二）/">Underscore源码解析（二）</a>、<a href="/2014/06/06/Underscore源码解析（三）/">Underscore源码解析（三）</a></p>
<h2 id="zip"><a href="#zip" class="headerlink" title="_.zip"></a>_.zip</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">_.zip = function() &#123;</div><div class="line">    // 将参数转换为数组, 此时args是一个二维数组</div><div class="line">    var args = slice.call(arguments);</div><div class="line">    // 计算每一个数组的长度, 并返回其中最大长度值</div><div class="line">    var length = _.max(_.pluck(args, &apos;length&apos;));</div><div class="line">    // 依照最大长度值创建一个新的空数组, 该数组用于存储处理结果</div><div class="line">    var results = new Array(length);</div><div class="line">    // 循环最大长度, 在每次循环将调用pluck方法获取每个数组中相同位置的数据(依次从0到最后位置)</div><div class="line">    // 将获取到的数据存储在一个新的数组, 放入results并返回</div><div class="line">    for(var i = 0; i &lt; length; i++)</div><div class="line">    results[i] = _.pluck(args, &quot;&quot; + i);</div><div class="line">    // 返回的结果是一个二维数组</div><div class="line">    return results;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这个函数将每个数组的相同位置的数据作为一个新的二维数组返回, 返回的数组长度以传入参数中最大的数组长度为准, 其它数组的空白位置使用undefined填充。zip函数应该包含多个参数, 且每个参数应该均为数组。</p>
<h2 id="indexOf"><a href="#indexOf" class="headerlink" title="_.indexOf"></a>_.indexOf</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">_.indexOf = function(array, item, isSorted) &#123;</div><div class="line">    if(array == null)</div><div class="line">        return -1;</div><div class="line">    var i, l;</div><div class="line">    // 若数组已经经过排序，则调用sortedIndex方法，获取元素插入数组中所处位置的索引号</div><div class="line">    if(isSorted) &#123;</div><div class="line">        i = _.sortedIndex(array, item);</div><div class="line">        return array[i] === item ? i : -1;</div><div class="line">    &#125;</div><div class="line">    // 优先调用宿主环境提供的indexOf方法</div><div class="line">    if(nativeIndexOf &amp;&amp; array.indexOf === nativeIndexOf)</div><div class="line">        return array.indexOf(item);</div><div class="line">    // 循环并返回元素首次出现的位置</div><div class="line">    for( i = 0, l = array.length; i &lt; l; i++)</div><div class="line">    if( i in array &amp;&amp; array[i] === item)</div><div class="line">        return i;</div><div class="line">    // 没有找到元素, 返回-1</div><div class="line">    return -1;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这个函数的作用是搜索一个元素在数组中首次出现的位置, 如果元素不存在则返回 -1，搜索时使用 === 对元素进行匹配</p>
<h2 id="lastIndexOf"><a href="#lastIndexOf" class="headerlink" title="_.lastIndexOf"></a>_.lastIndexOf</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">_.lastIndexOf = function(array, item) &#123;</div><div class="line">    if(array == null)</div><div class="line">        return -1;</div><div class="line">    // 优先调用宿主环境提供的lastIndexOf方法</div><div class="line">    if(nativeLastIndexOf &amp;&amp; array.lastIndexOf === nativeLastIndexOf)</div><div class="line">        return array.lastIndexOf(item);</div><div class="line">    var i = array.length;</div><div class="line">    // 循环并返回元素最后出现的位置</div><div class="line">    while(i--)</div><div class="line">    if( i in array &amp;&amp; array[i] === item)</div><div class="line">        return i;</div><div class="line">    // 没有找到元素, 返回-1</div><div class="line">    return -1;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这个函数返回一个元素在数组中最后一次出现的位置, 如果元素不存在则返回 -1，搜索时使用 === 对元素进行匹配</p>
<h2 id="range"><a href="#range" class="headerlink" title="_.range"></a>_.range</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">_.range = function(start, stop, step) &#123;</div><div class="line">    // 参数控制</div><div class="line">    if(arguments.length &lt;= 1) &#123;</div><div class="line">        // 如果没有参数, 则start = 0, stop = 0, 在循环中不会生成任何数据, 将返回一个空数组</div><div class="line">        // 如果有1个参数, 则参数指定给stop, start = 0</div><div class="line">        stop = start || 0;</div><div class="line">        start = 0;</div><div class="line">    &#125;</div><div class="line">    // 生成整数的步长值, 默认为1</div><div class="line">    step = arguments[2] || 1;</div><div class="line"></div><div class="line">    // 根据区间和步长计算将生成的最大值</div><div class="line">    var len = Math.max(Math.ceil((stop - start) / step), 0);</div><div class="line">    var idx = 0;</div><div class="line">    var range = new Array(len);</div><div class="line"></div><div class="line">    // 生成整数列表, 并存储到range数组</div><div class="line">    while(idx &lt; len) &#123;</div><div class="line">        range[idx++] = start;</div><div class="line">        start += step;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 返回列表结果</div><div class="line">    return range;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这个函数根据区间和步长, 生成一系列整数, 并作为数组返回，start参数表示最小数，stop参数表示最大数，step参数表示步长</p>
<h2 id="bind"><a href="#bind" class="headerlink" title="_.bind"></a>_.bind</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">_.bind = function bind(func, context) &#123;</div><div class="line">    var bound, args;</div><div class="line">    // 优先调用宿主环境提供的bind方法</div><div class="line">    if(func.bind === nativeBind &amp;&amp; nativeBind)</div><div class="line">        return nativeBind.apply(func, slice.call(arguments, 1));</div><div class="line">    // func参数必须是一个函数(Function)类型</div><div class="line">    if(!_.isFunction(func))</div><div class="line">        throw new TypeError;</div><div class="line">    // args变量存储了bind方法第三个开始的参数列表, 每次调用时都将传递给func函数</div><div class="line">    args = slice.call(arguments, 2);</div><div class="line">    return bound = function() &#123;</div><div class="line">        if(!(this instanceof bound))</div><div class="line">            return func.apply(context, args.concat(slice.call(arguments)));</div><div class="line">        ctor.prototype = func.prototype;</div><div class="line">        var self = new ctor;</div><div class="line">        var result = func.apply(self, args.concat(slice.call(arguments)));</div><div class="line">        if(Object(result) === result)</div><div class="line">            return result;</div><div class="line">        return self;</div><div class="line">    &#125;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这个函数为一个函数绑定执行上下文, 任何情况下调用该函数, 函数中的this均指向context对象，绑定函数时, 可以同时给函数传递调用形参</p>
<h2 id="bindAll"><a href="#bindAll" class="headerlink" title="_.bindAll"></a>_.bindAll</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">_.bindAll = function(obj) &#123;</div><div class="line">    // 第二个参数开始表示需要绑定的函数名称</div><div class="line">    var funcs = slice.call(arguments, 1);</div><div class="line">    // 如果没有指定特定的函数名称, 则默认绑定对象本身所有类型为Function的属性</div><div class="line">    if(funcs.length == 0)</div><div class="line">        funcs = _.functions(obj);</div><div class="line">    // 循环并将所有的函数上下本设置为obj对象本身</div><div class="line">    // each方法本身不会遍历对象原型链中的方法, 但此处的funcs列表是通过_.functions方法获取的, 它已经包含了原型链中的方法</div><div class="line">    each(funcs, function(f) &#123;</div><div class="line">        obj[f] = _.bind(obj[f], obj);</div><div class="line">    &#125;);</div><div class="line">    return obj;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这个函数将指定的函数, 或对象本身的所有函数上下本绑定到对象本身, 被绑定的函数在被调用时, 上下文对象始终指向对象本身</p>
<h2 id="memoize"><a href="#memoize" class="headerlink" title="_.memoize"></a>_.memoize</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">_.memoize = function(func, hasher) &#123;</div><div class="line">    // 用于存储缓存结果的memo对象</div><div class="line">    var memo = &#123;&#125;;</div><div class="line">    // hasher参数应该是一个function, 它用于返回一个key, 该key作为读取缓存的标识</div><div class="line">    // 如果没有指定key, 则默认使用函数的第一个参数作为key, 如果函数的第一个参数是复合数据类型, 可能会返回类似[Object object]的key, 这个key可能会造成后续计算的数据不正确</div><div class="line">    hasher || ( hasher = _.identity);</div><div class="line">    // 返回一个函数, 该函数首先通过检查缓存, 再对没有缓存过的数据进行调用</div><div class="line">    return function() &#123;</div><div class="line">        var key = hasher.apply(this, arguments);</div><div class="line">        return _.has(memo, key) ? memo[key] : (memo[key] = func.apply(this, arguments));</div><div class="line">    &#125;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这个函数将返回一个函数, 该函数集成了缓存功能, 将经过计算的值缓存到局部变量并在下次调用时直接返回</p>
<h2 id="delay"><a href="#delay" class="headerlink" title="_.delay"></a>_.delay</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">_.delay = function(func, wait) &#123;</div><div class="line">    var args = slice.call(arguments, 2);</div><div class="line">    // 通过setTimeout来延时执行</div><div class="line">    return setTimeout(function() &#123;</div><div class="line">        return func.apply(null, args);</div><div class="line">    &#125;, wait);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这个函数的作用是延时执行一个函数，wait单位为ms, 第3个参数开始将被依次传递给执行函数</p>
<h2 id="defer"><a href="#defer" class="headerlink" title="_.defer"></a>_.defer</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">_.defer = function(func) &#123;</div><div class="line">    // 相当于_.delay(func, 1, [arguments]);</div><div class="line">    return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这个函数的作用是延迟1ms执行函数，javascript是一个单线程的程序，setTimeout(func, time)作用是把func放到处理任务的队列末尾，在其他任务都完成之后的time ms 后执行func</p>
<h2 id="throttle"><a href="#throttle" class="headerlink" title="_.throttle"></a>_.throttle</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">_.throttle = function(func, wait) &#123;</div><div class="line">    var context, args, timeout, throttling, more, result;</div><div class="line">    // whenDone变量调用了debounce方法, 因此在多次连续调用函数时, 最后一次调用会覆盖之前调用的定时器, 清除状态函数也仅会被执行一次</div><div class="line">    // whenDone函数在最后一次函数执行的时间间隔截止时调用, 清除节流和调用过程中记录的一些状态</div><div class="line">    var whenDone = _.debounce(function() &#123;</div><div class="line">        more = throttling = false;</div><div class="line">    &#125;, wait);</div><div class="line">    // 返回一个函数, 并在函数内进行节流控制</div><div class="line">    return function() &#123;</div><div class="line">        // 保存函数的执行上下文和参数</div><div class="line">        context = this;</div><div class="line">        args = arguments;</div><div class="line">        // later函数在上一次函数调用时间间隔截止时执行</div><div class="line">        var later = function() &#123;</div><div class="line">            // 清除timeout句柄, 方便下一次函数调用</div><div class="line">            timeout = null;</div><div class="line">            // more记录了在上一次调用至时间间隔截止之间, 是否重复调用了函数</div><div class="line">            // 如果重复调用了函数, 在时间间隔截止时将自动再次调用函数</div><div class="line">            if(more)</div><div class="line">                func.apply(context, args);</div><div class="line">            // 调用whenDone, 用于在时间间隔后清除节流状态</div><div class="line">            whenDone();</div><div class="line">        &#125;;</div><div class="line">        // timeout记录了上一次函数执行的时间间隔句柄</div><div class="line">        // timeout时间间隔截止时调用later函数, later中将清除timeout, 并检查是否需要再次调用函数</div><div class="line">        if(!timeout)</div><div class="line">            timeout = setTimeout(later, wait);</div><div class="line">        // throttling变量记录上次调用的时间间隔是否已经结束, 即是否处于节流过程中</div><div class="line">        // throttling在每次函数调用时设为true, 表示需要进行节流, 在时间间隔截止时设置为false(在whenDone函数中实现)</div><div class="line">        if(throttling) &#123;</div><div class="line">            // 节流过程中进行了多次调用, 在more中记录一个状态, 表示在时间间隔截止时需要再次自动调用函数</div><div class="line">            more = true;</div><div class="line">        &#125; else &#123;</div><div class="line">            // 没有处于节流过程, 可能是第一次调用函数, 或已经超过上一次调用的间隔, 可以直接调用函数</div><div class="line">            result = func.apply(context, args);</div><div class="line">        &#125;</div><div class="line">        // 调用whenDone, 用于在时间间隔后清除节流状态</div><div class="line">        whenDone();</div><div class="line">        // throttling变量记录函数调用时的节流状态</div><div class="line">        throttling = true;</div><div class="line">        // 返回调用结果</div><div class="line">        return result;</div><div class="line">    &#125;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这是函数节流方法, throttle方法主要用于控制函数的执行频率, 在被控制的时间间隔内, 频繁调用函数不会被多次执行，在时间间隔内如果多次调用了函数, 时间隔截止时会自动调用一次, 不需要等到时间截止后再手动调用(自动调用时不会有返回值)，throttle函数一般用于处理复杂和调用频繁的函数, 通过节流控制函数的调用频率, 节省处理资源</p>
<h2 id="debounce"><a href="#debounce" class="headerlink" title="_.debounce"></a>_.debounce</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">_.debounce = function(func, wait, immediate) &#123;</div><div class="line">    // timeout用于记录函数上一次调用的执行状态(定时器句柄)</div><div class="line">    // 当timeout为null时, 表示上一次调用已经结束</div><div class="line">    var timeout;</div><div class="line">    // 返回一个函数, 并在函数内进行节流控制</div><div class="line">    return function() &#123;</div><div class="line">        // 保持函数的上下文对象和参数</div><div class="line">        var context = this, args = arguments;</div><div class="line">        var later = function() &#123;</div><div class="line">            // 设置timeout为null</div><div class="line">            // later函数会在允许的时间截止时被调用</div><div class="line">            // 调用该函数时, 表明上一次函数执行时间已经超过了约定的时间间隔, 此时之后再进行调用都是被允许的</div><div class="line">            timeout = null;</div><div class="line">            if(!immediate)</div><div class="line">                func.apply(context, args);</div><div class="line">        &#125;;</div><div class="line">        // 如果函数被设定为立即执行, 且上一次调用的时间间隔已经过去, 则立即调用函数</div><div class="line">        if(immediate &amp;&amp; !timeout)</div><div class="line">            func.apply(context, args);</div><div class="line">        // 创建一个定时器用于检查和设置函数的调用状态</div><div class="line">        // 创建定时器之前先清空上一次setTimeout句柄, 无论上一次绑定的函数是否已经被执行</div><div class="line">        // 如果本次函数在调用时, 上一次函数执行还没有开始(一般是immediate设置为false时), 则函数的执行时间会被推迟, 因此timeout句柄会被重新创建</div><div class="line">        clearTimeout(timeout);</div><div class="line">        // 在允许的时间截止时调用later函数</div><div class="line">        timeout = setTimeout(later, wait);</div><div class="line">    &#125;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>debounce与throttle方法类似, 用于函数节流, 它们的不同之处在于:<br>    – throttle关注函数的执行频率, 在指定频率内函数只会被执行一次<br>    – debounce函数更关注函数执行的间隔, 即函数两次的调用时间不能小于指定时间<br>如果两次函数的执行间隔小于wait, 定时器会被清除并重新创建, 这意味着连续频繁地调用函数, 函数一直不会被执行, 直到某一次调用与上一次调用的时间不小于wait毫秒</p>
<h2 id="once"><a href="#once" class="headerlink" title="_.once"></a>_.once</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">_.once = function(func) &#123;</div><div class="line">    // ran记录函数是否被执行过</div><div class="line">    // memo记录函数最后一次执行的结果</div><div class="line">    var ran = false, memo;</div><div class="line">    return function() &#123;</div><div class="line">        // 如果函数已被执行过, 则直接返回第一次执行的结果</div><div class="line">        if(ran)</div><div class="line">            return memo;</div><div class="line">        ran = true;</div><div class="line">        return memo = func.apply(this, arguments);</div><div class="line">    &#125;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这个函数创建一个只会被执行一次的函数, 如果该函数被重复调用, 将返回第一次执行的结果</p>
<h2 id="wrap"><a href="#wrap" class="headerlink" title="_.wrap"></a>_.wrap</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">_.wrap = function(func, wrapper) &#123;</div><div class="line">    return function() &#123;</div><div class="line">        // 将当前函数作为第一个参数, 传递给wrapper函数</div><div class="line">        var args = [func].concat(slice.call(arguments, 0));</div><div class="line">        // 返回wrapper函数的处理结果</div><div class="line">        return wrapper.apply(this, args);</div><div class="line">    &#125;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这个函数返回一个函数, 该函数会将当前函数作为参数传递给一个包裹函数，在包裹函数中可以通过第一个参数调用当前函数, 并返回结果</p>
<h2 id="compose"><a href="#compose" class="headerlink" title="_.compose"></a>_.compose</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">_.compose = function() &#123;</div><div class="line">    // 获取函数列表, 所有参数需均为Function类型</div><div class="line">    var funcs = arguments;</div><div class="line">    // 返回一个供调用的函数句柄</div><div class="line">    return function() &#123;</div><div class="line">        // 从后向前依次执行函数, 并将记录的返回值作为参数传递给前一个函数继续处理</div><div class="line">        var args = arguments;</div><div class="line">        for(var i = funcs.length - 1; i &gt;= 0; i--) &#123;</div><div class="line">            args = [funcs[i].apply(this, args)];</div><div class="line">        &#125;</div><div class="line">        // 返回最后一次调用函数的返回值</div><div class="line">        return args[0];</div><div class="line">    &#125;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这个函数将多个函数组合到一起, 按照参数传递的顺序, 后一个函数的返回值会被依次作为参数传递给前一个函数作为参数继续处理，_.compose(A, B, C)等同于 A(B(C()))</p>
<h2 id="after"><a href="#after" class="headerlink" title="_.after"></a>_.after</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">_.after = function(times, func) &#123;</div><div class="line">    // 如果没有指定或指定无效次数, 则func被直接调用</div><div class="line">    if(times &lt;= 0)</div><div class="line">        return func();</div><div class="line">    // 返回一个计数器函数</div><div class="line">    return function() &#123;</div><div class="line">        // 每次调用计数器函数times减1, 调用times次之后执行func函数并返回func函数的返回值</div><div class="line">        if(--times &lt; 1) &#123;</div><div class="line">            return func.apply(this, arguments);</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>after返回一个函数, 该函数作为调用计数器, 当该函数被调用times次(或超过times次)后, func函数将被执行</p>
<h2 id="keys"><a href="#keys" class="headerlink" title="_.keys"></a>_.keys</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">_.keys = nativeKeys ||</div><div class="line">function(obj) &#123;</div><div class="line">    if(obj !== Object(obj))</div><div class="line">        throw new TypeError(&apos;Invalid object&apos;);</div><div class="line">    var keys = [];</div><div class="line">    // 记录并返回对象的所有属性名</div><div class="line">    for(var key in obj)</div><div class="line">    if(_.has(obj, key))</div><div class="line">        keys[keys.length] = key;</div><div class="line">    return keys;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这个函数用于获取一个对象的属性名列表(不包含原型链中的属性)</p>
<h2 id="values"><a href="#values" class="headerlink" title="_.values"></a>_.values</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">_.values = function(obj) &#123;</div><div class="line">    return _.map(obj, _.identity);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这个函数返回一个对象中所有属性的值列表(不包含原型链中的属性)</p>
<h2 id="functions-methods"><a href="#functions-methods" class="headerlink" title=".functions / .methods"></a><em>.functions / </em>.methods</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">_.functions = _.methods = function(obj) &#123;</div><div class="line">    var names = [];</div><div class="line">    for(var key in obj) &#123;</div><div class="line">        if(_.isFunction(obj[key]))</div><div class="line">            names.push(key);</div><div class="line">    &#125;</div><div class="line">    return names.sort();</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这个函数获取一个对象中所有属性值为Function类型的key列表, 并按key名进行排序(包含原型链中的属性)</p>
<h2 id="extend"><a href="#extend" class="headerlink" title="_.extend"></a>_.extend</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">_.extend = function(obj) &#123;</div><div class="line">    // each循环参数中的一个或多个对象</div><div class="line">    each(slice.call(arguments, 1), function(source) &#123;</div><div class="line">        // 将对象中的全部属性复制或覆盖到obj对象</div><div class="line">        for(var prop in source) &#123;</div><div class="line">            obj[prop] = source[prop];</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">    return obj;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这个函数将一个或多个对象的属性(包含原型链中的属性), 复制到obj对象, 如果存在同名属性则覆盖</p>
<h2 id="pick"><a href="#pick" class="headerlink" title="_.pick"></a>_.pick</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">_.pick = function(obj) &#123;</div><div class="line">    // 创建一个对象, 存放复制的指定属性</div><div class="line">    var result = &#123;&#125;;</div><div class="line">    // 从第二个参数开始合并为一个存放属性名列表的数组</div><div class="line">    each(_.flatten(slice.call(arguments, 1)), function(key) &#123;</div><div class="line">        // 循环属性名列表, 如果obj中存在该属性, 则将其复制到result对象</div><div class="line">        if( key in obj)</div><div class="line">            result[key] = obj[key];</div><div class="line">    &#125;);</div><div class="line">    // 返回复制结果</div><div class="line">    return result;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这个函数返回一个新对象, 并从obj中复制指定的属性到新对象中，第2个参数开始为指定的需要复制的属性名</p>
<h2 id="defaults"><a href="#defaults" class="headerlink" title="_.defaults"></a>_.defaults</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">_.defaults = function(obj) &#123;</div><div class="line">    // 从第二个参数开始可指定多个对象, 这些对象中的属性将被依次复制到obj对象中(如果obj对象中不存在该属性的话)</div><div class="line">    each(slice.call(arguments, 1), function(source) &#123;</div><div class="line">        // 遍历每个对象中的所有属性</div><div class="line">        for(var prop in source) &#123;</div><div class="line">            // 如果obj中不存在或属性值转换为Boolean类型后值为false, 则将属性复制到obj中</div><div class="line">            if(obj[prop] == null)</div><div class="line">                obj[prop] = source[prop];</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">    return obj;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这个函数将obj中不存在或转换为Boolean类型后值为false的属性, 从参数中指定的一个或多个对象中复制到obj，一般用于给对象指定默认值</p>
<h2 id="clone"><a href="#clone" class="headerlink" title="_.clone"></a>_.clone</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">_.clone = function(obj) &#123;</div><div class="line">    // 不支持非数组和对象类型的数据</div><div class="line">    if(!_.isObject(obj))</div><div class="line">        return obj;</div><div class="line">    // 复制并返回数组或对象</div><div class="line">    return _.isArray(obj) ? obj.slice() : _.extend(&#123;&#125;, obj);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这个函数创建一个obj的副本, 返回一个新的对象, 该对象包含obj中的所有属性和值的状态</p>
<h2 id="tap"><a href="#tap" class="headerlink" title="_.tap"></a>_.tap</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">_.tap = function(obj, interceptor) &#123;</div><div class="line">    interceptor(obj);</div><div class="line">    return obj;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这个函数执行一个函数, 并将obj作为参数传递给该函数, 函数执行完毕后最终返回obj对象</p>
<h2 id="eq"><a href="#eq" class="headerlink" title="eq"></a>eq</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div></pre></td><td class="code"><pre><div class="line">function eq(a, b, stack) &#123;</div><div class="line">    // 检查两个简单数据类型的值是否相等</div><div class="line">    // 对于复合数据类型, 如果它们来自同一个引用, 则认为其相等</div><div class="line">    // 如果被比较的值其中包含0, 则检查另一个值是否为-0, 因为 0 === -0 是成立的</div><div class="line">    // 而 1 / 0 == 1 / -0 是不成立的(1 / 0值为Infinity, 1 / -0值为-Infinity, 而Infinity不等于-Infinity)</div><div class="line">    if(a === b)</div><div class="line">        return a !== 0 || 1 / a == 1 / b;</div><div class="line">    // 将数据转换为布尔类型后如果值为false, 将判断两个值的数据类型是否相等(因为null与undefined, false, 0, 空字符串, 在非严格比较下值是相等的)</div><div class="line">    if(a == null || b == null)</div><div class="line">        return a === b;</div><div class="line">    // 如果进行比较的数据是一个Underscore封装的对象(具有_chain属性的对象被认为是Underscore对象)</div><div class="line">    // 则将对象解封后获取本身的数据(通过_wrapped访问), 然后再对本身的数据进行比较</div><div class="line">    // 它们的关系类似与一个jQuery封装的DOM对象, 和浏览器本身创建的DOM对象</div><div class="line">    if(a._chain)</div><div class="line">        a = a._wrapped;</div><div class="line">    if(b._chain)</div><div class="line">        b = b._wrapped;</div><div class="line">    // 如果对象提供了自定义的isEqual方法(此处的isEqual方法并非Undersocre对象的isEqual方法, 因为在上一步已经对Undersocre对象进行了解封)</div><div class="line">    // 则使用对象自定义的isEqual方法与另一个对象进行比较</div><div class="line">    if(a.isEqual &amp;&amp; _.isFunction(a.isEqual))</div><div class="line">        return a.isEqual(b);</div><div class="line">    if(b.isEqual &amp;&amp; _.isFunction(b.isEqual))</div><div class="line">        return b.isEqual(a);</div><div class="line">    // 对两个数据的数据类型进行验证</div><div class="line">    // 获取对象a的数据类型(通过Object.prototype.toString方法)</div><div class="line">    var className = toString.call(a);</div><div class="line">    // 如果对象a的数据类型与对象b不匹配, 则认为两个数据值也不匹配</div><div class="line">    if(className != toString.call(b))</div><div class="line">        return false;</div><div class="line">    // 执行到此处, 可以确保需要比较的两个数据均为复合数据类型, 且数据类型相等</div><div class="line">    // 通过switch检查数据的数据类型, 针对不同数据类型进行不同的比较</div><div class="line">    // (此处不包括对数组和对象类型, 因为它们可能包含更深层次的数据, 将在后面进行深层比较)</div><div class="line">    switch (className) &#123;</div><div class="line">        case &apos;[object String]&apos;:</div><div class="line">            // 如果被比较的是字符串类型(其中a的是通过new String()创建的字符串)</div><div class="line">            // 则将B转换为String对象后进行匹配(这里匹配并非进行严格的数据类型检查, 因为它们并非来自同一个对象的引用)</div><div class="line">            // 在调用 == 进行比较时, 会自动调用对象的toString()方法, 返回两个简单数据类型的字符串</div><div class="line">            return a == String(b);</div><div class="line">        case &apos;[object Number]&apos;:</div><div class="line">            // 通过+a将a转成一个Number, 如果a被转换之前与转换之后不相等, 则认为a是一个NaN类型</div><div class="line">            // 因为NaN与NaN是不相等的, 因此当a值为NaN时, 无法简单地使用a == b进行匹配, 而是用相同的方法检查b是否为NaN(即 b != +b)</div><div class="line">            // 当a值是一个非NaN的数据时, 则检查a是否为0, 因为当b为-0时, 0 === -0是成立的(实际上它们在逻辑上属于两个不同的数据)</div><div class="line">            return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);</div><div class="line">        case &apos;[object Date]&apos;:</div><div class="line">        // 对日期类型没有使用return或break, 因此会继续执行到下一步(无论数据类型是否为Boolean类型, 因为下一步将对Boolean类型进行检查)</div><div class="line">        case &apos;[object Boolean]&apos;:</div><div class="line">            // 将日期或布尔类型转换为数字</div><div class="line">            // 日期类型将转换为数值类型的时间戳(无效的日期格式将被换转为NaN)</div><div class="line">            // 布尔类型中, true被转换为1, false被转换为0</div><div class="line">            // 比较两个日期或布尔类型被转换为数字后是否相等</div><div class="line">            return +a == +b;</div><div class="line">        case &apos;[object RegExp]&apos;:</div><div class="line">            // 正则表达式类型, 通过source访问表达式的字符串形式</div><div class="line">            // 检查两个表达式的字符串形式是否相等</div><div class="line">            // 检查两个表达式的全局属性是否相同(包括g, i, m)</div><div class="line">            // 如果完全相等, 则认为两个数据相等</div><div class="line">            return a.source == b.source &amp;&amp; a.global == b.global &amp;&amp; a.multiline == b.multiline &amp;&amp; a.ignoreCase == b.ignoreCase;</div><div class="line">    &#125;</div><div class="line">    // 当执行到此时, ab两个数据应该为类型相同的对象或数组类型</div><div class="line">    if( typeof a != &apos;object&apos; || typeof b != &apos;object&apos;)</div><div class="line">        return false;</div><div class="line">    // stack(堆)是在isEqual调用eq函数时内部传递的空数组, 在后面比较对象和数据的内部迭代中调用eq方法也会传递</div><div class="line">    // length记录堆的长度</div><div class="line">    var length = stack.length;</div><div class="line">    while(length--) &#123;</div><div class="line">        // 如果堆中的某个对象与数据a匹配, 则认为相等</div><div class="line">        if(stack[length] == a)</div><div class="line">            return true;</div><div class="line">    &#125;</div><div class="line">    // 将数据a添加到堆中</div><div class="line">    stack.push(a);</div><div class="line">    // 定义一些局部变量</div><div class="line">    var size = 0, result = true;</div><div class="line">    // 通过递归深层比较对象和数组</div><div class="line">    if(className == &apos;[object Array]&apos;) &#123;</div><div class="line">        // 被比较的数据为数组类型</div><div class="line">        // size记录数组的长度</div><div class="line">        // result比较两个数组的长度是否一致, 如果长度不一致, 则方法的最后将返回result(即false)</div><div class="line">        size = a.length;</div><div class="line">        result = size == b.length;</div><div class="line">        // 如果两个数组的长度一致</div><div class="line">        if(result) &#123;</div><div class="line">            // 调用eq方法对数组中的元素进行迭代比较(如果数组中包含二维数组或对象, eq方法会进行深层比较)</div><div class="line">            while(size--) &#123;</div><div class="line">                // 在确保两个数组都存在当前索引的元素时, 调用eq方法深层比较(将堆数据传递给eq方法)</div><div class="line">                // 将比较的结果存储到result变量, 如果result为false(即在比较中得到某个元素的数据不一致), 则停止迭代</div><div class="line">                if(!( result = size in a == size in b &amp;&amp; eq(a[size], b[size], stack)))</div><div class="line">                    break;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125; else &#123;</div><div class="line">        // 被比较的数据为对象类型</div><div class="line">        // 如果两个对象不是同一个类的实例(通过constructor属性比较), 则认为两个对象不相等</div><div class="line">        if(&apos;constructor&apos; in a != &apos;constructor&apos; in b || a.constructor != b.constructor)</div><div class="line">            return false;</div><div class="line">        // 深层比较两个对象中的数据</div><div class="line">        for(var key in a) &#123;</div><div class="line">            if(_.has(a, key)) &#123;</div><div class="line">                // size用于记录比较过的属性数量, 因为这里遍历的是a对象的属性, 并比较b对象中该属性的数据</div><div class="line">                // 当b对象中的属性数量多余a对象时, 此处的逻辑成立, 但两个对象并不相等</div><div class="line">                size++;</div><div class="line">                // 迭代调用eq方法, 深层比较两个对象中的属性值</div><div class="line">                // 将比较的结果记录到result变量, 当比较到不相等的数据时停止迭代</div><div class="line">                if(!( result = _.has(b, key) &amp;&amp; eq(a[key], b[key], stack)))</div><div class="line">                    break;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        // 深层比较完毕, 这里已经可以确保在对象a中的所有数据, 对象b中也存在相同的数据</div><div class="line">        // 根据size(对象属性长度)检查对象b中的属性数量是否与对象a相等</div><div class="line">        if(result) &#123;</div><div class="line">            // 遍历对象b中的所有属性</div><div class="line">            for(key in b) &#123;</div><div class="line">                // 当size已经到0时(即对象a中的属性数量已经遍历完毕), 而对象b中还存在有属性, 则对象b中的属性多于对象a</div><div class="line">                if(_.has(b, key) &amp;&amp; !(size--))</div><div class="line">                    break;</div><div class="line">            &#125;</div><div class="line">            // 当对象b中的属性多于对象a, 则认为两个对象不相等</div><div class="line">            result = !size;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    // 函数执行完毕时, 从堆中移除第一个数据(在比较对象或数组时, 会迭代eq方法, 堆中可能存在多个数据)</div><div class="line">    stack.pop();</div><div class="line">    // 返回的result记录了最终的比较结果</div><div class="line">    return result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>eq函数只在isEqual方法中调用, 用于比较两个数据的值是否相等,与 === 不同在于, eq更关注数据的值,如果进行比较的是两个复合数据类型, 不仅仅比较是否来自同一个引用, 且会进行深层比较(对两个对象的结构和数据进行比较)</p>
<h2 id="isEqual"><a href="#isEqual" class="headerlink" title="_.isEqual"></a>_.isEqual</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">_.isEqual = function(a, b) &#123;</div><div class="line">    return eq(a, b, []);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>不多说了，就是内部函数eq的外部方法</p>
<h2 id="isEmpty"><a href="#isEmpty" class="headerlink" title="_.isEmpty"></a>_.isEmpty</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">_.isEmpty = function(obj) &#123;</div><div class="line">    // obj被转换为Boolean类型后值为false</div><div class="line">    if(obj == null)</div><div class="line">        return true;</div><div class="line">    // 检查对象或字符串长度是否为0</div><div class="line">    if(_.isArray(obj) || _.isString(obj))</div><div class="line">        return obj.length === 0;</div><div class="line">    // 检查对象(使用for in循环时将首先循环对象本身的属性, 其次是原型链中的属性), 因此如果第一个属性是属于对象本身的, 那么该对象不是一个空对象</div><div class="line">    for(var key in obj)</div><div class="line">    if(_.has(obj, key))</div><div class="line">        return false;</div><div class="line">    // 所有数据类型均没有通过验证, 是一个空数据</div><div class="line">    return true;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这个函数用于检查数据是否为空值, 包含’’, false, 0, null, undefined, NaN, 空数组(数组长度为0)和空对象(对象本身没有任何属性)</p>
<h2 id="isElement"><a href="#isElement" class="headerlink" title="_.isElement"></a>_.isElement</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">_.isElement = function(obj) &#123;</div><div class="line">    return !!(obj &amp;&amp; obj.nodeType == 1);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这个函数用于验证对象是否是一个DOM对象</p>
<h2 id="isArray"><a href="#isArray" class="headerlink" title="_.isArray"></a>_.isArray</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">_.isArray = nativeIsArray ||</div><div class="line">function(obj) &#123;</div><div class="line">    return toString.call(obj) == &apos;[object Array]&apos;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这个函数用于验证一个变量是否是数组</p>
<h2 id="isObject"><a href="#isObject" class="headerlink" title="_.isObject"></a>_.isObject</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">_.isObject = function(obj) &#123;</div><div class="line">    return obj === Object(obj);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这个函数用于验证对象是否是一个复合数据类型的对象(即非基本数据类型String, Boolean, Number, null, undefined)</p>
<h2 id="isArguments"><a href="#isArguments" class="headerlink" title="_.isArguments"></a>_.isArguments</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">_.isArguments = function(obj) &#123;</div><div class="line">    return toString.call(obj) == &apos;[object Arguments]&apos;;</div><div class="line">&#125;;</div><div class="line">// 验证isArguments函数, 如果运行环境无法正常验证arguments类型的数据, 则重新定义isArguments方法</div><div class="line">if(!_.isArguments(arguments)) &#123;</div><div class="line">    // 对于环境无法通过toString验证arguments类型的, 则通过调用arguments独有的callee方法来进行验证</div><div class="line">    _.isArguments = function(obj) &#123;</div><div class="line">        // callee是arguments的一个属性, 指向对arguments所属函数自身的引用</div><div class="line">        return !!(obj &amp;&amp; _.has(obj, &apos;callee&apos;));</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个函数用于检查一个数据是否是一个arguments参数对象</p>
<h2 id="isFunction-isString-isNumber-isDate-isRegExp"><a href="#isFunction-isString-isNumber-isDate-isRegExp" class="headerlink" title=".isFunction / .isString / .isNumber / .isDate / _.isRegExp"></a><em>.isFunction / </em>.isString / <em>.isNumber / </em>.isDate / _.isRegExp</h2><p>这几个我就放在一起说了，他们都是通过<strong>Object.prototype.toString.call(obj)</strong>的值来进行判断的</p>
<h2 id="isFinite"><a href="#isFinite" class="headerlink" title="_.isFinite"></a>_.isFinite</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">_.isFinite = function(obj) &#123;</div><div class="line">    return _.isNumber(obj) &amp;&amp; isFinite(obj);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这个函数用于检查一个数字是否为有效数字且有效范围(Number类型, 值在负无穷大 - 正无穷大之间)</p>
<h2 id="isNaN"><a href="#isNaN" class="headerlink" title="_.isNaN"></a>_.isNaN</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">_.isNaN = function(obj) &#123;</div><div class="line">    return obj !== obj;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>在js里，所有数据中只有NaN与NaN不相等</p>
<h2 id="isBoolean"><a href="#isBoolean" class="headerlink" title="_.isBoolean"></a>_.isBoolean</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">_.isBoolean = function(obj) &#123;</div><div class="line">    // 支持字面量和对象形式的Boolean数据</div><div class="line">    return obj === true || obj === false || toString.call(obj) == &apos;[object Boolean]&apos;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这个函数用于检查数据是否是Boolean类型</p>
<h2 id="isNull"><a href="#isNull" class="headerlink" title="_.isNull"></a>_.isNull</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">_.isNull = function(obj) &#123;</div><div class="line">    return obj === null;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这个函数用于检查数据是否是Null值</p>
<h2 id="isUndefined"><a href="#isUndefined" class="headerlink" title="_.isUndefined"></a>_.isUndefined</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">_.isUndefined = function(obj) &#123;</div><div class="line">    return obj === void 0;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这个函数用于检查数据是否是Undefined值</p>
<h2 id="has"><a href="#has" class="headerlink" title="_.has"></a>_.has</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">_.has = function(obj, key) &#123;</div><div class="line">    return hasOwnProperty.call(obj, key);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这个函数检查一个属性是否属于对象本身, 而非原型链中</p>
<h2 id="noConflict"><a href="#noConflict" class="headerlink" title="_.noConflict"></a>_.noConflict</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">_.noConflict = function() &#123;</div><div class="line">    // previousUnderscore变量记录了Underscore定义前_(下划线)的值</div><div class="line">    root._ = previousUnderscore;</div><div class="line">    return this;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这个函数一般用于避免命名冲突或规范命名方式，放弃_(下划线)命名的Underscore对象, 并返回Underscore对象</p>
<h2 id="identity"><a href="#identity" class="headerlink" title="_.identity"></a>_.identity</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">_.identity = function(value) &#123;</div><div class="line">    return value;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这个函数返回与参数相同的值, 一般用于将一个数据的获取方式转换为函数获取方式(内部用于构建方法时作为默认处理器函数)</p>
<h2 id="times"><a href="#times" class="headerlink" title="_.times"></a>_.times</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">_.times = function(n, iterator, context) &#123;</div><div class="line">    for(var i = 0; i &lt; n; i++)</div><div class="line">    iterator.call(context, i);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这个函数的作用是使指定的函数迭代执行n次(无参数)</p>
<h2 id="escape"><a href="#escape" class="headerlink" title="_.escape"></a>_.escape</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">_.escape = function(string) &#123;</div><div class="line">    return (&apos;&apos; + string).replace(/&amp;/g, &apos;&amp;amp;&apos;).replace(/&lt;/g, &apos;&amp;lt;&apos;).replace(/&gt;/g, &apos;&amp;gt;&apos;).replace(/&quot;/g, &apos;&amp;quot;&apos;).replace(/&apos;/g, &apos;&amp;#x27;&apos;).replace(/\//g, &apos;&amp;#x2F;&apos;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这个函数用于将HTML字符串中的特殊字符转换为HTML实体, 包含 &amp; &lt; &gt; “ ‘ \</p>
<h2 id="result"><a href="#result" class="headerlink" title="_.result"></a>_.result</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">_.result = function(object, property) &#123;</div><div class="line">    if(object == null)</div><div class="line">        return null;</div><div class="line">    // 获取对象的值</div><div class="line">    var value = object[property];</div><div class="line">    // 如果值是一个函数, 则执行并返回, 否则将直接返回</div><div class="line">    return _.isFunction(value) ? value.call(object) : value;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这个函数指定一个对象的属性, 返回该属性对应的值, 如果该属性对应的是一个函数, 则会执行该函数并返回结果</p>
<h2 id="mixin"><a href="#mixin" class="headerlink" title="_.mixin"></a>_.mixin</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">_.mixin = function(obj) &#123;</div><div class="line">    // obj是一个集合一系列自定义方法的对象, 此处通过each遍历对象的方法</div><div class="line">    each(_.functions(obj), function(name) &#123;</div><div class="line">        // 通过addToWrapper函数将自定义方法添加到Underscore构建的对象中, 用于支持对象式调用</div><div class="line">        // 同时将方法添加到 _ 本身, 用于支持函数式调用</div><div class="line">        addToWrapper(name, _[name] = obj[name]);</div><div class="line">    &#125;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这个函数添加一系列自定义方法到Underscore对象中, 用于扩展Underscore插件</p>
<h2 id="template"><a href="#template" class="headerlink" title="_.template"></a>_.template</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">_.template = function(text, data, settings) &#123;</div><div class="line">    // 模板配置, 如果没有指定配置项, 则使用templateSettings中指定的配置项</div><div class="line">    settings = _.defaults(settings || &#123;&#125;, _.templateSettings);</div><div class="line"></div><div class="line">    // 开始将模板解析为可执行源码</div><div class="line">    var source = &quot;__p+=&apos;&quot; + text.replace(escaper, function(match) &#123;</div><div class="line">        // 将特殊符号转移为字符串形式</div><div class="line">        return &apos;\\&apos; + escapes[match];</div><div class="line">    &#125;).replace(settings.escape || noMatch, function(match, code) &#123;</div><div class="line">        // 解析escape形式标签 &lt;%- %&gt;, 将变量中包含的HTML通过_.escape函数转换为HTML实体</div><div class="line">        return &quot;&apos;+\n_.escape(&quot; + unescape(code) + &quot;)+\n&apos;&quot;;</div><div class="line">    &#125;).replace(settings.interpolate || noMatch, function(match, code) &#123;</div><div class="line">        // 解析interpolate形式标签 &lt;%= %&gt;, 将模板内容作为一个变量与其它字符串连接起来, 则会作为一个变量输出</div><div class="line">        return &quot;&apos;+\n(&quot; + unescape(code) + &quot;)+\n&apos;&quot;;</div><div class="line">    &#125;).replace(settings.evaluate || noMatch, function(match, code) &#123;</div><div class="line">        // 解析evaluate形式标签 &lt;% %&gt;, evaluate标签中存储了需要执行的JavaScript代码, 这里结束当前的字符串拼接, 并在新的一行作为JavaScript语法执行, 并将后面的内容再次作为字符串的开始, 因此evaluate标签内的JavaScript代码就能被正常执行</div><div class="line">        return &quot;&apos;;\n&quot; + unescape(code) + &quot;\n;__p+=&apos;&quot;;</div><div class="line">    &#125;) + &quot;&apos;;\n&quot;;</div><div class="line">    if(!settings.variable)</div><div class="line">        source = &apos;with(obj||&#123;&#125;)&#123;\n&apos; + source + &apos;&#125;\n&apos;;</div><div class="line">    source = &quot;var __p=&apos;&apos;;&quot; + &quot;var print=function()&#123;__p+=Array.prototype.join.call(arguments, &apos;&apos;)&#125;;\n&quot; + source + &quot;return __p;\n&quot;;</div><div class="line"></div><div class="line">    // 创建一个函数, 将源码作为函数执行体, 将obj和Underscore作为参数传递给该函数</div><div class="line">    var render = new Function(settings.variable || &apos;obj&apos;, &apos;_&apos;, source);</div><div class="line">    // 如果指定了模板的填充数据, 则替换模板内容, 并返回替换后的结果</div><div class="line">    if(data)</div><div class="line">        return render(data, _);</div><div class="line">    // 如果没有指定填充数据, 则返回一个函数, 该函数用于将接收到的数据替换到模板</div><div class="line">    // 如果在程序中会多次填充相同模板, 那么在第一次调用时建议不指定填充数据, 在获得处理函数的引用后, 再直接调用会提高运行效率</div><div class="line">    var template = function(data) &#123;</div><div class="line">        return render.call(this, data, _);</div><div class="line">    &#125;;</div><div class="line">    // 将创建的源码字符串添加到函数对象中, 一般用于调试和测试</div><div class="line">    template.source = &apos;function(&apos; + (settings.variable || &apos;obj&apos;) + &apos;)&#123;\n&apos; + source + &apos;&#125;&apos;;</div><div class="line">    // 没有指定填充数据的情况下, 返回处理函数句柄</div><div class="line">    return template;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这个我要介绍的最后一个函数，也是我个人认为比较重要的，它是Underscore模板解析方法, 用于将数据填充到一个模板字符串中，在模板体内, 可通过argments获取2个参数, 分别为填充数据(名称为obj)和Underscore对象(名称为_)</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>今天一口气把剩下的所有函数都介绍完了，真是累感不爱啊，不过在写作这几篇博客的过程中，我也从Underscore这个框架中学到了很多东西，包括它的优雅的代码风格（至少比我自己写的优雅），还有一个优秀的库整个的架构是怎么搭建起来的。<br>以后我还会继续为大家分享其他的前端知识和学习心得，thx for reading, hope u enjoy</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我在这个系列的第一篇文章说过，我学underscore是为了在学backbone的时候少一些阻碍，从第一篇的写作时间到今天，大概也有个十几二十天，感觉拖得有点久，所以今天将会是underscore源码解析系列的最后一篇文章，我会在这篇文章中介绍underscore剩下的所有
    
    </summary>
    
      <category term="技术" scheme="http://joeray61.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="javascript" scheme="http://joeray61.com/tags/javascript/"/>
    
      <category term="underscore" scheme="http://joeray61.com/tags/underscore/"/>
    
      <category term="源码" scheme="http://joeray61.com/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Underscore源码解析（三）</title>
    <link href="http://joeray61.com/2014/06/06/Underscore%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>http://joeray61.com/2014/06/06/Underscore源码解析（三）/</id>
    <published>2014-06-06T10:32:17.000Z</published>
    <updated>2017-04-04T10:42:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>前两天在微博上看到SF的微博推荐了我的前两篇文章，有点意外和惊喜。作为一个菜鸟，真的是倍受鼓舞，我写博客的动力也更充足了。<br>没看过前两篇博客的朋友可以戳这里：<a href="/2014/05/21/Underscore源码解析（一）/">Underscore源码解析（一）</a>、<a href="/2014/06/03/Underscore源码解析（二）/">Underscore源码解析（二）</a><br>上一篇文章介绍了underscore的10个函数的具体实现细节，今天将继续介绍其他的函数。</p>
<h2 id="invoke"><a href="#invoke" class="headerlink" title="_.invoke"></a>_.invoke</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">_.invoke = function(obj, method) &#123;</div><div class="line">    // 调用同名方法时传递的参数(从第3个参数开始)</div><div class="line">    var args = slice.call(arguments, 2);</div><div class="line">    // 依次调用每个元素的方法, 并将结果放入数组中返回</div><div class="line">    return _.map(obj, function(value) &#123;</div><div class="line">        return (_.isFunction(method) ? method || value : value[method]).apply(value, args);</div><div class="line">    &#125;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这个函数依次调用集合中所有元素的同名方法，从第3个参数开始的所有参数将被传入到元素的调用方法中，最后返回一个数组，该数组存储了所有方法的处理结果</p>
<h2 id="pluck"><a href="#pluck" class="headerlink" title="_.pluck"></a>_.pluck</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">_.pluck = function(obj, key) &#123;</div><div class="line">    // 如果某一个对象中不存在该属性, 则返回undefined</div><div class="line">    return _.map(obj, function(value) &#123;</div><div class="line">        return value[key];</div><div class="line">    &#125;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这个函数遍历了一个由对象列表组成的集合，并返回每个对象中的指定属性的值列表</p>
<h2 id="max"><a href="#max" class="headerlink" title="_.max"></a>_.max</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">_.max = function(obj, iterator, context) &#123;</div><div class="line">    // 如果集合是一个数组, 且没有使用处理器, 则使用Math.max获取最大值</div><div class="line">    // 一般会是在一个数组存储了一系列Number类型的数据</div><div class="line">    if(!iterator &amp;&amp; _.isArray(obj) &amp;&amp; obj[0] === +obj[0])</div><div class="line">        return Math.max.apply(Math, obj);</div><div class="line">    // 对于空值, 直接返回负无穷大</div><div class="line">    if(!iterator &amp;&amp; _.isEmpty(obj))</div><div class="line">        return -Infinity;</div><div class="line">    // 一个临时的对象, computed用于在比较过程中存储最大值(临时的)</div><div class="line">    var result = &#123;</div><div class="line">        computed : -Infinity</div><div class="line">    &#125;;</div><div class="line">    // 迭代集合中的元素</div><div class="line">    each(obj, function(value, index, list) &#123;</div><div class="line">        // 如果指定了处理器参数, 则比较的数据为处理器返回的值, 否则直接使用each遍历时的默认值</div><div class="line">        var computed = iterator ? iterator.call(context, value, index, list) : value;</div><div class="line">        // 如果比较值相比上一个值要大, 则将当前值放入result.value</div><div class="line">        computed &gt;= result.computed &amp;&amp; ( result = &#123;</div><div class="line">            value : value,</div><div class="line">            computed : computed</div><div class="line">        &#125;);</div><div class="line">    &#125;);</div><div class="line">    // 返回最大值</div><div class="line">    return result.value;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>顾名思义，这个函数用来返回集合中的最大值, 如果不存在可比较的值, 则返回undefined</p>
<h2 id="min"><a href="#min" class="headerlink" title="_.min"></a>_.min</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">_.min = function(obj, iterator, context) &#123;</div><div class="line">    if(!iterator &amp;&amp; _.isArray(obj) &amp;&amp; obj[0] === +obj[0])</div><div class="line">        return Math.min.apply(Math, obj);</div><div class="line">    if(!iterator &amp;&amp; _.isEmpty(obj))</div><div class="line">        return Infinity;</div><div class="line">    var result = &#123;</div><div class="line">        computed : Infinity</div><div class="line">    &#125;;</div><div class="line">    each(obj, function(value, index, list) &#123;</div><div class="line">        var computed = iterator ? iterator.call(context, value, index, list) : value;</div><div class="line">        computed &lt; result.computed &amp;&amp; ( result = &#123;</div><div class="line">            value : value,</div><div class="line">            computed : computed</div><div class="line">        &#125;);</div><div class="line">    &#125;);</div><div class="line">    return result.value;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这个函数没有加注释，因为实现过程与max基本相同，用于返回集合中的最小值</p>
<h2 id="shuffle"><a href="#shuffle" class="headerlink" title="_.shuffle"></a>_.shuffle</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">_.shuffle = function(obj) &#123;</div><div class="line">    // shuffled变量存储处理过程及最终的结果数据</div><div class="line">    var shuffled = [], rand;</div><div class="line">    // 迭代集合中的元素</div><div class="line">    each(obj, function(value, index, list) &#123;</div><div class="line">        // 生成一个随机数, 随机数在&lt;0-当前已处理的数量&gt;之间</div><div class="line">        rand = Math.floor(Math.random() * (index + 1));</div><div class="line">        // 将已经随机得到的元素放到shuffled数组末尾</div><div class="line">        shuffled[index] = shuffled[rand];</div><div class="line">        // 在前面得到的随机数的位置插入最新值</div><div class="line">        shuffled[rand] = value;</div><div class="line">    &#125;);</div><div class="line">    // 返回一个数组, 该数组中存储了经过随机混排的集合元素</div><div class="line">    return shuffled;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这个函数是通过随机数, 让数组无须排列，实际上是实现了一个模拟洗牌过程的算法</p>
<h2 id="sortBy"><a href="#sortBy" class="headerlink" title="_.sortBy"></a>_.sortBy</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">_.sortBy = function(obj, val, context) &#123;</div><div class="line">    // val应该是对象的一个属性, 或一个处理器函数, 如果是一个处理器, 则应该返回需要进行比较的数据</div><div class="line">    var iterator = _.isFunction(val) ? val : function(obj) &#123;</div><div class="line">        return obj[val];</div><div class="line">    &#125;;</div><div class="line">    // 调用顺序: _.pluck(_.map().sort());</div><div class="line">    // 调用_.map()方法遍历集合, 并将集合中的元素放到value节点, 将元素中需要进行比较的数据放到criteria属性中</div><div class="line">    // 调用sort()方法将集合中的元素按照criteria属性中的数据进行顺序排序</div><div class="line">    // 调用pluck获取排序后的对象集合并返回</div><div class="line">    return _.pluck(_.map(obj, function(value, index, list) &#123;</div><div class="line">        return &#123;</div><div class="line">            value : value,</div><div class="line">            criteria : iterator.call(context, value, index, list)</div><div class="line">        &#125;;</div><div class="line">    &#125;).sort(function(left, right) &#123;</div><div class="line">        var a = left.criteria, b = right.criteria;</div><div class="line">        if(a ===</div><div class="line">            void 0)</div><div class="line">            return 1;</div><div class="line">        if(b ===</div><div class="line">            void 0)</div><div class="line">            return -1;</div><div class="line">        return a &lt; b ? -1 : a &gt; b ? 1 : 0;</div><div class="line">    &#125;), &apos;value&apos;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这个函数对集合中元素, 按照特定的字段或值进行排列，相比Array.prototype.sort方法, sortBy方法支持对对象排序</p>
<h2 id="groupBy"><a href="#groupBy" class="headerlink" title="_.groupBy"></a>_.groupBy</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">_.groupBy = function(obj, val) &#123;</div><div class="line">    var result = &#123;&#125;;</div><div class="line">    // val将被转换为进行分组的处理器函数, 如果val不是一个Function类型的数据, 则将被作为筛选元素时的key值</div><div class="line">    var iterator = _.isFunction(val) ? val : function(obj) &#123;</div><div class="line">        return obj[val];</div><div class="line">    &#125;;</div><div class="line">    // 迭代集合中的元素</div><div class="line">    each(obj, function(value, index) &#123;</div><div class="line">        // 将处理器的返回值作为key, 并将相同的key元素放到一个新的数组</div><div class="line">        var key = iterator(value, index);</div><div class="line">        (result[key] || (result[key] = [])).push(value);</div><div class="line">    &#125;);</div><div class="line">    // 返回已分组的数据</div><div class="line">    return result;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这个函数将集合中的元素, 按处理器返回的key分为多个数组</p>
<h2 id="sortedIndex"><a href="#sortedIndex" class="headerlink" title="_.sortedIndex"></a>_.sortedIndex</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">_.sortedIndex = function(array, obj, iterator) &#123;</div><div class="line">    // 如果没有指定处理器参数, 则使用默认的处理器函数，该函数会返回参数本身</div><div class="line">    iterator || ( iterator = _.identity);</div><div class="line">    var low = 0, high = array.length;</div><div class="line">    // 不断与中间值对比，寻找obj的正确插入点</div><div class="line">    while(low &lt; high) &#123;</div><div class="line">        // (low + high) &gt;&gt; 1 相当于 Math.floor((low + high) / 2)</div><div class="line">        var mid = (low + high) &gt;&gt; 1;</div><div class="line">        iterator(array[mid]) &lt; iterator(obj) ? low = mid + 1 : high = mid;</div><div class="line">    &#125;</div><div class="line">    // 返回obj插入array之后的索引号</div><div class="line">    return low;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这个函数的作用是将obj插入已经排序的array中，返回obj在array中的索引号</p>
<h2 id="toArray"><a href="#toArray" class="headerlink" title="_.toArray"></a>_.toArray</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">_.toArray = function(obj) &#123;</div><div class="line">    if(!obj)</div><div class="line">        return [];</div><div class="line">    if(_.isArray(obj))</div><div class="line">        return slice.call(obj);</div><div class="line">    // 将arguments转换为数组</div><div class="line">    if(_.isArguments(obj))</div><div class="line">        return slice.call(obj);</div><div class="line">    if(obj.toArray &amp;&amp; _.isFunction(obj.toArray))</div><div class="line">        return obj.toArray();</div><div class="line">    // 将对象转换为数组, 数组中包含对象中所有属性的值列表(不包含对象原型链中的属性)</div><div class="line">    return _.values(obj);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这个函数很简单，作用是将一个集合转换一个数组并返回</p>
<h2 id="size"><a href="#size" class="headerlink" title="_.size"></a>_.size</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">_.size = function(obj) &#123;</div><div class="line">    // 如果集合是一个数组, 则计算数组元素数量</div><div class="line">    // 如果集合是一个对象, 则计算对象中的属性数量(不包含对象原型链中的属性)</div><div class="line">    return _.isArray(obj) ? obj.length : _.keys(obj).length;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这个函数用于计算集合中元素的数量，isArray和keys函数后面会介绍到</p>
<h2 id="first-head-take"><a href="#first-head-take" class="headerlink" title=".first / .head / _.take"></a><em>.first / </em>.head / _.take</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">_.first = _.head = _.take = function(array, n, guard) &#123;</div><div class="line">    // 如果没有指定参数n, 则返回第一个元素</div><div class="line">    // 如果指定了n, 则返回一个新的数组, 包含顺序指定数量n个元素</div><div class="line">    // guard参数用于确定只返回第一个元素, 当guard为true时, 指定数量n无效</div><div class="line">    return (n != null) &amp;&amp; !guard ? slice.call(array, 0, n) : array[0];</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这个函数用于返回一个数组的第一个或順序指定的n个元素</p>
<h2 id="initial"><a href="#initial" class="headerlink" title="_.initial"></a>_.initial</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">_.initial = function(array, n, guard) &#123;</div><div class="line">    // 如果没有传递参数n, 则默认返回除最后一个元素外的其它元素</div><div class="line">    // 如果传递参数n, 则返回从最后一个元素开始向前的n个元素外的其它元素</div><div class="line">    // guard用于确定只返回一个元素, 当guard为true时, 指定数量n无效</div><div class="line">    return slice.call(array, 0, array.length - ((n == null) || guard ? 1 : n));</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这个函数返回一个新数组, 包含除最后一个元素外的其它元素, 或排除从最后一个元素开始向前指定n个元素</p>
<h2 id="last"><a href="#last" class="headerlink" title="_.last"></a>_.last</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">_.last = function(array, n, guard) &#123;</div><div class="line">    if((n != null) &amp;&amp; !guard) &#123;</div><div class="line">        // 计算并指定获取的元素位置n, 直到数组末尾, 作为一个新的数组返回</div><div class="line">        return slice.call(array, Math.max(array.length - n, 0));</div><div class="line">    &#125; else &#123;</div><div class="line">        // 如果没有指定数量, 或guard为true时, 只返回最后一个元素</div><div class="line">        return array[array.length - 1];</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这个函数与first相反，返回数组的最后一个或倒序指定的n个元素</p>
<h2 id="rest-tail"><a href="#rest-tail" class="headerlink" title=".rest / .tail"></a><em>.rest / </em>.tail</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">_.rest = _.tail = function(array, index, guard) &#123;</div><div class="line">    // 计算slice的第二个位置参数, 直到数组末尾</div><div class="line">    // 如果没有指定index, 或guard值为true, 则返回除第一个元素外的其它元素</div><div class="line">    // (index == null)值为true时, 作为参数传递给slice函数将被自动转换为1</div><div class="line">    return slice.call(array, (index == null) || guard ? 1 : index);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这个函数与initial相反，用于获取除了第一个或指定前n个元素外的其它元素</p>
<h2 id="campact"><a href="#campact" class="headerlink" title="_.campact"></a>_.campact</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">_.compact = function(array) &#123;</div><div class="line">    return _.filter(array, function(value) &#123;</div><div class="line">        return !!value;</div><div class="line">    &#125;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这个函数借助filter函数，返回数组中所有值能被转换为true的元素, 返回一个新的数组，不能被转换的值包括 false, 0, ‘’, null, undefined, NaN, 这些值将被转换为false</p>
<h2 id="flatten"><a href="#flatten" class="headerlink" title="_.flatten"></a>_.flatten</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">_.flatten = function(array, shallow) &#123;</div><div class="line">    // 迭代数组中的每一个元素, 并将返回值作为demo传递给下一次迭代</div><div class="line">    return _.reduce(array, function(memo, value) &#123;</div><div class="line">        // 如果元素依然是一个数组, 进行以下判断:</div><div class="line">        // - 如果不进行深层合并, 则使用Array.prototype.concat将当前数组和之前的数据进行连接</div><div class="line">        // - 如果支持深层合并, 则迭代调用flatten方法, 直到底层元素不再是数组类型</div><div class="line">        if(_.isArray(value))</div><div class="line">            return memo.concat( shallow ? value : _.flatten(value));</div><div class="line">        // 数据(value)已经处于底层, 不再是数组类型, 则将数据合并到memo中并返回</div><div class="line">        memo[memo.length] = value;</div><div class="line">        return memo;</div><div class="line">    &#125;, []);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这个函数用于将一个多维数组合成为一维数组, 支持深层合并，其中第二个参数shallow用于控制合并深度, 当shallow为true时, 只合并第一层, 默认进行深层合并</p>
<h2 id="without"><a href="#without" class="headerlink" title="_.without"></a>_.without</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">_.without = function(array) &#123;</div><div class="line">    return _.difference(array, slice.call(arguments, 1));</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这个函数用于筛选并返回当前数组中与指定数据不相等的差异数据，具体可以参看我后续对difference函数的介绍</p>
<h2 id="uniq-unique"><a href="#uniq-unique" class="headerlink" title=".uniq/.unique"></a><em>.uniq/</em>.unique</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">_.uniq = _.unique = function(array, isSorted, iterator) &#123;</div><div class="line">    // 如果使用了iterator处理器, 则先将当前数组中的数据会先经过按迭代器处理, 并返回一个处理后的新数组</div><div class="line">    // 新数组用于作为比较的基准</div><div class="line">    var initial = iterator ? _.map(array, iterator) : array;</div><div class="line">    // 用于记录处理结果的临时数组</div><div class="line">    var results = [];</div><div class="line">    // 如果数组中只有2个值, 则不需要使用include方法进行比较, 将isSorted设置为true能提高运行效率</div><div class="line">    if(array.length &lt; 3)</div><div class="line">        isSorted = true;</div><div class="line">    // 使用reduce方法迭代并累加处理结果</div><div class="line">    // initial变量是需要进行比较的基准数据, 它可能是原始数组, 也可能是处理器的结果集合(如果设置过iterator)</div><div class="line">    _.reduce(initial, function(memo, value, index) &#123;</div><div class="line">        // 如果isSorted参数为true, 则直接使用===比较记录中的最后一个数据</div><div class="line">        // 如果isSorted参数为false, 则使用include方法与集合中的每一个数据进行对比</div><div class="line">        if( isSorted ? _.last(memo) !== value || !memo.length : !_.include(memo, value)) &#123;</div><div class="line">            // memo记录了已经比较过的无重复数据</div><div class="line">            // 根据iterator参数的状态, memo中记录的数据可能是原始数据, 也可能是处理器处理后的数据</div><div class="line">            memo.push(value);</div><div class="line">            // 处理结果数组中保存的始终为原始数组中的数据</div><div class="line">            results.push(array[index]);</div><div class="line">        &#125;</div><div class="line">        return memo;</div><div class="line">    &#125;, []);</div><div class="line">    // 返回处理结果, 它只包含数组中无重复的数据</div><div class="line">    return results;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这个函数用于对数组中的数据进行去重(使用===进行比较)，当isSorted参数不为false时, 将依次对数组中的元素调用include方法, 检查相同元素是否已经被添加到返回值(数组)中，如果调用之前确保数组中数据按顺序排列, 则可以将isSorted设为true, 它将通过与最后一个元素进行对比来排除相同值, 使用isSorted效率会高于默认的include方式，uniq方法默认将以数组中的数据进行对比, 如果声明iterator处理器, 则会根据处理器创建一个对比数组, 比较时以该数组中的数据为准, 但最终返回的唯一数据仍然是原始数组</p>
<h2 id="union"><a href="#union" class="headerlink" title="_.union"></a>_.union</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">_.union = function() &#123;</div><div class="line">    // union对参数中的多个数组进行浅层合并为一个数组对象传递给uniq方法进行处理</div><div class="line">    return _.uniq(_.flatten(arguments, true));</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这个函数与uniq作用一致, 不同之处在于union允许在参数中传入多个数组</p>
<h2 id="intersection"><a href="#intersection" class="headerlink" title="_.intersection"></a>_.intersection</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">_.intersection = _.intersect = function(array) &#123;</div><div class="line">    // rest变量记录需要进行比较的其它数组对象</div><div class="line">    var rest = slice.call(arguments, 1);</div><div class="line">    // 使用uniq方法去除当前数组中的重复数据, 避免重复计算</div><div class="line">    // 对当前数组的数据通过处理器进行过滤, 并返回符合条件(比较相同元素)的数据</div><div class="line">    return _.filter(_.uniq(array), function(item) &#123;</div><div class="line">        // 使用every方法验证每一个数组中都包含了需要对比的数据</div><div class="line">        // 如果所有数组中均包含对比数据, 则全部返回true, 如果任意一个数组没有包含该元素, 则返回false</div><div class="line">        return _.every(rest, function(other) &#123;</div><div class="line">            // other参数存储了每一个需要进行对比的数组</div><div class="line">            // item存储了当前数组中需要进行对比的数据</div><div class="line">            // 使用indexOf方法搜索数组中是否存在该元素(可参考indexOf方法注释)</div><div class="line">            return _.indexOf(other, item) &gt;= 0;</div><div class="line">        &#125;);</div><div class="line">    &#125;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这个函数用于获取当前数组与其它一个或多个数组的交集元素，从第二个参数开始为需要进行比较的一个或多个数组</p>
<h2 id="difference"><a href="#difference" class="headerlink" title="_.difference"></a>_.difference</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">_.difference = function(array) &#123;</div><div class="line">    // 对第2个参数开始的所有参数, 作为一个数组进行合并(仅合并第一层, 而并非深层合并)</div><div class="line">    // rest变量存储验证数据, 在本方法中用于与原数据对比</div><div class="line">    var rest = _.flatten(slice.call(arguments, 1), true);</div><div class="line">    // 对合并后的数组数据进行过滤, 过滤条件是当前数组中不包含参数指定的验证数据的内容</div><div class="line">    // 将符合过滤条件的数据组合为一个新的数组并返回</div><div class="line">    return _.filter(array, function(value) &#123;</div><div class="line">        return !_.include(rest, value);</div><div class="line">    &#125;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这个函数会筛选并返回当前数组中与指定数据不相等的差异数据，一般用于删除数组中指定的数据, 并得到删除后的新数组</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>今天一共介绍了21个函数的具体实现，我都写累了，大家可能也看累了吧，我觉得写太多也不利于大家消化这些知识，今天就到这儿吧。thx for reading, hope u enjoy</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前两天在微博上看到SF的微博推荐了我的前两篇文章，有点意外和惊喜。作为一个菜鸟，真的是倍受鼓舞，我写博客的动力也更充足了。&lt;br&gt;没看过前两篇博客的朋友可以戳这里：&lt;a href=&quot;/2014/05/21/Underscore源码解析（一）/&quot;&gt;Underscore源码解析
    
    </summary>
    
      <category term="技术" scheme="http://joeray61.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="javascript" scheme="http://joeray61.com/tags/javascript/"/>
    
      <category term="underscore" scheme="http://joeray61.com/tags/underscore/"/>
    
      <category term="源码" scheme="http://joeray61.com/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Underscore源码解析（二）</title>
    <link href="http://joeray61.com/2014/06/03/Underscore%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://joeray61.com/2014/06/03/Underscore源码解析（二）/</id>
    <published>2014-06-03T10:36:04.000Z</published>
    <updated>2017-04-04T10:40:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近十几天都在忙毕业论文的事，所以上一次为大家介绍完underscore这个框架的结构（或者说是这个框架的设计思路）之后就一直没动静了，今天我又满血复活了，让我们继续来探索underscore的源码奥秘吧。<br>没看过上一篇文章的朋友可以戳这里：<a href="/2014/05/21/Underscore源码解析（一）/">underscore源码解析（一）</a><br>今天的内容是underscore里面封装的一些函数，我将逐个介绍，咱们直接入正题吧</p>
<h2 id="each-each-forEach"><a href="#each-each-forEach" class="headerlink" title="each / .each / .forEach"></a>each / <em>.each / </em>.forEach</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">var each = _.each = _.forEach = function(obj, iterator, context) &#123;</div><div class="line">    // 不处理空值</div><div class="line">    if(obj == null)</div><div class="line">        return;</div><div class="line">    if(nativeForEach &amp;&amp; obj.forEach === nativeForEach) &#123;</div><div class="line">        // 如果宿主环境支持, 则优先调用JavaScript 1.6提供的forEach方法</div><div class="line">        obj.forEach(iterator, context);</div><div class="line">    &#125; else if(obj.length === +obj.length) &#123;</div><div class="line">        // 对[数组]中每一个元素执行处理器方法</div><div class="line">        for(var i = 0, l = obj.length; i &lt; l; i++) &#123;</div><div class="line">            if( i in obj &amp;&amp; iterator.call(context, obj[i], i, obj) === breaker)</div><div class="line">                return;</div><div class="line">        &#125;</div><div class="line">    &#125; else &#123;</div><div class="line">        // 对&#123;对象&#125;中每一个元素执行处理器方法</div><div class="line">        for(var key in obj) &#123;</div><div class="line">            if(_.has(obj, key)) &#123;</div><div class="line">                if(iterator.call(context, obj[key], key, obj) === breaker)</div><div class="line">                    return;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这个函数的实现思想其实很简单，如果宿主环境（一般为浏览器或者node.js）支持原生的forEach方法，就调用原生的，否则就遍历该数组或者对象，依次调用处理器方法<br>值得一提的是在判断是否是数组的时候，这里的代码为</p>
<blockquote>
<p>obj.length === +obj.length</p>
</blockquote>
<p>这其实是一种鸭式辨型的判定方法，具体可以参见我在SF上提过的一个问题：<a href="http://segmentfault.com/q/1010000000510887" target="_blank" rel="external">点我</a></p>
<h2 id="map-collect"><a href="#map-collect" class="headerlink" title=".map / .collect"></a><em>.map / </em>.collect</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">_.map = _.collect = function(obj, iterator, context) &#123;</div><div class="line">    // 用于存放返回值的数组</div><div class="line">    var results = [];</div><div class="line">    if(obj == null)</div><div class="line">        return results;</div><div class="line">    // 优先调用宿主环境提供的map方法</div><div class="line">    if(nativeMap &amp;&amp; obj.map === nativeMap)</div><div class="line">        return obj.map(iterator, context);</div><div class="line">    // 迭代处理集合中的元素</div><div class="line">    each(obj, function(value, index, list) &#123;</div><div class="line">        // 将每次迭代处理的返回值存储到results数组</div><div class="line">        results[results.length] = iterator.call(context, value, index, list);</div><div class="line">    &#125;);</div><div class="line">    // 返回处理结果</div><div class="line">    if(obj.length === +obj.length)</div><div class="line">        results.length = obj.length;</div><div class="line">    return results;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>map/collect函数与each的区别在于map/collect会存储每次迭代的返回值, 并作为一个新的数组返回</p>
<h2 id="reduce-foldl-inject"><a href="#reduce-foldl-inject" class="headerlink" title=".reduce / .foldl / _.inject"></a><em>.reduce / </em>.foldl / _.inject</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">_.reduce = _.foldl = _.inject = function(obj, iterator, memo, context) &#123;</div><div class="line">    // 通过参数数量检查是否存在初始值</div><div class="line">    var initial = arguments.length &gt; 2;</div><div class="line">    if(obj == null)</div><div class="line">        obj = [];</div><div class="line">    // 优先调用宿主环境提供的reduce方法</div><div class="line">    if(nativeReduce &amp;&amp; obj.reduce === nativeReduce &amp;&amp; false) &#123;</div><div class="line">        if(context)</div><div class="line">            iterator = _.bind(iterator, context);</div><div class="line">        return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);</div><div class="line">    &#125;</div><div class="line">    // 迭代处理集合中的元素</div><div class="line">    each(obj, function(value, index, list) &#123;</div><div class="line">        if(!initial) &#123;</div><div class="line">            // 如果没有初始值, 则将第一个元素作为初始值; 如果被处理的是对象集合, 则默认值为第一个属性的值</div><div class="line">            memo = value;</div><div class="line">            initial = true;</div><div class="line">        &#125; else &#123;</div><div class="line">            // 记录处理结果, 并将结果传递给下一次迭代</div><div class="line">            memo = iterator.call(context, memo, value, index, list);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">    if(!initial)</div><div class="line">        throw new TypeError(&apos;Reduce of empty array with no initial value&apos;);</div><div class="line">    return memo;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这个函数的作用是将集合中每个元素放入迭代处理器, 并将本次迭代的返回值作为<em>memo</em>传递到下一次迭代, 一般用于累计结果或连接数据</p>
<h2 id="reduceRight-foldr"><a href="#reduceRight-foldr" class="headerlink" title=".reduceRight / .foldr"></a><em>.reduceRight / </em>.foldr</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">_.reduceRight = _.foldr = function(obj, iterator, memo, context) &#123;</div><div class="line">    var initial = arguments.length &gt; 2;</div><div class="line">    if(obj == null)</div><div class="line">        obj = [];</div><div class="line">    // 优先调用宿主环境提供的reduceRight方法</div><div class="line">    if(nativeReduceRight &amp;&amp; obj.reduceRight === nativeReduceRight) &#123;</div><div class="line">        if(context)</div><div class="line">            iterator = _.bind(iterator, context);</div><div class="line">        return initial ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);</div><div class="line">    &#125;</div><div class="line">    // 逆转集合中的元素顺序</div><div class="line">    var reversed = _.toArray(obj).reverse();</div><div class="line">    if(context &amp;&amp; !initial)</div><div class="line">        iterator = _.bind(iterator, context);</div><div class="line">    // 通过reduce方法处理数据</div><div class="line">    return initial ? _.reduce(reversed, iterator, memo, context) : _.reduce(reversed, iterator);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这个函数与reduce相似，不过它是逆向迭代集合中的元素</p>
<h2 id="find-detect"><a href="#find-detect" class="headerlink" title=".find / .detect"></a><em>.find / </em>.detect</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">_.find = _.detect = function(obj, iterator, context) &#123;</div><div class="line">    // result存放第一个能够通过验证的元素</div><div class="line">    var result;</div><div class="line">    // 通过any方法遍历数据, 并记录通过验证的元素</div><div class="line">    any(obj, function(value, index, list) &#123;</div><div class="line">        // 如果处理器返回的结果被转换为Boolean类型后值为true, 则记录当前值并返回当前元素</div><div class="line">        if(iterator.call(context, value, index, list)) &#123;</div><div class="line">            result = value;</div><div class="line">            return true;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">    return result;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这个方法的作用是遍历集合中的元素, 返回能够通过处理器验证的第一个元素</p>
<h2 id="filter-select"><a href="#filter-select" class="headerlink" title=".filter / .select"></a><em>.filter / </em>.select</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">_.filter = _.select = function(obj, iterator, context) &#123;</div><div class="line">    // 用于存储通过验证的元素数组</div><div class="line">    var results = [];</div><div class="line">    if(obj == null)</div><div class="line">        return results;</div><div class="line">    // 优先调用宿主环境提供的filter方法</div><div class="line">    if(nativeFilter &amp;&amp; obj.filter === nativeFilter)</div><div class="line">        return obj.filter(iterator, context);</div><div class="line">    // 迭代集合中的元素, 并将通过处理器验证的元素放到数组中并返回</div><div class="line">    each(obj, function(value, index, list) &#123;</div><div class="line">        if(iterator.call(context, value, index, list))</div><div class="line">            results[results.length] = value;</div><div class="line">    &#125;);</div><div class="line">    return results;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这个方法与find作用类似, 但它会记录下集合中所有通过验证的元素</p>
<h2 id="reject"><a href="#reject" class="headerlink" title="_.reject"></a>_.reject</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">_.reject = function(obj, iterator, context) &#123;</div><div class="line">    var results = [];</div><div class="line">    if(obj == null)</div><div class="line">        return results;</div><div class="line">    each(obj, function(value, index, list) &#123;</div><div class="line">        if(!iterator.call(context, value, index, list))</div><div class="line">            results[results.length] = value;</div><div class="line">    &#125;);</div><div class="line">    return results;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这个方法的代码里面我没有加注释，因为整个代码与filter/select方法几乎一样，不同点在于向results数组里添加元素的时候判断条件是相反的，也就是说这个方法的作用是返回没有通过处理器验证的元素列表</p>
<h2 id="every-all"><a href="#every-all" class="headerlink" title=".every / .all"></a><em>.every / </em>.all</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">_.every = _.all = function(obj, iterator, context) &#123;</div><div class="line">    var result = true;</div><div class="line">    if(obj == null)</div><div class="line">        return result;</div><div class="line">    // 优先调用宿主环境提供的every方法</div><div class="line">    if(nativeEvery &amp;&amp; obj.every === nativeEvery)</div><div class="line">        return obj.every(iterator, context);</div><div class="line">    // 迭代集合中的元素</div><div class="line">    each(obj, function(value, index, list) &#123;</div><div class="line">        // 这里我不太理解，为什么药写成 result = (result &amp;&amp; iterator.call(context, value, index, list)) 而不是 result = iterator.call(context, value, index, list)</div><div class="line">        if(!( result = result &amp;&amp; iterator.call(context, value, index, list)))</div><div class="line">            return breaker;</div><div class="line">    &#125;);</div><div class="line">    return !!result;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这个方法的作用是如果集合中所有元素均能通过处理器验证, 则返回true</p>
<h2 id="any-some-any"><a href="#any-some-any" class="headerlink" title="any / .some / .any"></a>any / <em>.some / </em>.any</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">var any = _.some = _.any = function(obj, iterator, context) &#123;</div><div class="line">    // 如果没有指定处理器参数, 则使用默认的处理器函数，该函数会返回参数本身</div><div class="line">    iterator || ( iterator = _.identity);</div><div class="line">    var result = false;</div><div class="line">    if(obj == null)</div><div class="line">        return result;</div><div class="line">    // 优先调用宿主环境提供的some方法</div><div class="line">    if(nativeSome &amp;&amp; obj.some === nativeSome)</div><div class="line">        return obj.some(iterator, context);</div><div class="line">    // 迭代集合中的元素</div><div class="line">    each(obj, function(value, index, list) &#123;</div><div class="line">        if(result || ( result = iterator.call(context, value, index, list)))</div><div class="line">            return breaker;</div><div class="line">    &#125;);</div><div class="line">    return !!result;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>该函数的作用是检查集合中是否有任何一个元素在被转换成Boolean类型时是否为true</p>
<h2 id="include-contains"><a href="#include-contains" class="headerlink" title=".include / .contains"></a><em>.include / </em>.contains</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">_.include = _.contains = function(obj, target) &#123;</div><div class="line">    var found = false;</div><div class="line">    if(obj == null)</div><div class="line">        return found;</div><div class="line">    // 优先调用宿主环境提供的Array.prototype.indexOf方法</div><div class="line">    if(nativeIndexOf &amp;&amp; obj.indexOf === nativeIndexOf)</div><div class="line">        return obj.indexOf(target) != -1;</div><div class="line">    // 通过any方法迭代集合中的元素, 验证元素的值和类型与目标是否完全匹配</div><div class="line">    found = any(obj, function(value) &#123;</div><div class="line">        return value === target;</div><div class="line">    &#125;);</div><div class="line">    return found;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这个函数用于检查集合中是否有值与目标参数完全匹配，包括数据类型</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>今天先介绍以上10个函数的实现细节，之后还会继续带来其他函数的介绍，欢迎大家提出指正和建议，thx for reading, hope u enjoy</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近十几天都在忙毕业论文的事，所以上一次为大家介绍完underscore这个框架的结构（或者说是这个框架的设计思路）之后就一直没动静了，今天我又满血复活了，让我们继续来探索underscore的源码奥秘吧。&lt;br&gt;没看过上一篇文章的朋友可以戳这里：&lt;a href=&quot;/201
    
    </summary>
    
      <category term="技术" scheme="http://joeray61.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="javascript" scheme="http://joeray61.com/tags/javascript/"/>
    
      <category term="underscore" scheme="http://joeray61.com/tags/underscore/"/>
    
      <category term="源码" scheme="http://joeray61.com/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Underscore源码解析（一）</title>
    <link href="http://joeray61.com/2014/05/21/Underscore%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://joeray61.com/2014/05/21/Underscore源码解析（一）/</id>
    <published>2014-05-21T10:38:16.000Z</published>
    <updated>2017-04-04T10:39:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近准备折腾一下<em>backbone.js</em>，在事先了解了<em>backbone</em>之后，我知道了<em>backbone</em>对<em>underscore</em>这个库有着强依赖，正好<em>underscore</em>之前也没使用过，于是我就想先把<em>underscore</em>彻底了解一下，这样之后折腾<em>backbone</em>的时候也少一点阻碍。<br>    <em>underscore</em>是一个很实用且小巧的框架，提供了很多我们在编程时需要的基本功能函数，而且他没有扩展<em>javascript</em>的原生对象，主要涉及对<em>Object</em>、<em>Array</em>、<em>Function</em>的操作。<br>    我曾经问我的朋友<a href="http://www.cnblogs.com/hustskyking/" target="_blank" rel="external">@小胡子哥</a> 怎么学习一个框架？他给我的回答是：“直接看源码。”现在想想深感同意，因为研究源码是最直接的学习途径，可以深入地了解这个框架的思想和精髓，同时也能学习框架作者的编程技巧，提升自己的coding水平。<br>    好了，题外话就说到这里，下面咱们进入正题。</p>
<h1 id="简化源码看结构"><a href="#简化源码看结构" class="headerlink" title="简化源码看结构"></a>简化源码看结构</h1><p>我这次看的<em>underscore</em>版本是1.3.3，整个文件也就1000多行，我把代码简化了一下，并加入了相关的注释：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div></pre></td><td class="code"><pre><div class="line">// underscore的代码包裹在一个匿名自执行函数中</div><div class="line">(function() &#123;</div><div class="line">    // 创建一个全局对象, 在浏览器中表示为window对象, 在Node.js中表示global对象</div><div class="line">     var root = this;</div><div class="line"> </div><div class="line">     // 保存&quot;_&quot;(下划线变量)被覆盖之前的值</div><div class="line">     // 如果出现命名冲突或考虑到规范, 可通过_.noConflict()方法恢复&quot;_&quot;被Underscore占用之前的值, 并返回Underscore对象以便重新命名</div><div class="line">     var previousUnderscore = root._;</div><div class="line"> </div><div class="line">     // 创建一个空的对象常量, 便于内部共享使用</div><div class="line">     var breaker = &#123;&#125;;</div><div class="line"> </div><div class="line">     // 将内置对象的原型链缓存在局部变量</div><div class="line">     var ArrayProto = Array.prototype, </div><div class="line">     ObjProto = Object.prototype, </div><div class="line">     FuncProto = Function.prototype;</div><div class="line"> </div><div class="line">     // 将内置对象原型中的常用方法缓存在局部变量</div><div class="line">     var slice = ArrayProto.slice, </div><div class="line">     unshift = ArrayProto.unshift, </div><div class="line">     toString = ObjProto.toString,</div><div class="line">     hasOwnProperty = ObjProto.hasOwnProperty;</div><div class="line"> </div><div class="line">     // 这里定义了一些JavaScript 1.6提供的新方法</div><div class="line">     // 如果宿主环境中支持这些方法则优先调用, 如果宿主环境中没有提供, 则会由Underscore实现</div><div class="line">     var nativeForEach = ArrayProto.forEach, </div><div class="line">     nativeMap = ArrayProto.map, </div><div class="line">     nativeReduce = ArrayProto.reduce, </div><div class="line">     nativeReduceRight = ArrayProto.reduceRight, </div><div class="line">     nativeFilter = ArrayProto.filter, </div><div class="line">     nativeEvery = ArrayProto.every, </div><div class="line">     nativeSome = ArrayProto.some, </div><div class="line">     nativeIndexOf = ArrayProto.indexOf, </div><div class="line">     nativeLastIndexOf = ArrayProto.lastIndexOf, </div><div class="line">     nativeIsArray = Array.isArray, </div><div class="line">     nativeKeys = Object.keys, </div><div class="line">     nativeBind = FuncProto.bind;</div><div class="line"> </div><div class="line">     // 创建对象式的调用方式, 将返回一个Underscore包装器, 包装器对象的原型中包含Underscore所有方法(类似与将DOM对象包装为一个jQuery对象)</div><div class="line">     var _ = function(obj) &#123;</div><div class="line">         // 所有Underscore对象在内部均通过wrapper对象进行构造</div><div class="line">         return new wrapper(obj);</div><div class="line">     &#125;;</div><div class="line"> </div><div class="line">     // 针对不同的宿主环境, 将Undersocre的命名变量存放到不同的对象中</div><div class="line">     if( typeof exports !== &apos;undefined&apos;) &#123;// Node.js环境</div><div class="line">         if( typeof module !== &apos;undefined&apos; &amp;&amp; module.exports) &#123;</div><div class="line">             exports = module.exports = _;</div><div class="line">         &#125;</div><div class="line">         exports._ = _;</div><div class="line">     &#125; else &#123;// 浏览器环境中Underscore的命名变量被挂在window对象中</div><div class="line">         root[&apos;_&apos;] = _;</div><div class="line">     &#125;</div><div class="line"> </div><div class="line">     // 版本声明</div><div class="line">     _.VERSION = &apos;1.3.3&apos;;</div><div class="line"></div><div class="line">    //在_对象上定义各种方法</div><div class="line">    . . . . . .</div><div class="line"> </div><div class="line">     // underscore对象的包装函数</div><div class="line">     var wrapper = function(obj) &#123;</div><div class="line">         // 原始数据存放在包装对象的_wrapped属性中</div><div class="line">         this._wrapped = obj;</div><div class="line">     &#125;;</div><div class="line"> </div><div class="line">     // 将Underscore的原型对象指向wrapper的原型, 因此通过像wrapper原型中添加方法, Underscore对象也会具备同样的方法</div><div class="line">     _.prototype = wrapper.prototype;</div><div class="line"> </div><div class="line">     // 返回一个对象, 如果当前Underscore调用了chain()方法(即_chain属性为true), 则返回一个被包装的Underscore对象, 否则返回对象本身</div><div class="line">    // result函数用于在构造方法链时返回Underscore的包装对象</div><div class="line">     var result = function(obj, chain) &#123;</div><div class="line">         return chain ? _(obj).chain() : obj;</div><div class="line">     &#125;;</div><div class="line"> </div><div class="line">     // 将一个自定义方法添加到Underscore对象中(实际是添加到wrapper的原型中, 而Underscore对象的原型指向了wrapper的原型)</div><div class="line">     var addToWrapper = function(name, func) &#123;</div><div class="line">         // 向wrapper原型中添加一个name函数, 该函数调用func函数, 并支持了方法链的处理</div><div class="line">         wrapper.prototype[name] = function() &#123;</div><div class="line">             // 获取func函数的参数, 并将当前的原始数据添加到第一个参数</div><div class="line">             var args = slice.call(arguments);</div><div class="line">             unshift.call(args, this._wrapped);</div><div class="line">             // 执行函数并返回结果, 并通过result函数对方法链进行封装, 如果当前调用了chain()方法, 则返回封装后的Underscore对象, 否则返回对象本身</div><div class="line">             return result(func.apply(_, args), this._chain);</div><div class="line">         &#125;;</div><div class="line">     &#125;;</div><div class="line"> </div><div class="line">     // 将内部定义的_(即Underscore方法集合对象)中的方法复制到wrapper的原型链中(即Underscore的原型链中)</div><div class="line">     // 这是为了在构造对象式调用的Underscore对象时, 这些对象也会具有内部定义的Underscore方法</div><div class="line">     _.mixin(_);</div><div class="line"> </div><div class="line">     // 将Array.prototype中的相关方法添加到Underscore对象中, 因此在封装后的Underscore对象中也可以直接调用Array.prototype中的方法</div><div class="line">     // 如: _([]).push()</div><div class="line">     each([&apos;pop&apos;, &apos;push&apos;, &apos;reverse&apos;, &apos;shift&apos;, &apos;sort&apos;, &apos;splice&apos;, &apos;unshift&apos;], function(name) &#123;</div><div class="line">         // 获取Array.prototype中对应方法的引用</div><div class="line">         var method = ArrayProto[name];</div><div class="line">         // 将该方法添加到Underscore对象中(实际是添加到wrapper的原型对象, 因此在创建Underscore对象时同时具备了该方法)</div><div class="line">         wrapper.prototype[name] = function() &#123;</div><div class="line">             // _wrapped变量中存储Underscore对象的原始值</div><div class="line">             var wrapped = this._wrapped;</div><div class="line">            // 调用Array对应的方法并返回结果</div><div class="line">             method.apply(wrapped, arguments);</div><div class="line">             var length = wrapped.length;</div><div class="line">             if((name == &apos;shift&apos; || name == &apos;splice&apos;) &amp;&amp; length === 0)</div><div class="line">                 delete wrapped[0];</div><div class="line">             // 即使是对于Array中的方法, Underscore同样支持方法链操作</div><div class="line">             return result(wrapped, this._chain);</div><div class="line">         &#125;;</div><div class="line">     &#125;);</div><div class="line"> </div><div class="line">     // 作用同于上一段代码, 将数组中的一些方法添加到Underscore对象, 并支持了方法链操作</div><div class="line">     // 区别在于上一段代码所添加的函数, 均返回Array对象本身(也可能是封装后的Array), concat, join, slice方法将返回一个新的Array对象(也可能是封装后的Array)</div><div class="line">     each([&apos;concat&apos;, &apos;join&apos;, &apos;slice&apos;], function(name) &#123;</div><div class="line">         var method = ArrayProto[name];</div><div class="line">         wrapper.prototype[name] = function() &#123;</div><div class="line">             return result(method.apply(this._wrapped, arguments), this._chain);</div><div class="line">         &#125;;</div><div class="line">     &#125;);</div><div class="line"> </div><div class="line">     // 对Underscore对象进行链式操作的声明方法</div><div class="line">     wrapper.prototype.chain = function() &#123;</div><div class="line">         // this._chain用来标示当前对象是否使用链式操作</div><div class="line">         // 对于支持方法链操作的数据, 一般在具体方法中会返回一个Underscore对象, 并将原始值存放在_wrapped属性中, 也可以通过value()方法获取原始值</div><div class="line">         this._chain = true;</div><div class="line">         return this;</div><div class="line">     &#125;;</div><div class="line"> </div><div class="line">     // 返回被封装的Underscore对象的原始值(存放在_wrapped属性中)</div><div class="line">     wrapper.prototype.value = function() &#123;</div><div class="line">         return this._wrapped;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">&#125;).call(this);</div></pre></td></tr></table></figure>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p><em>underscore</em>这个库的结构（或者说思路）大致是这样的：<br>        创建一个包装器, 将一些原始数据进行包装，所有的<em>undersocre</em>对象, 内部均通过<em>wrapper</em>函数进行构造和封装<br>        <em>underscore</em>与<em>wrapper</em>的内部关系是:</p>
<pre><code>        - 内部定义变量*_*, 将*underscore*相关的方法添加到*_*, 这样就可以支持函数式的调用, 如*_.bind()*
        - 内部定义*wrapper*类, 将*_*的原型对象指向*wrapper*类的原型
        - 将*underscore*相关的方法添加到*wrapper*原型, 创建的*_*对象就具备了*underscore*的方法
        - 将*Array*.*prototype*相关方法添加到*wrapper*原型, 创建的*_*对象就具备了*Array.prototype*中的方法
        - *new _()*时实际创建并返回了一个*wrapper()*对象, 并将原始数组存储到*_wrapped*变量, 并将原始值作为第一个参数调用对应方法

之后我会对underscore中所有方法的具体实现进行介绍，感谢关注 
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近准备折腾一下&lt;em&gt;backbone.js&lt;/em&gt;，在事先了解了&lt;em&gt;backbone&lt;/em&gt;之后，我知道了&lt;em&gt;backbone&lt;/em&gt;对&lt;em&gt;underscore&lt;/em&gt;这个库有着强依赖，正好&lt;em&gt;underscore&lt;/em&gt;之前也没使用过，于是我
    
    </summary>
    
      <category term="技术" scheme="http://joeray61.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="javascript" scheme="http://joeray61.com/tags/javascript/"/>
    
      <category term="underscore" scheme="http://joeray61.com/tags/underscore/"/>
    
      <category term="源码" scheme="http://joeray61.com/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
</feed>
