<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>JoeRay61</title>
  <subtitle>make things make sense</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://joeray61.com/"/>
  <updated>2017-04-03T15:48:06.000Z</updated>
  <id>http://joeray61.com/</id>
  
  <author>
    <name>JoeRay61</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Vue原理解析之observer模块</title>
    <link href="http://joeray61.com/2017/02/16/Vue%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90%E4%B9%8Bobserver%E6%A8%A1%E5%9D%97/"/>
    <id>http://joeray61.com/2017/02/16/Vue原理解析之observer模块/</id>
    <published>2017-02-16T15:26:10.000Z</published>
    <updated>2017-04-03T15:48:06.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>本文是针对<code>Vue@2.1.8</code>进行分析</p>
</blockquote>
<p><code>observer</code>是Vue核心中最重要的一个模块（个人认为），能够实现视图与数据的响应式更新，底层全凭<code>observer</code>的支持。</p>
<p><code>observer</code>模块在Vue项目中的代码位置是<code>src/core/observer</code>，模块共分为这几个部分：</p>
<ul>
<li><code>Observer</code>: 数据的观察者，让数据对象的读写操作都处于自己的监管之下</li>
<li><code>Watcher</code>: 数据的订阅者，数据的变化会通知到<code>Watcher</code>，然后由<code>Watcher</code>进行相应的操作，例如更新视图</li>
<li><code>Dep</code>: <code>Observer</code>与<code>Watcher</code>的纽带，当数据变化时，会被<code>Observer</code>观察到，然后由<code>Dep</code>通知到<code>Watcher</code></li>
</ul>
<p>示意图如下：</p>
<img src="/2017/02/16/Vue原理解析之observer模块/flow.png" alt="flow.png" title="">
<h2 id="Observer"><a href="#Observer" class="headerlink" title="Observer"></a>Observer</h2><p><code>Observer</code>类定义在<code>src/core/observer/index.js</code>中，先来看一下<code>Observer</code>的构造函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">constructor (value: any) &#123;</div><div class="line">  this.value = value</div><div class="line">  this.dep = new Dep()</div><div class="line">  this.vmCount = 0</div><div class="line">  def(value, &apos;__ob__&apos;, this)</div><div class="line">  if (Array.isArray(value)) &#123;</div><div class="line">      const augment = hasProto</div><div class="line">      ? protoAugment</div><div class="line">      : copyAugment</div><div class="line">    augment(value, arrayMethods, arrayKeys)</div><div class="line">    this.observeArray(value)</div><div class="line">  &#125; else &#123;</div><div class="line">    this.walk(value)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>value</code>是需要被观察的数据对象，在构造函数中，会给<code>value</code>增加<code>__ob__</code>属性，作为数据已经被<code>Observer</code>观察的标志。如果<code>value</code>是数组，就使用<code>observeArray</code>遍历<code>value</code>，对<code>value</code>中每一个元素调用<code>observe</code>分别进行观察。如果<code>value</code>是对象，则使用<code>walk</code>遍历<code>value</code>上每个key，对每个key调用<code>defineReactive</code>来获得该key的<code>set/get</code>控制权。</p>
<p>解释下上面用到的几个函数的功能：</p>
<ul>
<li><code>observeArray</code>: 遍历数组，对数组的每个元素调用<code>observe</code></li>
<li><code>observe</code>: 检查对象上是否有<code>__ob__</code>属性，如果存在，则表明该对象已经处于<code>Observer</code>的观察中，如果不存在，则<code>new Observer</code>来观察对象（其实还有一些判断逻辑，为了便于理解就不赘述了）</li>
<li><code>walk</code>: 遍历对象的每个key，对对象上每个key的数据调用<code>defineReactive</code></li>
<li><code>defineReactive</code>: 通过<code>Object.defineProperty</code>设置对象的key属性，使得能够捕获到该属性值的<code>set/get</code>动作。一般是由<code>Watcher</code>的实例对象进行<code>get</code>操作，此时<code>Watcher</code>的实例对象将被自动添加到<code>Dep</code>实例的依赖数组中，在外部操作触发了<code>set</code>时，将通过<code>Dep</code>实例的<code>notify</code>来通知所有依赖的<code>watcher</code>进行更新。</li>
</ul>
<p>如果不太理解上面的文字描述可以看一下图：</p>
<img src="/2017/02/16/Vue原理解析之observer模块/flow2.png" alt="flow2.png" title="">
<h2 id="Dep"><a href="#Dep" class="headerlink" title="Dep"></a>Dep</h2><p><code>Dep</code>是<code>Observer</code>与<code>Watcher</code>之间的纽带，也可以认为<code>Dep</code>是服务于<code>Observer</code>的订阅系统。<code>Watcher</code>订阅某个<code>Observer</code>的<code>Dep</code>，当<code>Observer</code>观察的数据发生变化时，通过<code>Dep</code>通知各个已经订阅的<code>Watcher</code>。</p>
<p><code>Dep</code>提供了几个接口：</p>
<ul>
<li><code>addSub</code>: 接收的参数为<code>Watcher</code>实例，并把<code>Watcher</code>实例存入记录依赖的数组中</li>
<li><code>removeSub</code>: 与<code>addSub</code>对应，作用是将<code>Watcher</code>实例从记录依赖的数组中移除</li>
<li><code>depend</code>: <code>Dep.target</code>上存放这当前需要操作的<code>Watcher</code>实例，调用<code>depend</code>会调用该<code>Watcher</code>实例的<code>addDep</code>方法，<code>addDep</code>的功能可以看下面对<code>Watcher</code>的介绍</li>
<li><code>notify</code>: 通知依赖数组中所有的<code>watcher</code>进行更新操作</li>
</ul>
<h2 id="Watcher"><a href="#Watcher" class="headerlink" title="Watcher"></a>Watcher</h2><p><code>Watcher</code>是用来订阅数据的变化的并执行相应操作（例如更新视图）的。<code>Watcher</code>的构造器函数定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">constructor (vm, expOrFn, cb, options) &#123;</div><div class="line">  this.vm = vm</div><div class="line">  vm._watchers.push(this)</div><div class="line">  // options</div><div class="line">  if (options) &#123;</div><div class="line">    this.deep = !!options.deep</div><div class="line">    this.user = !!options.user</div><div class="line">    this.lazy = !!options.lazy</div><div class="line">    this.sync = !!options.sync</div><div class="line">  &#125; else &#123;</div><div class="line">    this.deep = this.user = this.lazy = this.sync = false</div><div class="line">  &#125;</div><div class="line">  this.cb = cb</div><div class="line">  this.id = ++uid // uid for batching</div><div class="line">  this.active = true</div><div class="line">  this.dirty = this.lazy // for lazy watchers</div><div class="line">  this.deps = []</div><div class="line">  this.newDeps = []</div><div class="line">  this.depIds = new Set()</div><div class="line">  this.newDepIds = new Set()</div><div class="line">  this.expression = process.env.NODE_ENV !== &apos;production&apos;</div><div class="line">    ? expOrFn.toString()</div><div class="line">    : &apos;&apos;</div><div class="line">  if (typeof expOrFn === &apos;function&apos;) &#123;</div><div class="line">    this.getter = expOrFn</div><div class="line">  &#125; else &#123;</div><div class="line">    this.getter = parsePath(expOrFn)</div><div class="line">    if (!this.getter) &#123;</div><div class="line">      this.getter = function () &#123;&#125;</div><div class="line">      process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; warn(</div><div class="line">        `Failed watching path: &quot;$&#123;expOrFn&#125;&quot; ` +</div><div class="line">        &apos;Watcher only accepts simple dot-delimited paths. &apos; +</div><div class="line">        &apos;For full control, use a function instead.&apos;,</div><div class="line">        vm</div><div class="line">      )</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  this.value = this.lazy</div><div class="line">    ? undefined</div><div class="line">    : this.get()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>参数中，<code>vm</code>表示组件实例，<code>expOrFn</code>表示要订阅的数据字段（字符串表示，例如<code>a.b.c</code>）或是一个要执行的函数，<code>cb</code>表示watcher运行后的回调函数，<code>options</code>是选项对象，包含<code>deep</code>、<code>user</code>、<code>lazy</code>等配置。</p>
<p><code>watcher</code>实例上有这些方法：</p>
<ul>
<li><code>get</code>: 将<code>Dep.target</code>设置为当前<code>watcher</code>实例，在内部调用<code>this.getter</code>，如果此时某个被<code>Observer</code>观察的数据对象被取值了，那么当前<code>watcher</code>实例将会自动订阅数据对象的<code>Dep</code>实例</li>
<li><code>addDep</code>: 接收参数<code>dep</code>(Dep实例)，让当前<code>watcher</code>订阅<code>dep</code></li>
<li><code>cleanupDeps</code>: 清除<code>newDepIds</code>和<code>newDep</code>上记录的对dep的订阅信息</li>
<li><code>update</code>: 立刻运行<code>watcher</code>或者将<code>watcher</code>加入队列中等待统一flush</li>
<li><code>run</code>: 运行<code>watcher</code>，调用<code>this.get()</code>求值，然后触发回调</li>
<li><code>evaluate</code>: 调用<code>this.get()</code>求值</li>
<li><code>depend</code>: 遍历<code>this.deps</code>，让当前<code>watcher</code>实例订阅所有<code>dep</code></li>
<li><code>teardown</code>: 去除当前<code>watcher</code>实例所有的订阅</li>
</ul>
<h2 id="Array-methods"><a href="#Array-methods" class="headerlink" title="Array methods"></a>Array methods</h2><p>在<code>src/core/observer/array.js</code>中，Vue框架对数组的<code>push</code>、<code>pop</code>、<code>shift</code>、<code>unshift</code>、<code>sort</code>、<code>splice</code>、<code>reverse</code>方法进行了改造，在调用数组的这些方法时，自动触发<code>dep.notify()</code>，解决了调用这些函数改变数组后无法触发更新的问题。在Vue的官方文档中对这个也有说明：<a href="http://cn.vuejs.org/v2/guide/list.html#变异方法" target="_blank" rel="external">http://cn.vuejs.org/v2/guide/list.html#变异方法</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文是针对&lt;code&gt;Vue@2.1.8&lt;/code&gt;进行分析&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;observer&lt;/code&gt;是Vue核心中最重要的一个模块（个人认为），能够实现视图与数据的响应式更新，底层全凭&lt;code&gt;ob
    
    </summary>
    
      <category term="技术" scheme="http://joeray61.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Vue" scheme="http://joeray61.com/categories/%E6%8A%80%E6%9C%AF/Vue/"/>
    
    
      <category term="vue.js" scheme="http://joeray61.com/tags/vue-js/"/>
    
  </entry>
  
</feed>
