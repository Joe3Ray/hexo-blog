<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="javascript,underscore,源码," />





  <link rel="alternate" href="/atom.xml" title="JoeRay61" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="我在这个系列的第一篇文章说过，我学underscore是为了在学backbone的时候少一些阻碍，从第一篇的写作时间到今天，大概也有个十几二十天，感觉拖得有点久，所以今天将会是underscore源码解析系列的最后一篇文章，我会在这篇文章中介绍underscore剩下的所有函数。先附上前三篇文章的地址：Underscore源码解析（一）、Underscore源码解析（二）、Underscore源码">
<meta property="og:type" content="article">
<meta property="og:title" content="Underscore源码解析（四）">
<meta property="og:url" content="http://joeray61.com/2014/06/07/Underscore源码解析（四）/index.html">
<meta property="og:site_name" content="JoeRay61">
<meta property="og:description" content="我在这个系列的第一篇文章说过，我学underscore是为了在学backbone的时候少一些阻碍，从第一篇的写作时间到今天，大概也有个十几二十天，感觉拖得有点久，所以今天将会是underscore源码解析系列的最后一篇文章，我会在这篇文章中介绍underscore剩下的所有函数。先附上前三篇文章的地址：Underscore源码解析（一）、Underscore源码解析（二）、Underscore源码">
<meta property="og:updated_time" content="2017-04-04T10:43:34.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Underscore源码解析（四）">
<meta name="twitter:description" content="我在这个系列的第一篇文章说过，我学underscore是为了在学backbone的时候少一些阻碍，从第一篇的写作时间到今天，大概也有个十几二十天，感觉拖得有点久，所以今天将会是underscore源码解析系列的最后一篇文章，我会在这篇文章中介绍underscore剩下的所有函数。先附上前三篇文章的地址：Underscore源码解析（一）、Underscore源码解析（二）、Underscore源码">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://joeray61.com/2014/06/07/Underscore源码解析（四）/"/>





  <title> Underscore源码解析（四） | JoeRay61 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?10bd0d22c09384f2eae659f4ed1d4c57";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>










  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">JoeRay61</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">make things make sense</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://joeray61.com/2014/06/07/Underscore源码解析（四）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JoeRay61">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/joeray61.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JoeRay61">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                Underscore源码解析（四）
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2014-06-07T18:24:24+08:00">
                2014-06-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2014/06/07/Underscore源码解析（四）/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2014/06/07/Underscore源码解析（四）/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>我在这个系列的第一篇文章说过，我学underscore是为了在学backbone的时候少一些阻碍，从第一篇的写作时间到今天，大概也有个十几二十天，感觉拖得有点久，所以今天将会是underscore源码解析系列的最后一篇文章，我会在这篇文章中介绍underscore剩下的所有函数。<br>先附上前三篇文章的地址：<a href="/2014/05/21/Underscore源码解析（一）/">Underscore源码解析（一）</a>、<a href="/2014/06/03/Underscore源码解析（二）/">Underscore源码解析（二）</a>、<a href="/2014/06/06/Underscore源码解析（三）/">Underscore源码解析（三）</a></p>
<h2 id="zip"><a href="#zip" class="headerlink" title="_.zip"></a>_.zip</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">_.zip = function() &#123;</div><div class="line">    // 将参数转换为数组, 此时args是一个二维数组</div><div class="line">    var args = slice.call(arguments);</div><div class="line">    // 计算每一个数组的长度, 并返回其中最大长度值</div><div class="line">    var length = _.max(_.pluck(args, &apos;length&apos;));</div><div class="line">    // 依照最大长度值创建一个新的空数组, 该数组用于存储处理结果</div><div class="line">    var results = new Array(length);</div><div class="line">    // 循环最大长度, 在每次循环将调用pluck方法获取每个数组中相同位置的数据(依次从0到最后位置)</div><div class="line">    // 将获取到的数据存储在一个新的数组, 放入results并返回</div><div class="line">    for(var i = 0; i &lt; length; i++)</div><div class="line">    results[i] = _.pluck(args, &quot;&quot; + i);</div><div class="line">    // 返回的结果是一个二维数组</div><div class="line">    return results;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这个函数将每个数组的相同位置的数据作为一个新的二维数组返回, 返回的数组长度以传入参数中最大的数组长度为准, 其它数组的空白位置使用undefined填充。zip函数应该包含多个参数, 且每个参数应该均为数组。</p>
<h2 id="indexOf"><a href="#indexOf" class="headerlink" title="_.indexOf"></a>_.indexOf</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">_.indexOf = function(array, item, isSorted) &#123;</div><div class="line">    if(array == null)</div><div class="line">        return -1;</div><div class="line">    var i, l;</div><div class="line">    // 若数组已经经过排序，则调用sortedIndex方法，获取元素插入数组中所处位置的索引号</div><div class="line">    if(isSorted) &#123;</div><div class="line">        i = _.sortedIndex(array, item);</div><div class="line">        return array[i] === item ? i : -1;</div><div class="line">    &#125;</div><div class="line">    // 优先调用宿主环境提供的indexOf方法</div><div class="line">    if(nativeIndexOf &amp;&amp; array.indexOf === nativeIndexOf)</div><div class="line">        return array.indexOf(item);</div><div class="line">    // 循环并返回元素首次出现的位置</div><div class="line">    for( i = 0, l = array.length; i &lt; l; i++)</div><div class="line">    if( i in array &amp;&amp; array[i] === item)</div><div class="line">        return i;</div><div class="line">    // 没有找到元素, 返回-1</div><div class="line">    return -1;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这个函数的作用是搜索一个元素在数组中首次出现的位置, 如果元素不存在则返回 -1，搜索时使用 === 对元素进行匹配</p>
<h2 id="lastIndexOf"><a href="#lastIndexOf" class="headerlink" title="_.lastIndexOf"></a>_.lastIndexOf</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">_.lastIndexOf = function(array, item) &#123;</div><div class="line">    if(array == null)</div><div class="line">        return -1;</div><div class="line">    // 优先调用宿主环境提供的lastIndexOf方法</div><div class="line">    if(nativeLastIndexOf &amp;&amp; array.lastIndexOf === nativeLastIndexOf)</div><div class="line">        return array.lastIndexOf(item);</div><div class="line">    var i = array.length;</div><div class="line">    // 循环并返回元素最后出现的位置</div><div class="line">    while(i--)</div><div class="line">    if( i in array &amp;&amp; array[i] === item)</div><div class="line">        return i;</div><div class="line">    // 没有找到元素, 返回-1</div><div class="line">    return -1;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这个函数返回一个元素在数组中最后一次出现的位置, 如果元素不存在则返回 -1，搜索时使用 === 对元素进行匹配</p>
<h2 id="range"><a href="#range" class="headerlink" title="_.range"></a>_.range</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">_.range = function(start, stop, step) &#123;</div><div class="line">    // 参数控制</div><div class="line">    if(arguments.length &lt;= 1) &#123;</div><div class="line">        // 如果没有参数, 则start = 0, stop = 0, 在循环中不会生成任何数据, 将返回一个空数组</div><div class="line">        // 如果有1个参数, 则参数指定给stop, start = 0</div><div class="line">        stop = start || 0;</div><div class="line">        start = 0;</div><div class="line">    &#125;</div><div class="line">    // 生成整数的步长值, 默认为1</div><div class="line">    step = arguments[2] || 1;</div><div class="line"></div><div class="line">    // 根据区间和步长计算将生成的最大值</div><div class="line">    var len = Math.max(Math.ceil((stop - start) / step), 0);</div><div class="line">    var idx = 0;</div><div class="line">    var range = new Array(len);</div><div class="line"></div><div class="line">    // 生成整数列表, 并存储到range数组</div><div class="line">    while(idx &lt; len) &#123;</div><div class="line">        range[idx++] = start;</div><div class="line">        start += step;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 返回列表结果</div><div class="line">    return range;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这个函数根据区间和步长, 生成一系列整数, 并作为数组返回，start参数表示最小数，stop参数表示最大数，step参数表示步长</p>
<h2 id="bind"><a href="#bind" class="headerlink" title="_.bind"></a>_.bind</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">_.bind = function bind(func, context) &#123;</div><div class="line">    var bound, args;</div><div class="line">    // 优先调用宿主环境提供的bind方法</div><div class="line">    if(func.bind === nativeBind &amp;&amp; nativeBind)</div><div class="line">        return nativeBind.apply(func, slice.call(arguments, 1));</div><div class="line">    // func参数必须是一个函数(Function)类型</div><div class="line">    if(!_.isFunction(func))</div><div class="line">        throw new TypeError;</div><div class="line">    // args变量存储了bind方法第三个开始的参数列表, 每次调用时都将传递给func函数</div><div class="line">    args = slice.call(arguments, 2);</div><div class="line">    return bound = function() &#123;</div><div class="line">        if(!(this instanceof bound))</div><div class="line">            return func.apply(context, args.concat(slice.call(arguments)));</div><div class="line">        ctor.prototype = func.prototype;</div><div class="line">        var self = new ctor;</div><div class="line">        var result = func.apply(self, args.concat(slice.call(arguments)));</div><div class="line">        if(Object(result) === result)</div><div class="line">            return result;</div><div class="line">        return self;</div><div class="line">    &#125;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这个函数为一个函数绑定执行上下文, 任何情况下调用该函数, 函数中的this均指向context对象，绑定函数时, 可以同时给函数传递调用形参</p>
<h2 id="bindAll"><a href="#bindAll" class="headerlink" title="_.bindAll"></a>_.bindAll</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">_.bindAll = function(obj) &#123;</div><div class="line">    // 第二个参数开始表示需要绑定的函数名称</div><div class="line">    var funcs = slice.call(arguments, 1);</div><div class="line">    // 如果没有指定特定的函数名称, 则默认绑定对象本身所有类型为Function的属性</div><div class="line">    if(funcs.length == 0)</div><div class="line">        funcs = _.functions(obj);</div><div class="line">    // 循环并将所有的函数上下本设置为obj对象本身</div><div class="line">    // each方法本身不会遍历对象原型链中的方法, 但此处的funcs列表是通过_.functions方法获取的, 它已经包含了原型链中的方法</div><div class="line">    each(funcs, function(f) &#123;</div><div class="line">        obj[f] = _.bind(obj[f], obj);</div><div class="line">    &#125;);</div><div class="line">    return obj;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这个函数将指定的函数, 或对象本身的所有函数上下本绑定到对象本身, 被绑定的函数在被调用时, 上下文对象始终指向对象本身</p>
<h2 id="memoize"><a href="#memoize" class="headerlink" title="_.memoize"></a>_.memoize</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">_.memoize = function(func, hasher) &#123;</div><div class="line">    // 用于存储缓存结果的memo对象</div><div class="line">    var memo = &#123;&#125;;</div><div class="line">    // hasher参数应该是一个function, 它用于返回一个key, 该key作为读取缓存的标识</div><div class="line">    // 如果没有指定key, 则默认使用函数的第一个参数作为key, 如果函数的第一个参数是复合数据类型, 可能会返回类似[Object object]的key, 这个key可能会造成后续计算的数据不正确</div><div class="line">    hasher || ( hasher = _.identity);</div><div class="line">    // 返回一个函数, 该函数首先通过检查缓存, 再对没有缓存过的数据进行调用</div><div class="line">    return function() &#123;</div><div class="line">        var key = hasher.apply(this, arguments);</div><div class="line">        return _.has(memo, key) ? memo[key] : (memo[key] = func.apply(this, arguments));</div><div class="line">    &#125;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这个函数将返回一个函数, 该函数集成了缓存功能, 将经过计算的值缓存到局部变量并在下次调用时直接返回</p>
<h2 id="delay"><a href="#delay" class="headerlink" title="_.delay"></a>_.delay</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">_.delay = function(func, wait) &#123;</div><div class="line">    var args = slice.call(arguments, 2);</div><div class="line">    // 通过setTimeout来延时执行</div><div class="line">    return setTimeout(function() &#123;</div><div class="line">        return func.apply(null, args);</div><div class="line">    &#125;, wait);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这个函数的作用是延时执行一个函数，wait单位为ms, 第3个参数开始将被依次传递给执行函数</p>
<h2 id="defer"><a href="#defer" class="headerlink" title="_.defer"></a>_.defer</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">_.defer = function(func) &#123;</div><div class="line">    // 相当于_.delay(func, 1, [arguments]);</div><div class="line">    return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这个函数的作用是延迟1ms执行函数，javascript是一个单线程的程序，setTimeout(func, time)作用是把func放到处理任务的队列末尾，在其他任务都完成之后的time ms 后执行func</p>
<h2 id="throttle"><a href="#throttle" class="headerlink" title="_.throttle"></a>_.throttle</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">_.throttle = function(func, wait) &#123;</div><div class="line">    var context, args, timeout, throttling, more, result;</div><div class="line">    // whenDone变量调用了debounce方法, 因此在多次连续调用函数时, 最后一次调用会覆盖之前调用的定时器, 清除状态函数也仅会被执行一次</div><div class="line">    // whenDone函数在最后一次函数执行的时间间隔截止时调用, 清除节流和调用过程中记录的一些状态</div><div class="line">    var whenDone = _.debounce(function() &#123;</div><div class="line">        more = throttling = false;</div><div class="line">    &#125;, wait);</div><div class="line">    // 返回一个函数, 并在函数内进行节流控制</div><div class="line">    return function() &#123;</div><div class="line">        // 保存函数的执行上下文和参数</div><div class="line">        context = this;</div><div class="line">        args = arguments;</div><div class="line">        // later函数在上一次函数调用时间间隔截止时执行</div><div class="line">        var later = function() &#123;</div><div class="line">            // 清除timeout句柄, 方便下一次函数调用</div><div class="line">            timeout = null;</div><div class="line">            // more记录了在上一次调用至时间间隔截止之间, 是否重复调用了函数</div><div class="line">            // 如果重复调用了函数, 在时间间隔截止时将自动再次调用函数</div><div class="line">            if(more)</div><div class="line">                func.apply(context, args);</div><div class="line">            // 调用whenDone, 用于在时间间隔后清除节流状态</div><div class="line">            whenDone();</div><div class="line">        &#125;;</div><div class="line">        // timeout记录了上一次函数执行的时间间隔句柄</div><div class="line">        // timeout时间间隔截止时调用later函数, later中将清除timeout, 并检查是否需要再次调用函数</div><div class="line">        if(!timeout)</div><div class="line">            timeout = setTimeout(later, wait);</div><div class="line">        // throttling变量记录上次调用的时间间隔是否已经结束, 即是否处于节流过程中</div><div class="line">        // throttling在每次函数调用时设为true, 表示需要进行节流, 在时间间隔截止时设置为false(在whenDone函数中实现)</div><div class="line">        if(throttling) &#123;</div><div class="line">            // 节流过程中进行了多次调用, 在more中记录一个状态, 表示在时间间隔截止时需要再次自动调用函数</div><div class="line">            more = true;</div><div class="line">        &#125; else &#123;</div><div class="line">            // 没有处于节流过程, 可能是第一次调用函数, 或已经超过上一次调用的间隔, 可以直接调用函数</div><div class="line">            result = func.apply(context, args);</div><div class="line">        &#125;</div><div class="line">        // 调用whenDone, 用于在时间间隔后清除节流状态</div><div class="line">        whenDone();</div><div class="line">        // throttling变量记录函数调用时的节流状态</div><div class="line">        throttling = true;</div><div class="line">        // 返回调用结果</div><div class="line">        return result;</div><div class="line">    &#125;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这是函数节流方法, throttle方法主要用于控制函数的执行频率, 在被控制的时间间隔内, 频繁调用函数不会被多次执行，在时间间隔内如果多次调用了函数, 时间隔截止时会自动调用一次, 不需要等到时间截止后再手动调用(自动调用时不会有返回值)，throttle函数一般用于处理复杂和调用频繁的函数, 通过节流控制函数的调用频率, 节省处理资源</p>
<h2 id="debounce"><a href="#debounce" class="headerlink" title="_.debounce"></a>_.debounce</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">_.debounce = function(func, wait, immediate) &#123;</div><div class="line">    // timeout用于记录函数上一次调用的执行状态(定时器句柄)</div><div class="line">    // 当timeout为null时, 表示上一次调用已经结束</div><div class="line">    var timeout;</div><div class="line">    // 返回一个函数, 并在函数内进行节流控制</div><div class="line">    return function() &#123;</div><div class="line">        // 保持函数的上下文对象和参数</div><div class="line">        var context = this, args = arguments;</div><div class="line">        var later = function() &#123;</div><div class="line">            // 设置timeout为null</div><div class="line">            // later函数会在允许的时间截止时被调用</div><div class="line">            // 调用该函数时, 表明上一次函数执行时间已经超过了约定的时间间隔, 此时之后再进行调用都是被允许的</div><div class="line">            timeout = null;</div><div class="line">            if(!immediate)</div><div class="line">                func.apply(context, args);</div><div class="line">        &#125;;</div><div class="line">        // 如果函数被设定为立即执行, 且上一次调用的时间间隔已经过去, 则立即调用函数</div><div class="line">        if(immediate &amp;&amp; !timeout)</div><div class="line">            func.apply(context, args);</div><div class="line">        // 创建一个定时器用于检查和设置函数的调用状态</div><div class="line">        // 创建定时器之前先清空上一次setTimeout句柄, 无论上一次绑定的函数是否已经被执行</div><div class="line">        // 如果本次函数在调用时, 上一次函数执行还没有开始(一般是immediate设置为false时), 则函数的执行时间会被推迟, 因此timeout句柄会被重新创建</div><div class="line">        clearTimeout(timeout);</div><div class="line">        // 在允许的时间截止时调用later函数</div><div class="line">        timeout = setTimeout(later, wait);</div><div class="line">    &#125;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>debounce与throttle方法类似, 用于函数节流, 它们的不同之处在于:<br>    – throttle关注函数的执行频率, 在指定频率内函数只会被执行一次<br>    – debounce函数更关注函数执行的间隔, 即函数两次的调用时间不能小于指定时间<br>如果两次函数的执行间隔小于wait, 定时器会被清除并重新创建, 这意味着连续频繁地调用函数, 函数一直不会被执行, 直到某一次调用与上一次调用的时间不小于wait毫秒</p>
<h2 id="once"><a href="#once" class="headerlink" title="_.once"></a>_.once</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">_.once = function(func) &#123;</div><div class="line">    // ran记录函数是否被执行过</div><div class="line">    // memo记录函数最后一次执行的结果</div><div class="line">    var ran = false, memo;</div><div class="line">    return function() &#123;</div><div class="line">        // 如果函数已被执行过, 则直接返回第一次执行的结果</div><div class="line">        if(ran)</div><div class="line">            return memo;</div><div class="line">        ran = true;</div><div class="line">        return memo = func.apply(this, arguments);</div><div class="line">    &#125;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这个函数创建一个只会被执行一次的函数, 如果该函数被重复调用, 将返回第一次执行的结果</p>
<h2 id="wrap"><a href="#wrap" class="headerlink" title="_.wrap"></a>_.wrap</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">_.wrap = function(func, wrapper) &#123;</div><div class="line">    return function() &#123;</div><div class="line">        // 将当前函数作为第一个参数, 传递给wrapper函数</div><div class="line">        var args = [func].concat(slice.call(arguments, 0));</div><div class="line">        // 返回wrapper函数的处理结果</div><div class="line">        return wrapper.apply(this, args);</div><div class="line">    &#125;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这个函数返回一个函数, 该函数会将当前函数作为参数传递给一个包裹函数，在包裹函数中可以通过第一个参数调用当前函数, 并返回结果</p>
<h2 id="compose"><a href="#compose" class="headerlink" title="_.compose"></a>_.compose</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">_.compose = function() &#123;</div><div class="line">    // 获取函数列表, 所有参数需均为Function类型</div><div class="line">    var funcs = arguments;</div><div class="line">    // 返回一个供调用的函数句柄</div><div class="line">    return function() &#123;</div><div class="line">        // 从后向前依次执行函数, 并将记录的返回值作为参数传递给前一个函数继续处理</div><div class="line">        var args = arguments;</div><div class="line">        for(var i = funcs.length - 1; i &gt;= 0; i--) &#123;</div><div class="line">            args = [funcs[i].apply(this, args)];</div><div class="line">        &#125;</div><div class="line">        // 返回最后一次调用函数的返回值</div><div class="line">        return args[0];</div><div class="line">    &#125;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这个函数将多个函数组合到一起, 按照参数传递的顺序, 后一个函数的返回值会被依次作为参数传递给前一个函数作为参数继续处理，_.compose(A, B, C)等同于 A(B(C()))</p>
<h2 id="after"><a href="#after" class="headerlink" title="_.after"></a>_.after</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">_.after = function(times, func) &#123;</div><div class="line">    // 如果没有指定或指定无效次数, 则func被直接调用</div><div class="line">    if(times &lt;= 0)</div><div class="line">        return func();</div><div class="line">    // 返回一个计数器函数</div><div class="line">    return function() &#123;</div><div class="line">        // 每次调用计数器函数times减1, 调用times次之后执行func函数并返回func函数的返回值</div><div class="line">        if(--times &lt; 1) &#123;</div><div class="line">            return func.apply(this, arguments);</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>after返回一个函数, 该函数作为调用计数器, 当该函数被调用times次(或超过times次)后, func函数将被执行</p>
<h2 id="keys"><a href="#keys" class="headerlink" title="_.keys"></a>_.keys</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">_.keys = nativeKeys ||</div><div class="line">function(obj) &#123;</div><div class="line">    if(obj !== Object(obj))</div><div class="line">        throw new TypeError(&apos;Invalid object&apos;);</div><div class="line">    var keys = [];</div><div class="line">    // 记录并返回对象的所有属性名</div><div class="line">    for(var key in obj)</div><div class="line">    if(_.has(obj, key))</div><div class="line">        keys[keys.length] = key;</div><div class="line">    return keys;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这个函数用于获取一个对象的属性名列表(不包含原型链中的属性)</p>
<h2 id="values"><a href="#values" class="headerlink" title="_.values"></a>_.values</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">_.values = function(obj) &#123;</div><div class="line">    return _.map(obj, _.identity);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这个函数返回一个对象中所有属性的值列表(不包含原型链中的属性)</p>
<h2 id="functions-methods"><a href="#functions-methods" class="headerlink" title=".functions / .methods"></a><em>.functions / </em>.methods</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">_.functions = _.methods = function(obj) &#123;</div><div class="line">    var names = [];</div><div class="line">    for(var key in obj) &#123;</div><div class="line">        if(_.isFunction(obj[key]))</div><div class="line">            names.push(key);</div><div class="line">    &#125;</div><div class="line">    return names.sort();</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这个函数获取一个对象中所有属性值为Function类型的key列表, 并按key名进行排序(包含原型链中的属性)</p>
<h2 id="extend"><a href="#extend" class="headerlink" title="_.extend"></a>_.extend</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">_.extend = function(obj) &#123;</div><div class="line">    // each循环参数中的一个或多个对象</div><div class="line">    each(slice.call(arguments, 1), function(source) &#123;</div><div class="line">        // 将对象中的全部属性复制或覆盖到obj对象</div><div class="line">        for(var prop in source) &#123;</div><div class="line">            obj[prop] = source[prop];</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">    return obj;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这个函数将一个或多个对象的属性(包含原型链中的属性), 复制到obj对象, 如果存在同名属性则覆盖</p>
<h2 id="pick"><a href="#pick" class="headerlink" title="_.pick"></a>_.pick</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">_.pick = function(obj) &#123;</div><div class="line">    // 创建一个对象, 存放复制的指定属性</div><div class="line">    var result = &#123;&#125;;</div><div class="line">    // 从第二个参数开始合并为一个存放属性名列表的数组</div><div class="line">    each(_.flatten(slice.call(arguments, 1)), function(key) &#123;</div><div class="line">        // 循环属性名列表, 如果obj中存在该属性, 则将其复制到result对象</div><div class="line">        if( key in obj)</div><div class="line">            result[key] = obj[key];</div><div class="line">    &#125;);</div><div class="line">    // 返回复制结果</div><div class="line">    return result;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这个函数返回一个新对象, 并从obj中复制指定的属性到新对象中，第2个参数开始为指定的需要复制的属性名</p>
<h2 id="defaults"><a href="#defaults" class="headerlink" title="_.defaults"></a>_.defaults</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">_.defaults = function(obj) &#123;</div><div class="line">    // 从第二个参数开始可指定多个对象, 这些对象中的属性将被依次复制到obj对象中(如果obj对象中不存在该属性的话)</div><div class="line">    each(slice.call(arguments, 1), function(source) &#123;</div><div class="line">        // 遍历每个对象中的所有属性</div><div class="line">        for(var prop in source) &#123;</div><div class="line">            // 如果obj中不存在或属性值转换为Boolean类型后值为false, 则将属性复制到obj中</div><div class="line">            if(obj[prop] == null)</div><div class="line">                obj[prop] = source[prop];</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">    return obj;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这个函数将obj中不存在或转换为Boolean类型后值为false的属性, 从参数中指定的一个或多个对象中复制到obj，一般用于给对象指定默认值</p>
<h2 id="clone"><a href="#clone" class="headerlink" title="_.clone"></a>_.clone</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">_.clone = function(obj) &#123;</div><div class="line">    // 不支持非数组和对象类型的数据</div><div class="line">    if(!_.isObject(obj))</div><div class="line">        return obj;</div><div class="line">    // 复制并返回数组或对象</div><div class="line">    return _.isArray(obj) ? obj.slice() : _.extend(&#123;&#125;, obj);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这个函数创建一个obj的副本, 返回一个新的对象, 该对象包含obj中的所有属性和值的状态</p>
<h2 id="tap"><a href="#tap" class="headerlink" title="_.tap"></a>_.tap</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">_.tap = function(obj, interceptor) &#123;</div><div class="line">    interceptor(obj);</div><div class="line">    return obj;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这个函数执行一个函数, 并将obj作为参数传递给该函数, 函数执行完毕后最终返回obj对象</p>
<h2 id="eq"><a href="#eq" class="headerlink" title="eq"></a>eq</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div></pre></td><td class="code"><pre><div class="line">function eq(a, b, stack) &#123;</div><div class="line">    // 检查两个简单数据类型的值是否相等</div><div class="line">    // 对于复合数据类型, 如果它们来自同一个引用, 则认为其相等</div><div class="line">    // 如果被比较的值其中包含0, 则检查另一个值是否为-0, 因为 0 === -0 是成立的</div><div class="line">    // 而 1 / 0 == 1 / -0 是不成立的(1 / 0值为Infinity, 1 / -0值为-Infinity, 而Infinity不等于-Infinity)</div><div class="line">    if(a === b)</div><div class="line">        return a !== 0 || 1 / a == 1 / b;</div><div class="line">    // 将数据转换为布尔类型后如果值为false, 将判断两个值的数据类型是否相等(因为null与undefined, false, 0, 空字符串, 在非严格比较下值是相等的)</div><div class="line">    if(a == null || b == null)</div><div class="line">        return a === b;</div><div class="line">    // 如果进行比较的数据是一个Underscore封装的对象(具有_chain属性的对象被认为是Underscore对象)</div><div class="line">    // 则将对象解封后获取本身的数据(通过_wrapped访问), 然后再对本身的数据进行比较</div><div class="line">    // 它们的关系类似与一个jQuery封装的DOM对象, 和浏览器本身创建的DOM对象</div><div class="line">    if(a._chain)</div><div class="line">        a = a._wrapped;</div><div class="line">    if(b._chain)</div><div class="line">        b = b._wrapped;</div><div class="line">    // 如果对象提供了自定义的isEqual方法(此处的isEqual方法并非Undersocre对象的isEqual方法, 因为在上一步已经对Undersocre对象进行了解封)</div><div class="line">    // 则使用对象自定义的isEqual方法与另一个对象进行比较</div><div class="line">    if(a.isEqual &amp;&amp; _.isFunction(a.isEqual))</div><div class="line">        return a.isEqual(b);</div><div class="line">    if(b.isEqual &amp;&amp; _.isFunction(b.isEqual))</div><div class="line">        return b.isEqual(a);</div><div class="line">    // 对两个数据的数据类型进行验证</div><div class="line">    // 获取对象a的数据类型(通过Object.prototype.toString方法)</div><div class="line">    var className = toString.call(a);</div><div class="line">    // 如果对象a的数据类型与对象b不匹配, 则认为两个数据值也不匹配</div><div class="line">    if(className != toString.call(b))</div><div class="line">        return false;</div><div class="line">    // 执行到此处, 可以确保需要比较的两个数据均为复合数据类型, 且数据类型相等</div><div class="line">    // 通过switch检查数据的数据类型, 针对不同数据类型进行不同的比较</div><div class="line">    // (此处不包括对数组和对象类型, 因为它们可能包含更深层次的数据, 将在后面进行深层比较)</div><div class="line">    switch (className) &#123;</div><div class="line">        case &apos;[object String]&apos;:</div><div class="line">            // 如果被比较的是字符串类型(其中a的是通过new String()创建的字符串)</div><div class="line">            // 则将B转换为String对象后进行匹配(这里匹配并非进行严格的数据类型检查, 因为它们并非来自同一个对象的引用)</div><div class="line">            // 在调用 == 进行比较时, 会自动调用对象的toString()方法, 返回两个简单数据类型的字符串</div><div class="line">            return a == String(b);</div><div class="line">        case &apos;[object Number]&apos;:</div><div class="line">            // 通过+a将a转成一个Number, 如果a被转换之前与转换之后不相等, 则认为a是一个NaN类型</div><div class="line">            // 因为NaN与NaN是不相等的, 因此当a值为NaN时, 无法简单地使用a == b进行匹配, 而是用相同的方法检查b是否为NaN(即 b != +b)</div><div class="line">            // 当a值是一个非NaN的数据时, 则检查a是否为0, 因为当b为-0时, 0 === -0是成立的(实际上它们在逻辑上属于两个不同的数据)</div><div class="line">            return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);</div><div class="line">        case &apos;[object Date]&apos;:</div><div class="line">        // 对日期类型没有使用return或break, 因此会继续执行到下一步(无论数据类型是否为Boolean类型, 因为下一步将对Boolean类型进行检查)</div><div class="line">        case &apos;[object Boolean]&apos;:</div><div class="line">            // 将日期或布尔类型转换为数字</div><div class="line">            // 日期类型将转换为数值类型的时间戳(无效的日期格式将被换转为NaN)</div><div class="line">            // 布尔类型中, true被转换为1, false被转换为0</div><div class="line">            // 比较两个日期或布尔类型被转换为数字后是否相等</div><div class="line">            return +a == +b;</div><div class="line">        case &apos;[object RegExp]&apos;:</div><div class="line">            // 正则表达式类型, 通过source访问表达式的字符串形式</div><div class="line">            // 检查两个表达式的字符串形式是否相等</div><div class="line">            // 检查两个表达式的全局属性是否相同(包括g, i, m)</div><div class="line">            // 如果完全相等, 则认为两个数据相等</div><div class="line">            return a.source == b.source &amp;&amp; a.global == b.global &amp;&amp; a.multiline == b.multiline &amp;&amp; a.ignoreCase == b.ignoreCase;</div><div class="line">    &#125;</div><div class="line">    // 当执行到此时, ab两个数据应该为类型相同的对象或数组类型</div><div class="line">    if( typeof a != &apos;object&apos; || typeof b != &apos;object&apos;)</div><div class="line">        return false;</div><div class="line">    // stack(堆)是在isEqual调用eq函数时内部传递的空数组, 在后面比较对象和数据的内部迭代中调用eq方法也会传递</div><div class="line">    // length记录堆的长度</div><div class="line">    var length = stack.length;</div><div class="line">    while(length--) &#123;</div><div class="line">        // 如果堆中的某个对象与数据a匹配, 则认为相等</div><div class="line">        if(stack[length] == a)</div><div class="line">            return true;</div><div class="line">    &#125;</div><div class="line">    // 将数据a添加到堆中</div><div class="line">    stack.push(a);</div><div class="line">    // 定义一些局部变量</div><div class="line">    var size = 0, result = true;</div><div class="line">    // 通过递归深层比较对象和数组</div><div class="line">    if(className == &apos;[object Array]&apos;) &#123;</div><div class="line">        // 被比较的数据为数组类型</div><div class="line">        // size记录数组的长度</div><div class="line">        // result比较两个数组的长度是否一致, 如果长度不一致, 则方法的最后将返回result(即false)</div><div class="line">        size = a.length;</div><div class="line">        result = size == b.length;</div><div class="line">        // 如果两个数组的长度一致</div><div class="line">        if(result) &#123;</div><div class="line">            // 调用eq方法对数组中的元素进行迭代比较(如果数组中包含二维数组或对象, eq方法会进行深层比较)</div><div class="line">            while(size--) &#123;</div><div class="line">                // 在确保两个数组都存在当前索引的元素时, 调用eq方法深层比较(将堆数据传递给eq方法)</div><div class="line">                // 将比较的结果存储到result变量, 如果result为false(即在比较中得到某个元素的数据不一致), 则停止迭代</div><div class="line">                if(!( result = size in a == size in b &amp;&amp; eq(a[size], b[size], stack)))</div><div class="line">                    break;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125; else &#123;</div><div class="line">        // 被比较的数据为对象类型</div><div class="line">        // 如果两个对象不是同一个类的实例(通过constructor属性比较), 则认为两个对象不相等</div><div class="line">        if(&apos;constructor&apos; in a != &apos;constructor&apos; in b || a.constructor != b.constructor)</div><div class="line">            return false;</div><div class="line">        // 深层比较两个对象中的数据</div><div class="line">        for(var key in a) &#123;</div><div class="line">            if(_.has(a, key)) &#123;</div><div class="line">                // size用于记录比较过的属性数量, 因为这里遍历的是a对象的属性, 并比较b对象中该属性的数据</div><div class="line">                // 当b对象中的属性数量多余a对象时, 此处的逻辑成立, 但两个对象并不相等</div><div class="line">                size++;</div><div class="line">                // 迭代调用eq方法, 深层比较两个对象中的属性值</div><div class="line">                // 将比较的结果记录到result变量, 当比较到不相等的数据时停止迭代</div><div class="line">                if(!( result = _.has(b, key) &amp;&amp; eq(a[key], b[key], stack)))</div><div class="line">                    break;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        // 深层比较完毕, 这里已经可以确保在对象a中的所有数据, 对象b中也存在相同的数据</div><div class="line">        // 根据size(对象属性长度)检查对象b中的属性数量是否与对象a相等</div><div class="line">        if(result) &#123;</div><div class="line">            // 遍历对象b中的所有属性</div><div class="line">            for(key in b) &#123;</div><div class="line">                // 当size已经到0时(即对象a中的属性数量已经遍历完毕), 而对象b中还存在有属性, 则对象b中的属性多于对象a</div><div class="line">                if(_.has(b, key) &amp;&amp; !(size--))</div><div class="line">                    break;</div><div class="line">            &#125;</div><div class="line">            // 当对象b中的属性多于对象a, 则认为两个对象不相等</div><div class="line">            result = !size;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    // 函数执行完毕时, 从堆中移除第一个数据(在比较对象或数组时, 会迭代eq方法, 堆中可能存在多个数据)</div><div class="line">    stack.pop();</div><div class="line">    // 返回的result记录了最终的比较结果</div><div class="line">    return result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>eq函数只在isEqual方法中调用, 用于比较两个数据的值是否相等,与 === 不同在于, eq更关注数据的值,如果进行比较的是两个复合数据类型, 不仅仅比较是否来自同一个引用, 且会进行深层比较(对两个对象的结构和数据进行比较)</p>
<h2 id="isEqual"><a href="#isEqual" class="headerlink" title="_.isEqual"></a>_.isEqual</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">_.isEqual = function(a, b) &#123;</div><div class="line">    return eq(a, b, []);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>不多说了，就是内部函数eq的外部方法</p>
<h2 id="isEmpty"><a href="#isEmpty" class="headerlink" title="_.isEmpty"></a>_.isEmpty</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">_.isEmpty = function(obj) &#123;</div><div class="line">    // obj被转换为Boolean类型后值为false</div><div class="line">    if(obj == null)</div><div class="line">        return true;</div><div class="line">    // 检查对象或字符串长度是否为0</div><div class="line">    if(_.isArray(obj) || _.isString(obj))</div><div class="line">        return obj.length === 0;</div><div class="line">    // 检查对象(使用for in循环时将首先循环对象本身的属性, 其次是原型链中的属性), 因此如果第一个属性是属于对象本身的, 那么该对象不是一个空对象</div><div class="line">    for(var key in obj)</div><div class="line">    if(_.has(obj, key))</div><div class="line">        return false;</div><div class="line">    // 所有数据类型均没有通过验证, 是一个空数据</div><div class="line">    return true;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这个函数用于检查数据是否为空值, 包含’’, false, 0, null, undefined, NaN, 空数组(数组长度为0)和空对象(对象本身没有任何属性)</p>
<h2 id="isElement"><a href="#isElement" class="headerlink" title="_.isElement"></a>_.isElement</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">_.isElement = function(obj) &#123;</div><div class="line">    return !!(obj &amp;&amp; obj.nodeType == 1);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这个函数用于验证对象是否是一个DOM对象</p>
<h2 id="isArray"><a href="#isArray" class="headerlink" title="_.isArray"></a>_.isArray</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">_.isArray = nativeIsArray ||</div><div class="line">function(obj) &#123;</div><div class="line">    return toString.call(obj) == &apos;[object Array]&apos;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这个函数用于验证一个变量是否是数组</p>
<h2 id="isObject"><a href="#isObject" class="headerlink" title="_.isObject"></a>_.isObject</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">_.isObject = function(obj) &#123;</div><div class="line">    return obj === Object(obj);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这个函数用于验证对象是否是一个复合数据类型的对象(即非基本数据类型String, Boolean, Number, null, undefined)</p>
<h2 id="isArguments"><a href="#isArguments" class="headerlink" title="_.isArguments"></a>_.isArguments</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">_.isArguments = function(obj) &#123;</div><div class="line">    return toString.call(obj) == &apos;[object Arguments]&apos;;</div><div class="line">&#125;;</div><div class="line">// 验证isArguments函数, 如果运行环境无法正常验证arguments类型的数据, 则重新定义isArguments方法</div><div class="line">if(!_.isArguments(arguments)) &#123;</div><div class="line">    // 对于环境无法通过toString验证arguments类型的, 则通过调用arguments独有的callee方法来进行验证</div><div class="line">    _.isArguments = function(obj) &#123;</div><div class="line">        // callee是arguments的一个属性, 指向对arguments所属函数自身的引用</div><div class="line">        return !!(obj &amp;&amp; _.has(obj, &apos;callee&apos;));</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个函数用于检查一个数据是否是一个arguments参数对象</p>
<h2 id="isFunction-isString-isNumber-isDate-isRegExp"><a href="#isFunction-isString-isNumber-isDate-isRegExp" class="headerlink" title=".isFunction / .isString / .isNumber / .isDate / _.isRegExp"></a><em>.isFunction / </em>.isString / <em>.isNumber / </em>.isDate / _.isRegExp</h2><p>这几个我就放在一起说了，他们都是通过<strong>Object.prototype.toString.call(obj)</strong>的值来进行判断的</p>
<h2 id="isFinite"><a href="#isFinite" class="headerlink" title="_.isFinite"></a>_.isFinite</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">_.isFinite = function(obj) &#123;</div><div class="line">    return _.isNumber(obj) &amp;&amp; isFinite(obj);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这个函数用于检查一个数字是否为有效数字且有效范围(Number类型, 值在负无穷大 - 正无穷大之间)</p>
<h2 id="isNaN"><a href="#isNaN" class="headerlink" title="_.isNaN"></a>_.isNaN</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">_.isNaN = function(obj) &#123;</div><div class="line">    return obj !== obj;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>在js里，所有数据中只有NaN与NaN不相等</p>
<h2 id="isBoolean"><a href="#isBoolean" class="headerlink" title="_.isBoolean"></a>_.isBoolean</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">_.isBoolean = function(obj) &#123;</div><div class="line">    // 支持字面量和对象形式的Boolean数据</div><div class="line">    return obj === true || obj === false || toString.call(obj) == &apos;[object Boolean]&apos;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这个函数用于检查数据是否是Boolean类型</p>
<h2 id="isNull"><a href="#isNull" class="headerlink" title="_.isNull"></a>_.isNull</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">_.isNull = function(obj) &#123;</div><div class="line">    return obj === null;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这个函数用于检查数据是否是Null值</p>
<h2 id="isUndefined"><a href="#isUndefined" class="headerlink" title="_.isUndefined"></a>_.isUndefined</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">_.isUndefined = function(obj) &#123;</div><div class="line">    return obj === void 0;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这个函数用于检查数据是否是Undefined值</p>
<h2 id="has"><a href="#has" class="headerlink" title="_.has"></a>_.has</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">_.has = function(obj, key) &#123;</div><div class="line">    return hasOwnProperty.call(obj, key);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这个函数检查一个属性是否属于对象本身, 而非原型链中</p>
<h2 id="noConflict"><a href="#noConflict" class="headerlink" title="_.noConflict"></a>_.noConflict</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">_.noConflict = function() &#123;</div><div class="line">    // previousUnderscore变量记录了Underscore定义前_(下划线)的值</div><div class="line">    root._ = previousUnderscore;</div><div class="line">    return this;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这个函数一般用于避免命名冲突或规范命名方式，放弃_(下划线)命名的Underscore对象, 并返回Underscore对象</p>
<h2 id="identity"><a href="#identity" class="headerlink" title="_.identity"></a>_.identity</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">_.identity = function(value) &#123;</div><div class="line">    return value;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这个函数返回与参数相同的值, 一般用于将一个数据的获取方式转换为函数获取方式(内部用于构建方法时作为默认处理器函数)</p>
<h2 id="times"><a href="#times" class="headerlink" title="_.times"></a>_.times</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">_.times = function(n, iterator, context) &#123;</div><div class="line">    for(var i = 0; i &lt; n; i++)</div><div class="line">    iterator.call(context, i);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这个函数的作用是使指定的函数迭代执行n次(无参数)</p>
<h2 id="escape"><a href="#escape" class="headerlink" title="_.escape"></a>_.escape</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">_.escape = function(string) &#123;</div><div class="line">    return (&apos;&apos; + string).replace(/&amp;/g, &apos;&amp;amp;&apos;).replace(/&lt;/g, &apos;&amp;lt;&apos;).replace(/&gt;/g, &apos;&amp;gt;&apos;).replace(/&quot;/g, &apos;&amp;quot;&apos;).replace(/&apos;/g, &apos;&amp;#x27;&apos;).replace(/\//g, &apos;&amp;#x2F;&apos;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这个函数用于将HTML字符串中的特殊字符转换为HTML实体, 包含 &amp; &lt; &gt; “ ‘ \</p>
<h2 id="result"><a href="#result" class="headerlink" title="_.result"></a>_.result</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">_.result = function(object, property) &#123;</div><div class="line">    if(object == null)</div><div class="line">        return null;</div><div class="line">    // 获取对象的值</div><div class="line">    var value = object[property];</div><div class="line">    // 如果值是一个函数, 则执行并返回, 否则将直接返回</div><div class="line">    return _.isFunction(value) ? value.call(object) : value;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这个函数指定一个对象的属性, 返回该属性对应的值, 如果该属性对应的是一个函数, 则会执行该函数并返回结果</p>
<h2 id="mixin"><a href="#mixin" class="headerlink" title="_.mixin"></a>_.mixin</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">_.mixin = function(obj) &#123;</div><div class="line">    // obj是一个集合一系列自定义方法的对象, 此处通过each遍历对象的方法</div><div class="line">    each(_.functions(obj), function(name) &#123;</div><div class="line">        // 通过addToWrapper函数将自定义方法添加到Underscore构建的对象中, 用于支持对象式调用</div><div class="line">        // 同时将方法添加到 _ 本身, 用于支持函数式调用</div><div class="line">        addToWrapper(name, _[name] = obj[name]);</div><div class="line">    &#125;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这个函数添加一系列自定义方法到Underscore对象中, 用于扩展Underscore插件</p>
<h2 id="template"><a href="#template" class="headerlink" title="_.template"></a>_.template</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">_.template = function(text, data, settings) &#123;</div><div class="line">    // 模板配置, 如果没有指定配置项, 则使用templateSettings中指定的配置项</div><div class="line">    settings = _.defaults(settings || &#123;&#125;, _.templateSettings);</div><div class="line"></div><div class="line">    // 开始将模板解析为可执行源码</div><div class="line">    var source = &quot;__p+=&apos;&quot; + text.replace(escaper, function(match) &#123;</div><div class="line">        // 将特殊符号转移为字符串形式</div><div class="line">        return &apos;\\&apos; + escapes[match];</div><div class="line">    &#125;).replace(settings.escape || noMatch, function(match, code) &#123;</div><div class="line">        // 解析escape形式标签 &lt;%- %&gt;, 将变量中包含的HTML通过_.escape函数转换为HTML实体</div><div class="line">        return &quot;&apos;+\n_.escape(&quot; + unescape(code) + &quot;)+\n&apos;&quot;;</div><div class="line">    &#125;).replace(settings.interpolate || noMatch, function(match, code) &#123;</div><div class="line">        // 解析interpolate形式标签 &lt;%= %&gt;, 将模板内容作为一个变量与其它字符串连接起来, 则会作为一个变量输出</div><div class="line">        return &quot;&apos;+\n(&quot; + unescape(code) + &quot;)+\n&apos;&quot;;</div><div class="line">    &#125;).replace(settings.evaluate || noMatch, function(match, code) &#123;</div><div class="line">        // 解析evaluate形式标签 &lt;% %&gt;, evaluate标签中存储了需要执行的JavaScript代码, 这里结束当前的字符串拼接, 并在新的一行作为JavaScript语法执行, 并将后面的内容再次作为字符串的开始, 因此evaluate标签内的JavaScript代码就能被正常执行</div><div class="line">        return &quot;&apos;;\n&quot; + unescape(code) + &quot;\n;__p+=&apos;&quot;;</div><div class="line">    &#125;) + &quot;&apos;;\n&quot;;</div><div class="line">    if(!settings.variable)</div><div class="line">        source = &apos;with(obj||&#123;&#125;)&#123;\n&apos; + source + &apos;&#125;\n&apos;;</div><div class="line">    source = &quot;var __p=&apos;&apos;;&quot; + &quot;var print=function()&#123;__p+=Array.prototype.join.call(arguments, &apos;&apos;)&#125;;\n&quot; + source + &quot;return __p;\n&quot;;</div><div class="line"></div><div class="line">    // 创建一个函数, 将源码作为函数执行体, 将obj和Underscore作为参数传递给该函数</div><div class="line">    var render = new Function(settings.variable || &apos;obj&apos;, &apos;_&apos;, source);</div><div class="line">    // 如果指定了模板的填充数据, 则替换模板内容, 并返回替换后的结果</div><div class="line">    if(data)</div><div class="line">        return render(data, _);</div><div class="line">    // 如果没有指定填充数据, 则返回一个函数, 该函数用于将接收到的数据替换到模板</div><div class="line">    // 如果在程序中会多次填充相同模板, 那么在第一次调用时建议不指定填充数据, 在获得处理函数的引用后, 再直接调用会提高运行效率</div><div class="line">    var template = function(data) &#123;</div><div class="line">        return render.call(this, data, _);</div><div class="line">    &#125;;</div><div class="line">    // 将创建的源码字符串添加到函数对象中, 一般用于调试和测试</div><div class="line">    template.source = &apos;function(&apos; + (settings.variable || &apos;obj&apos;) + &apos;)&#123;\n&apos; + source + &apos;&#125;&apos;;</div><div class="line">    // 没有指定填充数据的情况下, 返回处理函数句柄</div><div class="line">    return template;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这个我要介绍的最后一个函数，也是我个人认为比较重要的，它是Underscore模板解析方法, 用于将数据填充到一个模板字符串中，在模板体内, 可通过argments获取2个参数, 分别为填充数据(名称为obj)和Underscore对象(名称为_)</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>今天一口气把剩下的所有函数都介绍完了，真是累感不爱啊，不过在写作这几篇博客的过程中，我也从Underscore这个框架中学到了很多东西，包括它的优雅的代码风格（至少比我自己写的优雅），还有一个优秀的库整个的架构是怎么搭建起来的。<br>以后我还会继续为大家分享其他的前端知识和学习心得，thx for reading, hope u enjoy</p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        
  <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
    <div>坚持原创技术分享，您的支持将鼓励我继续创作！</div>
    <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
      <span>赏</span>
    </button>
    <div id="QR" style="display: none;">
      
        <div id="wechat" style="display: inline-block">
          <img id="wechat_qr" src="/images/wechat.jpg" alt="JoeRay61 WeChat Pay"/>
          <p>微信打赏</p>
        </div>
      
      
        <div id="alipay" style="display: inline-block">
          <img id="alipay_qr" src="/images/alipay.jpg" alt="JoeRay61 Alipay"/>
          <p>支付宝打赏</p>
        </div>
      
    </div>
  </div>


      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/javascript/" rel="tag"># javascript</a>
          
            <a href="/tags/underscore/" rel="tag"># underscore</a>
          
            <a href="/tags/源码/" rel="tag"># 源码</a>
          
        </div>
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2014/06/06/Underscore源码解析（三）/" rel="next" title="Underscore源码解析（三）">
                <i class="fa fa-chevron-left"></i> Underscore源码解析（三）
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2014/09/20/浅谈Javascript中Promise对象的实现/" rel="prev" title="浅谈Javascript中Promise对象的实现">
                浅谈Javascript中Promise对象的实现 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/joeray61.png"
               alt="JoeRay61" />
          <p class="site-author-name" itemprop="name">JoeRay61</p>
           
              <p class="site-description motion-element" itemprop="description">野蛮生长ing ~</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">14</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">1</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">13</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/Joe3Ray" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/u/1997891561" target="_blank" title="Weibo">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                  Weibo
                </a>
              </span>
            
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              友情链接
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="https://schoeu.com/" title="Schoeu" target="_blank">Schoeu</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="https://xuexb.com/" title="前端小武" target="_blank">前端小武</a>
                </li>
              
            </ul>
          </div>
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#zip"><span class="nav-number">1.</span> <span class="nav-text">_.zip</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#indexOf"><span class="nav-number">2.</span> <span class="nav-text">_.indexOf</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#lastIndexOf"><span class="nav-number">3.</span> <span class="nav-text">_.lastIndexOf</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#range"><span class="nav-number">4.</span> <span class="nav-text">_.range</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#bind"><span class="nav-number">5.</span> <span class="nav-text">_.bind</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#bindAll"><span class="nav-number">6.</span> <span class="nav-text">_.bindAll</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#memoize"><span class="nav-number">7.</span> <span class="nav-text">_.memoize</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#delay"><span class="nav-number">8.</span> <span class="nav-text">_.delay</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#defer"><span class="nav-number">9.</span> <span class="nav-text">_.defer</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#throttle"><span class="nav-number">10.</span> <span class="nav-text">_.throttle</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#debounce"><span class="nav-number">11.</span> <span class="nav-text">_.debounce</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#once"><span class="nav-number">12.</span> <span class="nav-text">_.once</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#wrap"><span class="nav-number">13.</span> <span class="nav-text">_.wrap</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#compose"><span class="nav-number">14.</span> <span class="nav-text">_.compose</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#after"><span class="nav-number">15.</span> <span class="nav-text">_.after</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#keys"><span class="nav-number">16.</span> <span class="nav-text">_.keys</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#values"><span class="nav-number">17.</span> <span class="nav-text">_.values</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#functions-methods"><span class="nav-number">18.</span> <span class="nav-text">.functions / .methods</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#extend"><span class="nav-number">19.</span> <span class="nav-text">_.extend</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#pick"><span class="nav-number">20.</span> <span class="nav-text">_.pick</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#defaults"><span class="nav-number">21.</span> <span class="nav-text">_.defaults</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#clone"><span class="nav-number">22.</span> <span class="nav-text">_.clone</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#tap"><span class="nav-number">23.</span> <span class="nav-text">_.tap</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#eq"><span class="nav-number">24.</span> <span class="nav-text">eq</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#isEqual"><span class="nav-number">25.</span> <span class="nav-text">_.isEqual</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#isEmpty"><span class="nav-number">26.</span> <span class="nav-text">_.isEmpty</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#isElement"><span class="nav-number">27.</span> <span class="nav-text">_.isElement</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#isArray"><span class="nav-number">28.</span> <span class="nav-text">_.isArray</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#isObject"><span class="nav-number">29.</span> <span class="nav-text">_.isObject</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#isArguments"><span class="nav-number">30.</span> <span class="nav-text">_.isArguments</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#isFunction-isString-isNumber-isDate-isRegExp"><span class="nav-number">31.</span> <span class="nav-text">.isFunction / .isString / .isNumber / .isDate / _.isRegExp</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#isFinite"><span class="nav-number">32.</span> <span class="nav-text">_.isFinite</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#isNaN"><span class="nav-number">33.</span> <span class="nav-text">_.isNaN</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#isBoolean"><span class="nav-number">34.</span> <span class="nav-text">_.isBoolean</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#isNull"><span class="nav-number">35.</span> <span class="nav-text">_.isNull</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#isUndefined"><span class="nav-number">36.</span> <span class="nav-text">_.isUndefined</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#has"><span class="nav-number">37.</span> <span class="nav-text">_.has</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#noConflict"><span class="nav-number">38.</span> <span class="nav-text">_.noConflict</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#identity"><span class="nav-number">39.</span> <span class="nav-text">_.identity</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#times"><span class="nav-number">40.</span> <span class="nav-text">_.times</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#escape"><span class="nav-number">41.</span> <span class="nav-text">_.escape</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#result"><span class="nav-number">42.</span> <span class="nav-text">_.result</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#mixin"><span class="nav-number">43.</span> <span class="nav-text">_.mixin</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#template"><span class="nav-number">44.</span> <span class="nav-text">_.template</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#小结"><span class="nav-number"></span> <span class="nav-text">小结</span></a></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2016 - 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">JoeRay61</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  






  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  


  

    
      <script id="dsq-count-scr" src="https://joeray61-blog.disqus.com/count.js" async></script>
    

    
      <script type="text/javascript">
        var disqus_config = function () {
          this.page.url = 'http://joeray61.com/2014/06/07/Underscore源码解析（四）/';
          this.page.identifier = '2014/06/07/Underscore源码解析（四）/';
          this.page.title = 'Underscore源码解析（四）';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://joeray61-blog.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      </script>
    

  




	





  





  





  






  





  

  

  

  

</body>
</html>
