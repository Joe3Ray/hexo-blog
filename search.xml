<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[eslint 学习笔记]]></title>
      <url>%2F2017%2F07%2F18%2Feslint-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[安装局部： 1npm install eslint --save-dev 全局： 1npm install eslint -g 初始化1eslint --init Note: 此处及以后都假设全局安装eslint或者在npm script中使用eslint 使用eslint进行校验1eslint file.js 配置parser指定eslint使用的 parser，默认是Espree，除此之外常用的还有： Esprima Babel-ESLint .eslintrc示例： 123&#123; &quot;parser&quot;: &quot;esprima&quot;&#125; parserOptions指定传给 parser 的信息 .eslintrc示例： 123456789&#123; &quot;parserOptions&quot;: &#123; &quot;ecmaVersion&quot;: 6, &quot;sourceType&quot;: &quot;module&quot;, &quot;ecmaFeatures&quot;: &#123; &quot;jsx&quot;: true &#125; &#125;&#125; env指定程序运行的环境，这关系到有哪些预先定义好的全局变量 browser - 浏览器中的全局变量 node - nodejs中的全局变量 es6 - 启用 es6 中除了模块之外的其他特性（这会自动将parserOptions.ecmaVersion设置为6） worker - web worker中的全局变量 mocha - mocha 测试框架中的全局变量 … Note: 可以同时定义多个env .eslintrc示例: 123456&#123; &quot;env&quot;: &#123; &quot;browser&quot;: true, &quot;node&quot;: true &#125;&#125; globals全局变量申明，true表示允许改写，false表示不允许改写 .eslintrc示例： 123456&#123; &quot;globals&quot;: &#123; &quot;var1&quot;: true, &quot;var2&quot;: false &#125;&#125; plugins声明使用了哪些插件，插件名可以默认忽略eslint-plugin-前缀，这些插件可以用于rules、env和extends等配置中 .eslintrc示例： 123456789101112131415&#123; &quot;plugins&quot;: [ &quot;example&quot; // or &quot;eslint-plugin-example&quot; ], &quot;env&quot;: &#123; &quot;example/custom&quot;: true &#125;, &quot;extends&quot;: [ &quot;eslint:recommended&quot;, &quot;plugin:example/recommended&quot; ], &quot;rules&quot;: &#123; &quot;example/rule1&quot;: &quot;error&quot; &#125;&#125; extends继承一套基础配置 .eslintrc示例： 123&#123; &quot;extends&quot;: &quot;eslint:recommended&quot;&#125; rules具体校验规则的配置 .eslintrc示例： 12345&#123; &quot;rules&quot;: &#123; &quot;no-set-state&quot;: &quot;off&quot; &#125;&#125; 可以参考 http://eslint.org/docs/rules/ 了解更多rule settings共享的配置，配置中的信息将会被传递给所有要执行的规则（rule） .eslintrc示例： 12345&#123; &quot;settings&quot;: &#123; &quot;sharedData&quot;: &quot;Hello&quot; &#125;&#125; 注释配置注释配置是指在js文件中通过注释来单独指定一些校验信息 env1/* eslint-env node, mocha */ global1/* global var1:false, var2:false */ rule1/* eslint eqeqeq: 0, curly: 2 */ “off” or 0: 关闭这条规则 “warn” or 1: 开启规则，如果校验有问题则抛出警告 “error” or 2: 开启规则，如果校验有问题则抛出错误 关闭/开启所有规则校验12345/* eslint-disable */alert(&apos;foo&apos;);/* eslint-enable */ 关闭/开启校验部分具体的规则校验123456/* eslint-disable no-alert, no-console */alert(&apos;foo&apos;);console.log(&apos;bar&apos;);/* eslint-enable no-alert, no-console */ 关闭当前行的所有规则校验1alert(&apos;foo&apos;); // eslint-disable-line 关闭下一行的所有规则校验12// eslint-disable-next-linealert(&apos;foo&apos;); 关闭当前行的具体规则校验1alert(&apos;foo&apos;); // eslint-disable-line no-alert 关闭下一行的具体规则校验12// eslint-disable-next-line no-alertalert(&apos;foo&apos;);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[【译】JavaScript分号插入 - 所有你需要知道的事]]></title>
      <url>%2F2017%2F05%2F26%2F%E3%80%90%E8%AF%91%E3%80%91JavaScript%E5%88%86%E5%8F%B7%E6%8F%92%E5%85%A5-%E6%89%80%E6%9C%89%E4%BD%A0%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93%E7%9A%84%E4%BA%8B%2F</url>
      <content type="text"><![CDATA[原文地址：http://inimino.org/~inimino/blog/javascript_semicolons 分号自动插入是 JavaScript 最具争议的语法特点之一，人们对于这个特点有许多误解。 一些 JavaScript 程序员在每一条语句后面使用分号，还有一些只在必要的时候使用分号。大部分人介于这两者之间，有些甚至添加额外的分号作为风格。 即使你在每一行语句的结尾都加上分号，一些构建工具还是会转换成不明显的方式。不管你在使用分号这件事上是何种偏好，你必须知道如何能够专业地书写 JavaScript 代码。如果你能记住下面要说的这几种简单规则，你就能理解任何你有可能遇到的程序是如何被解析的，并且对 JavaScript 自动插入分号的机制了如指掌。 何时允许使用分号在 ECMAScirpt 标准中给出的正式语法，分号出现在每一句他们能出现的语句的末尾。比如do-while语句： 1do Statement while ( Expression ) ; 分号也会出现在变量声明语句、表达式语句（例如&quot;4 + 4;&quot; 或者&quot;f();&quot;）、continue、return、break、throw 和 debugger 语句后。 空语句只有一个分号，这在 JavaScript 中也是合法的。因此，;;;是一句合法的 JavaScript 语句，它会被解析成三条空语句，运行时不做任何事，如此重复三次。 有时候空语句的确是有用的，至少从语法上来说是这样。举个例子，要写一个无限循环，可以写while(1);，这里分号会被解析成空语句，这样while语句在语法上就是合法的。如果删掉分号，那while语句就不完整了，因为循环条件后面必须要有其他语句。 最后，分号也会出现在 for 循环语句中，例如for ( Expression ; Expression ; Expression ) Statement的形式，当然还有字符串和常规的字面量表达式中也会出现分号。 何时可以删除分号在 ECMAScript 标准的正式语法中，分号就是按照上述的场景来引入的。但是，标准随后也给出了一些规则，这些规则描述了真实的解析过程与正式语法的区别。分号会在解析时被插入到标记流中，尽快这只是规范层面的遍历用法。实际上，解析器并不需要生成假的分号标记，而是把分号视为在语法中特定位置可选（比如可以参考this parser expression grammar for ECMAScript，尤其是Statement，EOS，EOSnoLB和SnoLB规则）。插入了分号，就意味着当前正在被解析的这条语句结束了。 分号插入规则在ECMA-262 [pdf]的 7.9 章节有具体说明。 这一章节指出了 3 条基本规则，以及 2 个例外情况。 规则是： 当程序出现了一个不是正式语法允许的标记，如果 (a) 在那里有一个换行，或者 (b) 那个意外标记是一个关闭的大括号，就会插入一个分号 当一个文件已经到最后了，如果程序无法继续被解析，就会插入分号]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[rollup 初体验]]></title>
      <url>%2F2017%2F05%2F21%2Frollup-%E5%88%9D%E4%BD%93%E9%AA%8C%2F</url>
      <content type="text"><![CDATA[简介rollup 是 JavaScript 模块打包工具，能够将多个具有引用依赖关系的脚本文件打包成一个文件，并且能够做到只引入使用到的代码，如果使用 ES6 的模块系统的话。举个简单的栗子： 12345678910// foo.jsexport let a = &apos;hello world!&apos;;export let b = &apos;hello rollup!&apos;;// main.jsimport &#123;a&#125; from &apos;./foo&apos;;export default () =&gt; &#123; console.log(`the string is $&#123;a&#125;`);&#125; 以main.js作为程序入口，使用rollup打包后的代码是 12345678910// bundle.js&apos;use strict&apos;;var a = &apos;hello world!&apos;;var main = (function () &#123; console.log(&apos;the string is &apos; + a);&#125;);module.exports = main; 可以看到，foo.js和main.js被打包到bundle.js中，并且只引入了foo.js中使用到的export let a = &#39;hello world!&#39;; 安装局部安装 1$ npm i rollup 全局安装（可能需要sudo） 1$ npm i -g rollup 使用CLI123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354$ rolluprollup 版本 0.41.6=====================================用法: rollup [选项] &lt;入口文件&gt;基础选项:-v, --version 显示版本号-h, --help 显示帮助信息-c, --config 使用这个配置文件 （如果使用了该参数，但是并没有指定具体的配置文 p.config.js`）-w, --watch 观察要打包文件的变动，并且在有变动时重新打包-i, --input 输入 （另一种指定&lt;入口文件&gt;的方式）-o, --output &lt;output&gt; 输出 （如果缺省，则输出到控制台）-f, --format [es] 输出类型 (amd, cjs, es, iife, umd)-e, --external 用逗号分隔的不需要打包的模块 ID 列表-g, --globals 用逗号分隔的`module ID:Global`键值对 任何在这里定义的模块 ID 都会被加入到 external 选项中-n, --name UMD 输出的命名-u, --id AMD 模块的 ID （默认是匿名的）-m, --sourcemap 生成 sourcemap (`-m inline`用于生成内联map)--no-strict 不要在生成的模块中声明`use strict;`--no-indent 不要缩进结果--environment &lt;values&gt; 传给配置文件的设置 (见示例)--no-conflict 为 UMD 模块生成一个 noConflict 方法--silent 不要打印警告--intro 需要插入到包顶部的内容（在 amd/umd/iife 包装函数的内部）--outro 需要插入到包底部的内容（在 amd/umd/iife 包装函数的内部）--banner 需要插入到包顶部的内容（在 amd/umd/iife 包装函数的外部）--footer 需要插入到包底部的内容（在 amd/umd/iife 包装函数的外部）示例：# 在配置文件中使用设置rollup -c# 在配置文件中, process.env.INCLUDE_DEPS === &apos;true&apos;# 并且 process.env.BUILD === &apos;production&apos;rollup -c --environment INCLUDE_DEPS,BUILD:production# 从 src/main.js 创建 CommonJS 类型的包 bundle.jsrollup --format=cjs --output=bundle.js -- src/main.js# 创建一个使用`window.jQuery`和`window._`这两个全局变量的自执行的函数rollup -f iife --globals jquery:jQuery,lodash:_ \ -i src/app.js -o build/app.js -m build/app.js.map注意：* 当输出到控制台时，只允许使用内联 sourcemaps访问 https://github.com/rollup/rollup/wiki 获取更多信息 配置文件跟 webpack 一样，rollup 也可以使用配置文件，通过 cli 的-c参数来指定配置文件，默认为当前目录下的rollup.config.js。 使用配置文件有几点好处： 重复编译时，不需要重复输入大段的 CLI 配置参数 配置文件中我们可以进行编程，这样能够完成一些纯靠 CLI 参数无法完成的配置 配置文件需要输出一个配置对象 1234// rollup.config.jsexport default &#123; // write config key: value pair here&#125;; 常用的配置项其实跟 CLI 大同小异，具体如下： entry: String，入口文件路径 format: String，输出类型 (amd, cjs, es, iife, umd) plugins: Array，插件声明 external: Array，不需要打包的文件 dest: String，输出的打包文件 sourceMap: Boolean，是否要支持 sourcemap 插件rollup 的插件一般以 npm 包的形式引入，在配置文件中 plugins 里面声明。下面我介绍几个常用的 rollup 插件 rollup-plugin-json需要加载 json 文件的数据时，可以通过rollup-plugin-json这个插件 rollup-plugin-node-resolve这个插件可以让 rollup 更加智能地找到各个需要打包的文件路径 rollup-plugin-commonjs目前大多数的 npm 包还是以 CommonJS 模块的形式对外 export，rollup 本身无法解析他们，需要用rollup-plugin-commonjs先把他们转换成 ES6 的模块 rollup-plugin-babel熟悉 babel 的人大概已经猜到了，这个插件能让 rollup 具有 babel 的能力，可以用来转换 ES6 的代码，在使用前需要先配置.babelrc&#39;，要注意的是不能用 babel 转换 ES6 的模块，因为 rollup 的打包是依赖于 ES6 模块的。.babelrc`配置如下： 123456789&#123; &quot;presets&quot;: [ [&quot;latest&quot;, &#123; &quot;es2015&quot;: &#123; &quot;modules&quot;: false &#125; &#125;] ]&#125; APIrollup 可以作为一个包引入到 js 程序中 1var rollup = require(&apos;rollup&apos;); 他提供了几个 API: rollup.rollup(options)根据 options 选项执行打包过程，返回一个 Promise 对象，该对象在调用 resolve 时会传入打包后的bundle对象 bundle.generate(options)根据 options 生成代码，返回一个{code, sourcemap}对象 bundle.write(options)与bundle.generate类似，但是可以直接将编译结果写入到文件中。 以上只对 API 的功能做了简要介绍，具体可以参考官方wiki Tree-Shakingrollup 中的 Tree-Shaking 又叫live code inclusion，能够做到只引入使用的代码，减少打包后的文件大小，这与我们常说的DCE( Dead Code Elimination)目的一致，但是做法相反，DCE 的思路是提出不用的代码，从语义上来说，DCE 更符合 Tree-Shaking 的表述（想象熊孩子在摇晃一棵树，树上一些枯死的枝芽都被晃掉下来了）。 其实 rollup 的 Tree-Shaking 也只是处理了顶层的 AST，所以 rollup 处理后的代码仍然可能存在冗余，另外，Tree-Shaking 也不是代码压缩，所以也需要在这之后使用代码压缩工具进一步缩小文件大小。 Tree-Shaking的实现主要归功于 ES6 的模块，ES6 的模块是静态的 import 和 export，基于这个特性才能够进行模块的静态分析，这是在动态的 CommonJS 和 AMD 模块里无法做到的。这也是为什么 rollup 要求使用 ES6 模块的原因。 推荐大家阅读一下 Rich Harris 的这篇文章：Tree-shaking versus dead code elimination（需要翻墙） rollup vs webpack同样是打包工具，我们自然要将 rollup 和 webpack 比较一番，以下是我认为的几点区别，不一定对，欢迎留言讨论 rollup 一般用于 JavaScript 库的开发，而 webpack 一般用于 web 应用的开发 rollup 希望打包后的代码还是像人写的代码，而不是机器生成的代码，所以 rollup 不会给每个模块包上一层 function，也不会在打包后的文件顶部加上一个模块加载器，而 webpack 相反 基于第 2 点，rollup 打包后的文件比 webpack 打包后的文件更小]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Vue原理解析之observer模块]]></title>
      <url>%2F2017%2F02%2F16%2FVue%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90%E4%B9%8Bobserver%E6%A8%A1%E5%9D%97%2F</url>
      <content type="text"><![CDATA[本文是针对Vue@2.1.8进行分析 observer是Vue核心中最重要的一个模块（个人认为），能够实现视图与数据的响应式更新，底层全凭observer的支持。 observer模块在Vue项目中的代码位置是src/core/observer，模块共分为这几个部分： Observer: 数据的观察者，让数据对象的读写操作都处于自己的监管之下 Watcher: 数据的订阅者，数据的变化会通知到Watcher，然后由Watcher进行相应的操作，例如更新视图 Dep: Observer与Watcher的纽带，当数据变化时，会被Observer观察到，然后由Dep通知到Watcher 示意图如下： ObserverObserver类定义在src/core/observer/index.js中，先来看一下Observer的构造函数 123456789101112131415constructor (value: any) &#123; this.value = value this.dep = new Dep() this.vmCount = 0 def(value, &apos;__ob__&apos;, this) if (Array.isArray(value)) &#123; const augment = hasProto ? protoAugment : copyAugment augment(value, arrayMethods, arrayKeys) this.observeArray(value) &#125; else &#123; this.walk(value) &#125;&#125; value是需要被观察的数据对象，在构造函数中，会给value增加__ob__属性，作为数据已经被Observer观察的标志。如果value是数组，就使用observeArray遍历value，对value中每一个元素调用observe分别进行观察。如果value是对象，则使用walk遍历value上每个key，对每个key调用defineReactive来获得该key的set/get控制权。 解释下上面用到的几个函数的功能： observeArray: 遍历数组，对数组的每个元素调用observe observe: 检查对象上是否有__ob__属性，如果存在，则表明该对象已经处于Observer的观察中，如果不存在，则new Observer来观察对象（其实还有一些判断逻辑，为了便于理解就不赘述了） walk: 遍历对象的每个key，对对象上每个key的数据调用defineReactive defineReactive: 通过Object.defineProperty设置对象的key属性，使得能够捕获到该属性值的set/get动作。一般是由Watcher的实例对象进行get操作，此时Watcher的实例对象将被自动添加到Dep实例的依赖数组中，在外部操作触发了set时，将通过Dep实例的notify来通知所有依赖的watcher进行更新。 如果不太理解上面的文字描述可以看一下图： DepDep是Observer与Watcher之间的纽带，也可以认为Dep是服务于Observer的订阅系统。Watcher订阅某个Observer的Dep，当Observer观察的数据发生变化时，通过Dep通知各个已经订阅的Watcher。 Dep提供了几个接口： addSub: 接收的参数为Watcher实例，并把Watcher实例存入记录依赖的数组中 removeSub: 与addSub对应，作用是将Watcher实例从记录依赖的数组中移除 depend: Dep.target上存放这当前需要操作的Watcher实例，调用depend会调用该Watcher实例的addDep方法，addDep的功能可以看下面对Watcher的介绍 notify: 通知依赖数组中所有的watcher进行更新操作 WatcherWatcher是用来订阅数据的变化的并执行相应操作（例如更新视图）的。Watcher的构造器函数定义如下： 1234567891011121314151617181920212223242526272829303132333435363738394041constructor (vm, expOrFn, cb, options) &#123; this.vm = vm vm._watchers.push(this) // options if (options) &#123; this.deep = !!options.deep this.user = !!options.user this.lazy = !!options.lazy this.sync = !!options.sync &#125; else &#123; this.deep = this.user = this.lazy = this.sync = false &#125; this.cb = cb this.id = ++uid // uid for batching this.active = true this.dirty = this.lazy // for lazy watchers this.deps = [] this.newDeps = [] this.depIds = new Set() this.newDepIds = new Set() this.expression = process.env.NODE_ENV !== &apos;production&apos; ? expOrFn.toString() : &apos;&apos; if (typeof expOrFn === &apos;function&apos;) &#123; this.getter = expOrFn &#125; else &#123; this.getter = parsePath(expOrFn) if (!this.getter) &#123; this.getter = function () &#123;&#125; process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; warn( `Failed watching path: &quot;$&#123;expOrFn&#125;&quot; ` + &apos;Watcher only accepts simple dot-delimited paths. &apos; + &apos;For full control, use a function instead.&apos;, vm ) &#125; &#125; this.value = this.lazy ? undefined : this.get()&#125; 参数中，vm表示组件实例，expOrFn表示要订阅的数据字段（字符串表示，例如a.b.c）或是一个要执行的函数，cb表示watcher运行后的回调函数，options是选项对象，包含deep、user、lazy等配置。 watcher实例上有这些方法： get: 将Dep.target设置为当前watcher实例，在内部调用this.getter，如果此时某个被Observer观察的数据对象被取值了，那么当前watcher实例将会自动订阅数据对象的Dep实例 addDep: 接收参数dep(Dep实例)，让当前watcher订阅dep cleanupDeps: 清除newDepIds和newDep上记录的对dep的订阅信息 update: 立刻运行watcher或者将watcher加入队列中等待统一flush run: 运行watcher，调用this.get()求值，然后触发回调 evaluate: 调用this.get()求值 depend: 遍历this.deps，让当前watcher实例订阅所有dep teardown: 去除当前watcher实例所有的订阅 Array methods在src/core/observer/array.js中，Vue框架对数组的push、pop、shift、unshift、sort、splice、reverse方法进行了改造，在调用数组的这些方法时，自动触发dep.notify()，解决了调用这些函数改变数组后无法触发更新的问题。在Vue的官方文档中对这个也有说明：http://cn.vuejs.org/v2/guide/list.html#变异方法]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Vue原理解析之Virtual Dom]]></title>
      <url>%2F2017%2F02%2F08%2FVue%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90%E4%B9%8BVirtual-Dom%2F</url>
      <content type="text"><![CDATA[DOM是文档对象模型(Document Object Model)的简写，在浏览器中我们可以通过js来操作DOM，但是这样的操作性能很差，于是Virtual Dom应运而生。我的理解，Virtual Dom就是在js中模拟DOM对象树来优化DOM操作的一种技术或思路。 本文将对于Vue框架2.1.8版本中使用的Virtual Dom进行分析。 VNode对象一个VNode的实例对象包含了以下属性 tag: 当前节点的标签名 data: 当前节点的数据对象，具体包含哪些字段可以参考vue源码types/vnode.d.ts中对VNodeData的定义 children: 数组类型，包含了当前节点的子节点 text: 当前节点的文本，一般文本节点或注释节点会有该属性 elm: 当前虚拟节点对应的真实的dom节点 ns: 节点的namespace context: 编译作用域 functionalContext: 函数化组件的作用域 key: 节点的key属性，用于作为节点的标识，有利于patch的优化 componentOptions: 创建组件实例时会用到的选项信息 child: 当前节点对应的组件实例 parent: 组件的占位节点 raw: raw html isStatic: 静态节点的标识 isRootInsert: 是否作为根节点插入，被&lt;transition&gt;包裹的节点，该属性的值为false isComment: 当前节点是否是注释节点 isCloned: 当前节点是否为克隆节点 isOnce: 当前节点是否有v-once指令 VNode分类 VNode可以理解为vue框架的虚拟dom的基类，通过new实例化的VNode大致可以分为几类 EmptyVNode: 没有内容的注释节点 TextVNode: 文本节点 ElementVNode: 普通元素节点 ComponentVNode: 组件节点 CloneVNode: 克隆节点，可以是以上任意类型的节点，唯一的区别在于isCloned属性为true ... createElement解析1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192const SIMPLE_NORMALIZE = 1const ALWAYS_NORMALIZE = 2function createElement (context, tag, data, children, normalizationType, alwaysNormalize) &#123; // 兼容不传data的情况 if (Array.isArray(data) || isPrimitive(data)) &#123; normalizationType = children children = data data = undefined &#125; // 如果alwaysNormalize是true // 那么normalizationType应该设置为常量ALWAYS_NORMALIZE的值 if (alwaysNormalize) normalizationType = ALWAYS_NORMALIZE // 调用_createElement创建虚拟节点 return _createElement(context, tag, data, children, normalizationType)&#125;function _createElement (context, tag, data, children, normalizationType) &#123; /** * 如果存在data.__ob__，说明data是被Observer观察的数据 * 不能用作虚拟节点的data * 需要抛出警告，并返回一个空节点 * * 被监控的data不能被用作vnode渲染的数据的原因是： * data在vnode渲染过程中可能会被改变，这样会触发监控，导致不符合预期的操作 */ if (data &amp;&amp; data.__ob__) &#123; process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; warn( `Avoid using observed data object as vnode data: $&#123;JSON.stringify(data)&#125;\n` + &apos;Always create fresh vnode data objects in each render!&apos;, context ) return createEmptyVNode() &#125; // 当组件的is属性被设置为一个falsy的值 // Vue将不会知道要把这个组件渲染成什么 // 所以渲染一个空节点 if (!tag) &#123; return createEmptyVNode() &#125; // 作用域插槽 if (Array.isArray(children) &amp;&amp; typeof children[0] === &apos;function&apos;) &#123; data = data || &#123;&#125; data.scopedSlots = &#123; default: children[0] &#125; children.length = 0 &#125; // 根据normalizationType的值，选择不同的处理方法 if (normalizationType === ALWAYS_NORMALIZE) &#123; children = normalizeChildren(children) &#125; else if (normalizationType === SIMPLE_NORMALIZE) &#123; children = simpleNormalizeChildren(children) &#125; let vnode, ns // 如果标签名是字符串类型 if (typeof tag === &apos;string&apos;) &#123; let Ctor // 获取标签名的命名空间 ns = config.getTagNamespace(tag) // 判断是否为保留标签 if (config.isReservedTag(tag)) &#123; // 如果是保留标签,就创建一个这样的vnode vnode = new VNode( config.parsePlatformTagName(tag), data, children, undefined, undefined, context ) // 如果不是保留标签，那么我们将尝试从vm的components上查找是否有这个标签的定义 &#125; else if ((Ctor = resolveAsset(context.$options, &apos;components&apos;, tag))) &#123; // 如果找到了这个标签的定义，就以此创建虚拟组件节点 vnode = createComponent(Ctor, data, context, children, tag) &#125; else &#123; // 兜底方案，正常创建一个vnode vnode = new VNode( tag, data, children, undefined, undefined, context ) &#125; // 当tag不是字符串的时候，我们认为tag是组件的构造类 // 所以直接创建 &#125; else &#123; vnode = createComponent(tag, data, context, children) &#125; // 如果有vnode if (vnode) &#123; // 如果有namespace，就应用下namespace，然后返回vnode if (ns) applyNS(vnode, ns) return vnode // 否则，返回一个空节点 &#125; else &#123; return createEmptyVNode() &#125;&#125; 简单的梳理了一个流程图，可以参考下 patch原理patch函数的定义在src/core/vdom/patch.js中，我们先来看下这个函数的逻辑 patch函数接收6个参数： oldVnode: 旧的虚拟节点或旧的真实dom节点 vnode: 新的虚拟节点 hydrating: 是否要跟真是dom混合 removeOnly: 特殊flag，用于&lt;transition-group&gt;组件 parentElm: 父节点 refElm: 新节点将插入到refElm之前 patch的策略是： 如果vnode不存在但是oldVnode存在，说明意图是要销毁老节点，那么就调用invokeDestroyHook(oldVnode)来进行销毁 如果oldVnode不存在但是vnode存在，说明意图是要创建新节点，那么就调用createElm来创建新节点 当vnode和oldVnode都存在时 如果oldVnode和vnode是同一个节点，就调用patchVnode来进行patch 当vnode和oldVnode不是同一个节点时，如果oldVnode是真实dom节点或hydrating设置为true，需要用hydrate函数将虚拟dom和真是dom进行映射，然后将oldVnode设置为对应的虚拟dom，找到oldVnode.elm的父节点，根据vnode创建一个真实dom节点并插入到该父节点中oldVnode.elm的位置 这里面值得一提的是patchVnode函数，因为真正的patch算法是由它来实现的（patchVnode中更新子节点的算法其实是在updateChildren函数中实现的，为了便于理解，我统一放到patchVnode中来解释）。 patchVnode算法是： 如果oldVnode跟vnode完全一致，那么不需要做任何事情 如果oldVnode跟vnode都是静态节点，且具有相同的key，当vnode是克隆节点或是v-once指令控制的节点时，只需要把oldVnode.elm和oldVnode.child都复制到vnode上，也不用再有其他操作 否则，如果vnode不是文本节点或注释节点 如果oldVnode和vnode都有子节点，且2方的子节点不完全一致，就执行更新子节点的操作（这一部分其实是在updateChildren函数中实现），算法如下 分别获取oldVnode和vnode的firstChild、lastChild，赋值给oldStartVnode、oldEndVnode、newStartVnode、newEndVnode 如果oldStartVnode和newStartVnode是同一节点，调用patchVnode进行patch，然后将oldStartVnode和newStartVnode都设置为下一个子节点，重复上述流程 如果oldEndVnode和newEndVnode是同一节点，调用patchVnode进行patch，然后将oldEndVnode和newEndVnode都设置为上一个子节点，重复上述流程 如果oldStartVnode和newEndVnode是同一节点，调用patchVnode进行patch，如果removeOnly是false，那么可以把oldStartVnode.elm移动到oldEndVnode.elm之后，然后把oldStartVnode设置为下一个节点，newEndVnode设置为上一个节点，重复上述流程 如果newStartVnode和oldEndVnode是同一节点，调用patchVnode进行patch，如果removeOnly是false，那么可以把oldEndVnode.elm移动到oldStartVnode.elm之前，然后把newStartVnode设置为下一个节点，oldEndVnode设置为上一个节点，重复上述流程 如果以上都不匹配，就尝试在oldChildren中寻找跟newStartVnode具有相同key的节点，如果找不到相同key的节点，说明newStartVnode是一个新节点，就创建一个，然后把newStartVnode设置为下一个节点 如果上一步找到了跟newStartVnode相同key的节点，那么通过其他属性的比较来判断这2个节点是否是同一个节点，如果是，就调用patchVnode进行patch，如果removeOnly是false，就把newStartVnode.elm插入到oldStartVnode.elm之前，把newStartVnode设置为下一个节点，重复上述流程 如果在oldChildren中没有寻找到newStartVnode的同一节点，那就创建一个新节点，把newStartVnode设置为下一个节点，重复上述流程 如果oldStartVnode跟oldEndVnode重合了，并且newStartVnode跟newEndVnode也重合了，这个循环就结束了 如果只有oldVnode有子节点，那就把这些节点都删除 如果只有vnode有子节点，那就创建这些子节点 如果oldVnode和vnode都没有子节点，但是oldVnode是文本节点或注释节点，就把vnode.elm的文本设置为空字符串 如果vnode是文本节点或注释节点，但是vnode.text != oldVnode.text时，只需要更新vnode.elm的文本内容就可以 生命周期patch提供了5个生命周期钩子，分别是 create: 创建patch时 activate: 激活组件时 update: 更新节点时 remove: 移除节点时 destroy: 销毁节点时 这些钩子是提供给Vue内部的directives/ref/attrs/style等模块使用的，方便这些模块在patch的不同阶段进行相应的操作，这里模块定义在src/core/vdom/modules和src/platforms/web/runtime/modules2个目录中 vnode也提供了生命周期钩子，分别是 init: vdom初始化时 create: vdom创建时 prepatch: patch之前 insert: vdom插入后 update: vdom更新前 postpatch: patch之后 remove: vdom移除时 destroy: vdom销毁时 vue组件的生命周期底层其实就依赖于vnode的生命周期，在src/core/vdom/create-component.js中我们可以看到，vue为自己的组件vnode已经写好了默认的init/prepatch/insert/destroy，而vue组件的mounted/activated就是在insert中触发的，deactivated就是在destroy中触发的 实践在Vue里面，Vue.prototype.$createElement对应vdom的createElement方法，Vue.prototype.__patch__对应patch方法，我写了个简单的demo来验证下功能 See the Pen Vue Virtual Dom by zhulei (@JoeRay) on CodePen.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[git常用命令速查表]]></title>
      <url>%2F2016%2F12%2F18%2Fgit%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E9%80%9F%E6%9F%A5%E8%A1%A8%2F</url>
      <content type="text"><![CDATA[前言本文主要是用来记录一些在git管理的项目中常见的场景及其对应的命令，方便自己和他人使用的时候快速查询。如有不对，敬请指正。 查看某个git命令的帮助文档1git help [command] 查看各个文件的状态1git status clone一个仓库1git clone [url] 初始化一个仓库1git init 将文件放到暂存区1git add [file-name] 提交1git commit 停止跟踪文件并删除文件1git rm [file-name] 停止跟踪并删除已修改且添加到暂存区的文件1git rm -f [file-name] 停止跟踪但不删除文件1git rm --cached [file-name] 移动文件或修改文件名1git mv [old-name] [new-name] 显示已经放到暂存区的文件的修改1git diff --cached 显示未放到暂存区的文件的修改1git diff [path/to/file] 显示当前仓库的所有本地分支1git branch 显示当前仓库的所有远程分支1git branch -r 显示当前仓库的所有分支（包括本地和远程）1git branch -a 创建一个本地分支1git branch [branch-name] 切换到某个本地分支1git checkout [branch-name] 将某个分支合并到当前分支1git merge [branch-name] 删除已经被合并的分支1git branch -d [branch-name] 删除还未被合并的分支1git branch -D [branch-name] 合并代码后还未提交，此时希望撤销合并1git reset --hard HEAD 查看所有的提交1git log 查看所有提交及每个提交对应的代码diff1git log -p 查看所有提交，以及每个提交涉及的文件，以及这些文件删除/添加了多少行1git log --stat 查看当前工作目录与某个分支的差别1git diff [branch-name] 查看当前工作目录下的某个目录与某个分支的差别1git diff [branch-name] -- [path] 修改最后一次提交1git commit --amend 撤销已暂存的文件1git reset HEAD [file-name] 撤销对文件的修改1git checkout -- [file-name] 查看当前配置的远程仓库1git remote 查看当前配置的远程仓库和对应的地址1git remote -v 添加远程仓库1git remote add [remote-name] [url] 从远程仓库抓去数据1git fetch [remote-name] [branch-name] 推送数据到远程仓库1git push [remote-name] [branch-name] 查看某个远程仓库信息1git remote show [remote-name] 重命名远程仓库1git remote rename [old-name] [new-name] 删除某个远程仓库1git remote rm [remote-name] 显示已有的标签1git tag 搜索特定tag1git tag -l [keyword] 创建轻量级标签1git tag [tag-name] 创建含附注标签1git tag -a [tag-name] -m [msg] 给之前的某个提交加标签1git tag -a [tag-name] [hash] 查看某个标签的信息1git show [tag-name] 将标签推送到远程仓库1git push [remote-name] [tag-name] 将所有本地标签一次推送到远程仓库1git push [remote-name] --tags 将分支b衍合入分支a12git checkout bgit rebase a 切换到另一个分支前，你并不想把当前分支上的修改提交的话，可以使用储藏功能1git stash 显示所有储藏1git stash list 应用你的储藏1git stash apply [stash-name]]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[webpack入门指南]]></title>
      <url>%2F2016%2F09%2F25%2Fwebpack%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97%2F</url>
      <content type="text"><![CDATA[本文是一个简单的webpack入门教程，希望能够帮助webpack初学者快速上手。如有错误，敬请斧正。本文所有的demo都可以在webpack-demo里找到，git clone之后需要执行npm install安装所有依赖包。 简介webpack是一个模块打包工具，出自德国开发者Tobias Koppers之手，处理速度很快。在webpack看来，一切资源都可以是一个模块，不仅限于js文件。正是由于这些特点，使得webpack可以替代Grunt和Gulp，成为了目前业内最火的前端构建工具。 安装webpack可以安装到全局，也可以作为项目的依赖工具安装到项目中 123// 全局安装$ npm install -g webpack$ npm install -g webpack-dev-server 如果报没有权限的话，在命令前面加上sudo就可以了 123// 局部安装$ npm install --save-dev webpack$ npm install --save-dev webpack-dev-server 可以看到，我们在安装webpack的同时，也安装了webpack-dev-server。那么webpack-dev-server是什么呢？它是一个轻量级的基于express的node.js服务器，用来服务资源文件。不是必须的，但是建议一起安装。 命令行1$ webpack main.js bundle.js 以上是直接使用webpack命令行来进行打包的命令，把main.js构建成bundle.js，具体示例可以查看demo1，在文件夹中执行上方的命令即可。 webpack有一些参数是我们应该要知道的 webpack: 构建一次开发版本 webpack -p: 构建一次产品版本，与开发版本的区别是会对文件进行压缩 webpack -d: 添加source map webpack --watch: 监听文件的改动，持续增量构建 webpack --colors: 让命令行的输出更好看一点（实际使用zsh的命令行时发现并没有区别） 配置文件webpack还有很多强大的功能，这些都可以在命令行使用，但是如果都写在命令行，既不方便使用，也不能直观地反映各个配置项，这时候，就需要配置文件登场了。 webpack默认使用的配置文件名是webpack.config.js，也可以通过--config参数在命令行指定另一个命名的配置文件。配置文件其实也是一个模块，所有的构建信息都放在module.exports中。下面我们就来讲一讲各个重要的配置项。 以下各个示例请在各demo文件夹中执行webpack-dev-server进行查看 入口文件入口文件的配置项名称是entry，代表了webpack给整个项目进行打包的一个主入口，可以搭配output属性指定的输出文件来使用 12345678910111213141516171819202122232425// webpack.config.jsmodule.exports = &#123; entry: &apos;main.js&apos;, output: &#123; filename: &apos;bundle.js&apos; &#125;&#125;;// index.html&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Demo2&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script src=&quot;bundle.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;// main.jsdocument.write(&apos;&lt;h1&gt;Hello Webpack!&lt;/h1&gt;&apos;); 示例见demo2 多入口文件在多页的应用中，我们需要有多个入口文件，这在webpack中也是可以支持的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445// webpack.config.jsmodule.exports = &#123; entry: &#123; profile: &apos;./profile.js&apos;, feed: &apos;./feed.js&apos; &#125;, output: &#123; filename: &apos;[name].bundle.js&apos; &#125;&#125;;// feed.html&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Demo3-Feed&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script src=&quot;feed.bundle.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;// feed.jsdocument.write(&apos;&lt;h1&gt;Hello Feed!&lt;/h1&gt;&apos;);// profile.html&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Demo3-Profile&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script src=&quot;profile.bundle.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;// profile.jsdocument.write(&apos;&lt;h1&gt;Hello Profile!&lt;/h1&gt;&apos;); 示例见demo3，在demo3文件夹中启动webpack-dev-server，访问localhost:8080/profile.html和localhost:8080/feed.html查看效果。 LoadersLoaders顾名思义就是加载器，用于加载各种格式的文件，例如React使用的JSX，ES6和ES7，图片、CSS、JSON文件等，可谓是webpack中最核心的功能之一。官方文档中列出了所有可用的loaders。 loaders配置在module.exports中的module字段下（说起来有点绕，待会儿看代码就懂了），是一个数组，代表loader的集合，每一个loader有几个配置项： test: 正则表达式，用于匹配文件的路径，一般都直接用来匹配文件后缀，在复杂的场景下，可以针对同一类型的不同文件做不同处理 loader: loader的名称，实际使用时可以省略-loader的后缀（例如css-loader，可以写成css） include: 必须包含的文件路径 exclude: 不需要处理的文件路径 query: loader的额外设置选项 下面我介绍几个常用的loader。 CSS Loader先安装style-loader和css-loader。其中，style-loader用来向 HTML 页面中插入&lt;style&gt;，css-loader用来读取 css 文件。 1$ npm install --save-dev style-loader css-loader 然后在webpack.config.js中配置loader 123456789101112131415161718192021222324252627282930313233343536module.exports = &#123; entry: &apos;./main.js&apos;, output: &#123; filename: &apos;bundle.js&apos; &#125;, module: &#123; loaders: [ &#123; test: /\.css$/, loader: &apos;style!css&apos; &#125; ] &#125;&#125;;// index.html&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Demo4&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;Hello World!&lt;/h1&gt; &lt;script src=&quot;bundle.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;// a.cssh1 &#123;color: red;&#125;// main.jsrequire(&apos;./a.css&apos;); 示例见demo4，可以看到，多个loader之间用!连接。在本地用webpack-dev-server启动服务，访问localhost:8080可以看到h1中的字体颜色如a.css定义的那样显示红色 这个 demo 中的 css 是对全局生效的，如果需要只对当前模块生效，就要用到我们下面介绍的css module。 CSS Module近几年，模块化这个概念在前端被不断地被提及。模块化使得代码被分割成一个个更小的、独立的、可维护性更高的独立单元。相比于JS，CSS的模块化发展的相对慢一点。最近出现了一个叫做css modules的技术，在css模块中，所有的类名和动画名默认只对向前模块生效。webpack对css module提供了不错的支持，只需要在css-loader后面加上?module即可使用。如果要对全局生效，可以使用:global()，把选择器作为参数传入。 123456789101112131415161718192021222324252627282930313233343536373839404142434445// webpack.config.jsmodule.exports = &#123; entry: &apos;./main.js&apos;, output: &#123; filename: &apos;bundle.js&apos; &#125;, module: &#123; loaders: [ &#123; test: /\.css$/, loader: &apos;style!css?module&apos; &#125; ] &#125;&#125;;// index.html&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Demo5&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;foo&quot;&gt;Foo&lt;/div&gt; &lt;div class=&quot;bar&quot;&gt;Bar&lt;/div&gt; &lt;script src=&quot;bundle.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;// a.css.foo &#123;color: red;&#125;:global(.bar) &#123; color: green;&#125;// main.jsvar style = require(&apos;./a.css&apos;);document.write(&apos;&lt;div class=&apos; + style.foo + &apos;&gt;Module - Foo&lt;/div&gt;&apos;);document.write(&apos;&lt;div class=&quot;bar&quot;&gt;Module - Bar&lt;/div&gt;&apos;); 需要注意的是，在main.js中使用时，必须用变量style.foo，直接写成class=&quot;foo&quot;是不会生效的，因为a.css中的.foo的类名被编译了，所以导出的style.foo将不等于foo。 示例代码见demo5。在 demo5 的目录下执行webpack-dev-server，在浏览器中打开localhost:8080，可以看到对应的效果。 Url Loader先安装url-loader和file-loader 1$ npm install --save-dev url-loader file-loader 注意，url-loader对file-loader有依赖，但是安装url-loader时不会自动安装file-loader，这里我暂时没有花时间去了解原因，先都手动安装吧。如果不安装file-loader，超过limit大小的文件将无法加载。 url-loader是一个文件加载器，我们可以给他设定一个limit，用来限定文件大小，文件小于这个大小时会被转换成一个Data Url，反之转换成普通url表示资源路径。我们常用url-loader来加载图片。 123456789101112131415161718192021222324252627282930313233343536373839// webpack.config.jsmodule.exports = &#123; entry: &apos;./main.js&apos;, output: &#123; filename: &apos;bundle.js&apos; &#125;, module: &#123; loaders: [ &#123; test: /\.(png|jpg)$/, loader: &apos;url-loader?limit=8192&apos; &#125; ] &#125;&#125;;// index.html&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Demo6&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script src=&quot;bundle.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;// main.jsvar img1 = new Image();img1.src = require(&apos;./webpack.png&apos;);document.body.appendChild(img1);var img2 = new Image();img2.src = require(&apos;./wade.jpg&apos;);document.body.appendChild(img2); 示例代码见demo6。在demo6目录下运行webpack-dev-server，在浏览器中访问localhost:8080，审查元素可以看到，8k以下的图片使用了Data Url，8k以上的图片使用的是资源地址。 Babel Loader现如今，ES6、React可谓是红透半边天，说起ES6、React，就不得不提Babel了。Babel是一个 Javascript 编译工具，可以让你现在就能使用目前还未被浏览器完全支持的下一代JS（ES6/ES7）,或是基于 JS 进行扩展的 JSX 等。 我们先安装需要的包 1$ npm install --save-dev babel-core babel-loader babel-preset-es2015 babel-preset-react react react-dom 其中，babel-core是babel的核心功能，babel-loader是webpack使用的babel加载器，babel-preset-es2015和babel-preset-react是babel用来解析ES6和JSX的包，react和react-dom是开发react的依赖包。 1234567891011121314151617181920212223242526272829303132333435363738394041424344// webpack.config.jsmodule.exports = &#123; entry: &apos;./main.jsx&apos;, output: &#123; filename: &apos;bundle.js&apos; &#125;, module: &#123; loaders: [ &#123; test: /\.js[x]?$/, exclude: /node_modules/, loader: &apos;babel-loader&apos;, query: &#123; presets: [&apos;es2015&apos;, &apos;react&apos;] &#125; &#125; ] &#125;&#125;;// index.html&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Demo7&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; &lt;script src=&quot;bundle.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;// main.jsximport React from &apos;react&apos;;import &#123;render&#125; from &apos;react-dom&apos;;render( &lt;h1&gt;Hello world!&lt;/h1&gt;, document.querySelector(&apos;#root&apos;)); 可以看到，在这个配置中，我们把babel-loader的配置写在query字段中。其实也可以直接写在loader字段中，loader: &#39;babel-loader?presets[]=es2015&amp;presets[]=react&#39;，但是这样就不是太清晰了，建议配置比较长时拿出来放到query字段中去。 示例代码见demo7，在demo7目录下执行webpack-dev-server，在浏览器中访问localhost:8080查看效果。 Pluginsplugins是webpack中另一个非常重要且又用的配置，它与loaders的区别在于，loader是用来加载文件的，会逐个文件处理，而plugins是作为webpack功能的补充，整个构建过程都在持续发挥作用。下面我来给大家介绍几个常用的插件。 UglifyJS Plugin这个插件估计很多人看名字就猜出来了，是用于压缩 JS 代码的。它是webpack的内置插件，不需要安装就可以使用。 直接上代码吧: 123456789101112131415161718192021222324252627282930313233// webpack.config.jsvar webpack = require(&apos;webpack&apos;);var UglifyJsPlugin = webpack.optimize.UglifyJsPlugin;module.exports = &#123; entry: &apos;./main.js&apos;, output: &#123; filename: &apos;bundle.js&apos; &#125;, plugins: [ new UglifyJsPlugin() ]&#125;;// index.html&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Demo8&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script src=&quot;bundle.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;// main.jsvar name = &apos;JoeRay61&apos;;var age = 24;document.write(&apos;My name is &apos; + name + &apos;, I\&apos;m &apos; + age + &apos; years old.&apos;); 示例代码见demo8。在demo8目录下执行webpack-dev-server，在浏览器中访问localhost:8080，打开开发这工具，可以看到bundle.js的代码被压缩成了一行，变量名也被替换了，说明插件生效了。 1!function(r)&#123;function e(t)&#123;if(o[t])return o[t].exports;var n=o[t]=&#123;exports:&#123;&#125;,id:t,loaded:!1&#125;;return r[t].call(n.exports,n,n.exports,e),n.loaded=!0,n.exports&#125;var o=&#123;&#125;;return e.m=r,e.c=o,e.p=&quot;&quot;,e(0)&#125;([function(r,e)&#123;var o=&quot;JoeRay61&quot;,t=24;document.write(&quot;My name is &quot;+o+&quot;, I&apos;m &quot;+t+&quot; years old.&quot;)&#125;]); Feature Flags想象这样一种场景，我们希望在开发环境中在代码中输出一些调试信息，那么如何在webpack中实现呢。这时候就需要用上Feature Flags。它是借由webpack的自定义插件机制实现的全局环境变量，我们可以在代码中判这些全局变量的值来实现定制化的功能。 12345678910111213141516171819202122232425262728293031323334// webpack.config.jsvar webpack = require(&apos;webpack&apos;);var flags = new webpack.DefinePlugin(&#123; __PROD__: JSON.stringify(JSON.parse(process.env.PROD || &apos;false&apos;))&#125;);module.exports = &#123; entry: &apos;./main.js&apos;, output: &#123; filename: &apos;bundle.js&apos; &#125;, plugins: [flags]&#125;;// index.html&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Demo9&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script src=&quot;bundle.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;// main.jsdocument.write(&apos;&lt;h1&gt;Hello world!&lt;/h1&gt;&apos;);if (!__PROD__) &#123; document.write(&apos;&lt;p&gt;it is dev version&lt;/p&gt;&apos;);&#125; 示例代码见demo9。进入demo9目录，分别执行PROD=1 webpack-dev-server和webpack-dev-server，在浏览器中访问localhost:8080，可以看到区别。 Hot Module ReplacementHMR是webpack中一个激动人心的功能，中文直译叫模块热替换，是指配合webpack-dev-server的服务器，在你修改了项目的模块之后，不需要手动刷新页面，即可以看到更新后的效果，有效地提升了开发效率。 配合webpack-dev-server，我们有2种方式可以启用该功能： 在命令中中webpack-dev-server命令后面追加--hot和--inline参数 --hot: 添加HMR插件，将服务器切换到 hot 模式 --inline: 将webpack-dev-server的 runtime 加入到打包后的文件中 --hot --inline: 当这两个参数并存时，会额外添加一个webpack/hot/dev-server的entry 配置webpack.config.js 添加new webpack.HotModuleReplacementPlugin()插件 添加webpack/hot/dev-server和webpack-dev-server/client?http://localhost:8080这2个entry 针对第2中方式我们来测试一下： 12345678910111213141516171819202122232425262728293031323334// webpack.config.jsvar webpack = require(&apos;webpack&apos;);module.exports = &#123; entry: [ &apos;webpack/hot/dev-server&apos;, &apos;webpack-dev-server/client?http://localhost:8080&apos;, &apos;./main.js&apos; ], output: &#123; filename: &apos;bundle.js&apos; &#125;, plugins: [ new webpack.HotModuleReplacementPlugin() ]&#125;;// index.html&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Demo10&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script src=&quot;bundle.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;// main.jsdocument.write(&apos;&lt;h1&gt;Hello world!&lt;/h1&gt;&apos;); 注意，测试过程中我发现，如果原来是全局安装的webpack-dev-server，必须要在项目中局部安装webpack-dev-server，否则启动服务器时会报错安装命令$ npm install --save-dev webpack-dev-server 示例代码见demo10。在demo10目录下，执行webpack-dev-server，在浏览器中查看localhost:8080，发现输出Hello world!，这时候不要关闭服务器，直接修改main.js的代码，保存后查看浏览器效果，发现虽然没有手动刷新页面，但是效果已经出来了。 Commons Chunk Plugin当几个不同的脚本有公共的部分时，我们可以把公共部分抽出来放到一个单独的文件中。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// webpack.config.jsvar webpack = require(&apos;webpack&apos;);module.exports = &#123; entry: &#123; index: &apos;./index.js&apos;, main: &apos;./main.js&apos; &#125;, output: &#123; filename: &apos;[name].bundle.js&apos; &#125;, plugins: [ new webpack.optimize.CommonsChunkPlugin(&apos;common.js&apos;) ]&#125;;// index.html&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Demo11&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script src=&quot;common.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;index.bundle.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;main.bundle.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;// index.jsvar data = require(&apos;./data&apos;);document.write(&apos;&lt;p&gt;foo is &apos; + data.foo + &apos;&lt;/p&gt;&apos;);// main.jsvar data = require(&apos;./data&apos;);document.write(&apos;&lt;p&gt;bar is &apos; + data.bar + &apos;&lt;/p&gt;&apos;);// data.jsvar data = &#123; foo: 123, bar: 456&#125;;module.exports = data; 具体示例见demo11。在demo11目录下执行webpack-dev-server，在浏览器中访问localhost:8080，打开开发者工具，发现data.js被抽出单独放到了common.js中。 总结本文是我自己学习webpack的一个笔记，我把它记录下来，希望能给其他的webpack初学者提供一点帮助，谢谢观看，欢迎交流！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ES6学习笔记之模块]]></title>
      <url>%2F2016%2F06%2F29%2FES6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E6%A8%A1%E5%9D%97%2F</url>
      <content type="text"><![CDATA[简介在当今的Javascript程序中，模块的作用不言而喻，目前广泛应用的主要有AMD（浏览器端）和CommonJS（服务器端）。但是Javascript一直没有在语言层面支持模块，直到ES6的出现。相信在不久的将来，ES6的模块一定会全面取代AMD和CommonJS。 exportES6的模块提供了2个新的语法，分别是export和import。export就是模块用来对外暴露数据的接口，具体用法如下。 export let a = 1; export class A {}; export let b = () =&gt; {}; 输出多个数据时不必分别export，可以用一个export统一输出 let a = 1; class A {}; let b = () =&gt; {}; export {a, A, b}; import与export对应，import就是ES6的模块用来引入数据的命令。 我们先来建立一个数据数据的文件a.js: // a.js let a = 1; export {a}; 然后再创建一个b.js用来导入a.js暴露的数据 // b.js import {a} from &apos;./a&apos;; console.log(a); // 1 如果要导入的模块暴露了很多变量，而你又不想一个一个地去写要import的数据时，可以使用* // b.js import * as obj from &apos;./a&apos;; console.log(obj.a); // 1 需要注意的是，import使用的变量名必须跟export使用的变量名一致 renameimport和export的时候都是可以对变量进行重命名的 // a.js，用于export变量a，但是导出时将a改名为aa let a = 1; export {a as aa}; // b.js用于import从a.js导出的数据aa，但是在导入时将aa改名为b import {aa as b} from &apos;./a&apos;; console.log(a); // undefined console.log(aa); // undefined console.log(b); // 1 defaultexport时可以指定要默认导出的数据 // a.js let a = 1; let aa = 2; export default a; export {aa}; // 也可以写成 export {a as default, aa}; 导入默认数据时需要这样写： // b.js import x from &apos;./a&apos;; console.log(x); // 1 细心的同学可能发现了，这里import的时候使用的变量名是x，这就是default的特权了，导入时使用的变量名可以随便取，不需要跟导出时的变量名一致。 另外，如果同时要导入default和其他数据时该怎么写呢？ // b.js import x, {aa} from &apos;./a&apos;; console.log(x); // 1 console.log(aa); // 2 ES6模块加载实质CommonJS加载模块时，加载的是值的副本，而ES6的模块加载，加载的是值的引用。还是直接上代码吧 // lib.js export let x = 1; export let changeX = () =&gt; { x++; }; // a.js import {x, changeX} from &apos;./lib&apos;; changeX(); console.log(x); // b.js import {x, changeX} from &apos;./lib&apos;; changeX(); console.log(x); // index.js import &apos;./a&apos;; import &apos;./b&apos;; 执行index.js输出的值是2和3，这就说明a.js和b.js执行的时候改变的都是lib.js里的x，而不是各自操作了一份副本 注意点 ES6的模块采用严格模式，无论你是否申明use strict; import具有提升效果，即使写在文件的后面，也会被提到头部首先执行 本文为学习过程中整理，如有问题欢迎交流~]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ES6学习笔记之Classes]]></title>
      <url>%2F2016%2F06%2F16%2FES6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8BClasses%2F</url>
      <content type="text"><![CDATA[简介ES6的Classes是在原型链继承的基础上，由语言本身提供的语法糖，并非是一种全新的继承模式。这使得Javascript有一种更加简洁清晰的方式来实现类的创建和继承。 语法话不多说，直接上代码。 定义Classclass Person { constructor(name, age) { this.name = name; this.age = age; } } 继承Classclass Student extends Person { constructor(name, age, grade) { super(name, age); this.grade = grade; } } 原型链方法class Person { constructor(name, age) { this.name = name; this.age = age; } speak() { console.log(&apos;something...&apos;); } } speak就是原型链方法，不需要再繁琐地使用prototype来定义，直接定义在class内部即可。 静态方法class Person { constructor(name, age) { this.name = name; this.age = age; } static getClassName() { return &apos;Person&apos;; } } console.log(Person.getClassName()); // Person 静态方法直接用类名来调用就可以了，熟悉面向对象编程的同学应该都不陌生。 Species某些情况下，类里面有一个方法返回的是类的实例，但是你可能希望返回父类的示例，这时候可以使用species pattern来达到目的。 举个栗子，你实现了一个类叫做MyArray，继承自Array，如果你不使用species pattern，那么调用map方法将会返回MyArray的实例，如果使用了species pattern则能够返回Array的实例。 class MyArray extends Array { static get [Symbol.species]() { return Array; } } var a = new MyArray(1,2,3); var mapped = a.map(x =&gt; x * x); console.log(mapped instanceof MyArray); // false console.log(mapped instanceof Array); // true Mixinmixin是类的模板。在EcmaScript中，一个类不能继承多个类。这样有些需求就不是很方便。为了解决这个问题，可以使用mixin。 var Bar = Sub =&gt; class extends Sub { bar() {} }; var Baz = Sub =&gt; class extends Sub { baz() {} }; class Person { speak() {} } class Student extends Bar(Baz(Person)) {} 这样，Student就可以继承Bar、Baz和Person3个基类了。 特点提升以前使用function来定义类的时候，我们可以在定以前先使用new，由于JS语言的变量提升特性，这样写不会有任何问题，示例如下： var joe = new Person(&apos;joe&apos;, 23); function Person(name, age) { this.name = name; this.age = age; } 如果使用class来定义类，则必须在定义后才能使用new来进行对象的实例化，如果先new则会报错 var joe = new Person(&apos;joe&apos;, 23); // ReferenceError class Person { constructor(name, age) { this.name = name; this.age = age; } } 严格模式（strict mode）类声明和类表达式都是在严格模式下执行的。 类表达式跟function一样，class也可以使用表达式来定义。类表达式可以命名也可以匿名。当类表达式有命名时，该命名仅作为类内部使用。 var Person = class Man { getName() { return Man.name; } }; var p = new Person(); console.log(p.getName()); // Man console.log(Man); // ReferenceError: Man is not defined 参考资料 Classes http://exploringjs.com/es6/ch_classes.html]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ES6学习笔记之箭头函数]]></title>
      <url>%2F2016%2F04%2F26%2FES6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%2F</url>
      <content type="text"><![CDATA[JS中的箭头箭头在JS里并不算是个新鲜的玩意儿，一直以来，JS都支持--&gt;这样的箭头。 很早的时候有些浏览器还不支持JS，当时的人们为了兼容这些浏览器，需要这样写JS: &lt;script language=&quot;javascript&quot;&gt; &lt;!-- alert(&apos;Joe&apos;); // --&gt; &lt;/script&gt; 这段代码在不支持JS的浏览器里会被解读成2个未知标签和一段html注释。在支持JS的浏览器里，JS引擎会把&lt;!--和--&gt;看成是单行注释的开始。需要说明的是，--&gt;仅仅是在一行的开头才能表示这一行是注释，其余情况--&gt;是一个操作符，表示goes to的含义。 function countdown(n) { while (n --&gt; 0) { alert(n); } } 这段代码确实能够正常运行哦。当你给countdown函数传入一个大于0的参数时，这个循环能够一直运行，直到n变为0为止。 此箭头非彼箭头，以上讲述的--&gt;并不是我们今天要讲的主角，大家权当拓展下JS知识，下面让我们进入正题。 特性介绍箭头函数是ES6新增的特性之一，它为JS这门语言提供了一种全新的书写函数的语法。 // ES5 var double = nums.map(function (v) { return 2 * n; }); // ES6 var double = nums.map(v =&gt; 2 * n); 箭头函数简化了原先的函数语法，不需要再写function，如果函数体只有一行代码的话连return都不用写，这个特性对于热衷于简化流程和工作的程序员来说相当对胃口。 使用箭头函数有几个注意点： 函数体箭头函数支持两种模式的函数体写法，我们姑且叫他简洁函数体和块级函数体。 // 简洁函数体 var fn = x =&gt; x * x; // 块级函数体 var fn = (x, y) =&gt; {return x + y;}; 简介函数体默认会把表达式的结果返回，块级函数体需要手动return。如果想要返回一个对象又想使用简洁函数体的话，需要这么写： var fn = () =&gt; ({}); fn(); // {} 如果写成var fn = () =&gt; {};，那么执行fn()只能返回undefined。 this用function生成的函数会定义一个自己的this，而箭头函数没有自己的this，而是会和上一层的作用域共享this。 function Person() { this.age = 0; var self = this; setTimeout(function () { self.age++; console.log(self.age); }, 1000); } var p = new Person(); 这段代码里，setTimeout的参数function中需要操作外层的age属性，必须要把this赋值给self，然后通过self来获取到age 如果使用箭头函数则省事很多，代码如下： function Person() { this.age = 0; setTimeout(() =&gt; { this.age++; console.log(this.age); }, 1000); } var p = new Person(); apply &amp; call由于箭头函数已经绑定了this的值，即使使用apply或者call也不能只能起到传参数的作用，并不能强行改变箭头函数里的this。 var adder = { x: 1, add1: function (y) { var fn = v =&gt; v + this.x; return fn(y); }, add2: function (y) { var fn = v =&gt; v + this.x; var whatever = { x: 2 }; return fn.call(whatever, y); } }; adder.add1(1); // 2 adder.add2(1); // 仍然是2 arguments普通函数里arguments代表了调用时传入的参数，但是箭头函数不然，在箭头函数中无法使用arguments 当然，ES6中也有办法可以让箭头函数像普通函数一样使用类似于arguments这样的类数组对象 var fn = (...rest) =&gt; rest[0]; fn(2); // 2 ...rest也是ES6的一个新特性，之后会介绍。 不能被new箭头函数不能与new关键字一起使用，会报错 var Fn = () =&gt; { this.a = 1; }; var f = new Fn(); // Error 使用场景在我看来，箭头函数几乎可以完全取代function，除非是函数需要进行递归或者需要可变的this对象，其他场景我认为都可以使用箭头函数。 参考资料 ES6 In Depth: Arrow functions Arrow functions]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[初探WebRTC]]></title>
      <url>%2F2015%2F04%2F08%2F%E5%88%9D%E6%8E%A2WebRTC%2F</url>
      <content type="text"><![CDATA[##简介 WebRTC is a new front in the long war for an open and unencumbered web. 这句话是JavaScript之父Brendan Eich对于WebRTC的评价，大致意思是『WebRTC是争取开放和无阻碍Web的漫长战争中一条新战线』。 那么WebRTC到底是一种什么样的技术呢？WebRTC是一个免费的开放项目，提供了几个简单的API让浏览器、手机平台还有其他设备通过一个通用的协议进行实时通信，帮助开发者开发出丰富而且高质量的跨平台实时通信应用。 本文的目的就是通过简洁的介绍和引导让开发者了解WebRTC的工作流程并能够快速上手开发WebRTC应用。 ##API MediaStream(getUserMedia) MediaStream表示一段多媒体流，获取多媒体流的一个简单方式就是通过 getUserMedia函数，该函数可以调用设备的摄像头和麦克风，并拿到这些硬件生成的多媒体流。这些多媒体流可以输出到video标签或者一个RTCPeerConnection。 getUserMedia接受3个参数： 一个限制对象，用于指定接受的流 获取stream成功后的回调函数，被调用时能获取到对应的流 获取stream失败后的回调函数，被调用时能获取到一个错误对象 具体用法如下所示： 123456789101112var getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia; var constraints = &#123;video: true&#125;; getUserMedia(constraints, function (stream) &#123; var video = document.querySelector(&quot;video&quot;); //URL.createObjectURL方法把stream转换成blob，作为video的src属性进行播放 video.src = window.URL.createObjectURL(stream); video.play(); &#125;, function (error) &#123; console.log(error); &#125;); RTCPeerConnection RTCPeerConnection帮我们做了很多事情，我们只需要把RTCPeerConnection理解成一种p2p传输音视频数据的通道，但是我们仍然还需要服务器来为我们传递消息，因为在建立p2p之前需要先互相交换session、网络配置、媒体适配等信息。另外，WebRTC还需要服务器帮助完成NAT穿越，以及在p2p建立失败的时候作为中转服务器。具体用法将在流程讲解中说明。 RTCDataChannel WebRTC除了支持视频和音频流之外，还支持其他类型的数据。RTCDataChannel用于点到点的任意数据交换，具有低延迟和高吞吐量的特点。RTCDataChannel必须建立在RTCPeerConnnection之上，没办法单独工作。 这个API潜在的应用场景很多，例如： 游戏 远程桌面应用 实时文字聊天 文件传输 创建一个RTCDataChannel的方式如下： 123 var RTCPeerConnection = webkitRTCPeerConnection || mozRTCPeerConnection;var peerConn = new RTCPeerConnection(); var dc = peerConn.createDataChannel(&quot;label&quot;); ##流程讲解 看完上面的内容，大家应该还是处于云里雾里的状态，不知道WebRTC应用要如何开发，3个API如何配合使用。没关系，这里才是重点，看完这一段，相信你的所有疑惑就都解开了。 要用WebRTC建立一个p2p通道需要经历2个步骤： 获得本机SDP描述符并交换 A、B均实例化一个RTCPeerConnection(以下简称rpcA和rpcB),调用rpcA的createOffer()方法建立一个offer信令，并且拿到A的SDP 通过rpcA的setLocalDescription()方法设置A机器的本地描述 A通过服务器将offer信令发给B B接收到A的offer信令，通过rpcB的setRemoteDescription()方法设置远程机器（即A）的描述 B调用rpcB的createAnswer()方法建立一个answer信令，并且拿到B的SDP 通过rpcB的setLocalDescription()方法设置B机器的本地描述 B通过服务器将answer信令发送给A A接收到B的answer信令，通过rpcA的setRemoteDescription()方法设置远程机器B的描述 这个过程完成后，A和B就都拿到各自的SDP描述符了 通过ICE框架连接两段主机的网络地址 ICE框架具体内容我不清楚，咱们姑且先了解在WebRTC中如何使用，对ICE感兴趣的同学可以自行谷歌。 在实例化RTCPeerConnection对象的时候可以传入ICE服务器的地址，我们可以使用谷歌提供的『stun:stun.l.google.com:19302』或者Mozilla提供的『stun:stun.services.mozilla.com』，代码如下： 12var configuration = &#123;iceServers: [&#123;url: &quot;stun:stun.l.google.com:19302&quot;&#125;]&#125;;var rpc = new RTCPeerConnection(configuration); 在rpc上绑定onicecandidate事件的回调函数，当网络候选可用时这个函数会被调用，在这个回调函数中，本机可以拿到ice candidate信令，然后通过服务器发给远程机器，远程机器通过自己的rpc实例的addIceCandidate()方法添加，同样地，远程机器也应该将自己的ice candidate信令通过服务器发送给本机。 当双方的ice candidate交换完成时，连接就建立成功了，可以在rpc示例上调用addStream()来添加流，另一边通过绑定onaddstream事件就可以获取到传过去的流。 服务器通信部分，没有规定必须要用某种协议，所以只要能在两边传输消息的技术可以使用，例如WebSocket、XHR等，大家自行选择即可。##示例 本来想自己写个例子给大家参考的，后来发现网上有个非常棒的实例教程，我就直接上地址了https://bitbucket.org/webrtc/codelab ##小结 写这篇文章的目的是为了让学习WebRTC的同学能够快速上手，对WebRTC技术有个整体的概念，所以文章写的比较简短，专注于讲解WebRTC的运作流程，对一些相关技术，比如ICE、SDP等没有深入探讨（当然我也不太懂）。如果你想快速上手制作WebRTC应用，看完这篇文章再对着codelab提供的例子一步一步跟着做应该就没问题了。Good luck! 参考资料 http://www.html5rocks.com/en/tutorials/webrtc/basics/ http://www.webrtc.org/ http://www.w3.org/TR/webrtc/ https://developer.mozilla.org/en-US/docs/Glossary/WebRTC]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Javascript实现图片的预加载功能]]></title>
      <url>%2F2014%2F09%2F21%2FJavascript%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E7%9A%84%E9%A2%84%E5%8A%A0%E8%BD%BD%E5%8A%9F%E8%83%BD%2F</url>
      <content type="text"><![CDATA[最近要用javascript做一个动画功能，为了确保动画在播放的时候能够顺利和平滑，我需要对所用到的图片素材进行预加载，下面跟大家分享一下我实现这个功能的过程 ##单图片预加载##目前最常见的一种实现方式如下1234567891011121314function preloadImg(url) &#123; var img = new Image(); img.src = url; if(img.complete) &#123; //接下来可以使用图片了 //do something here &#125; else &#123; img.onload = function() &#123; //接下来可以使用图片了 //do something here &#125;; &#125;&#125; 首先实例化一个Image对象赋值给img，然后设置img.src为参数url指定的图片地址,接着判断img的complete属性，如果本地有这张图片的缓存，则该值为true，此时我们可以直接操作这张图片，如果本地没有缓存，则该值为false，此时我们需要监听img的onload事件，把对img的操作放在onload的回调函数里面，经过测试，这种方案基本能够兼容目前所有浏览器 ##多图片预加载##很多场景下，单图片预加载并不能满足我们的需求，因为像动画这种功能通常都会有很多的图片素材，接下来我们就在原来单图片预加载的基础上来改进我们的函数1234567891011121314151617181920212223function preloadImg(list) &#123; var imgs = arguments[1] || [], //用于存储预加载好的图片资源 fn = arguments.cal lee; if(list.length == 0) &#123; return imgs; &#125; var img = new Image(); img.src = list[0]; if(img.complete) &#123; imgs.push(img); list.shift(); fn(list, imgs); &#125; else &#123; img.onload = function() &#123; imgs.push(img); list.shift(); fn(list, imgs); &#125;; &#125;&#125;var list = [......], //此处省略一万个字符 imgs = preloadImg(); 因为帧动画可能需要保证每一帧动画所用的图片的顺序，所以我在这段代码中使用递归的方式，在上一张加载完成之后再去加载下一张图片，每加载一张图片，就把这张图片资源存储到imgs数组中，并且把这张图片的地址从地址数组list中去掉，当list中已经没有地址的时候跳出递归，并返回imgs数组设想很美好，现实很残酷，这段代码有2个不能忍受的问题 首先，我很有可能拿不到最后返回的imgs数组，因为只要有图片在本地没有缓存，imgs的存储操作都会放到onload的回调事件中，而事件监听也属于javascript中异步操作的一种，在绑定完onload事件的回调函数后，preloadImg函数就执行结束了，没有任何返回值，外部imgs变量接收到的值为undefined，只有在所有图片都有本地缓存的情况下，外部imgs变量才能顺利拿到存储了全部预加载图片资源的数组 在加载完一张图片之后才去加载下一张，整个预加载图片的过程所需要的时间相对会比较长，用户体验会降低，而且本来异步操作具体速度快的特性，这样的实现方式等于完全弃置了onload异步的这个特性##多图片预加载（改进版）##这次我们直接把一个空数组作为参数传进函数，图片全部存储到这个数组里面，下面是改进后的函数代码（假设我们可以使用jQuery）123456789101112131415161718192021222324252627282930313233343536373839function preloadImg(list,imgs) &#123; var def = $.Deferred(), len = list.length; $(list).each(function(i,e) &#123; var img = new Image(); img.src = e; if(img.complete) &#123; imgs[i] = img; len--; if(len == 0) &#123; def.resolve(); &#125; &#125; else &#123; img.onload = (function(j) &#123; return function() &#123; imgs[j] = img len--; if(len == 0) &#123; def.resolve(); &#125; &#125;; &#125;)(i); img.onerror = function() &#123; len--; console.log(&apos;fail to load image&apos;); &#125;; &#125; &#125;); return def.promise();&#125;var list = [......], //此处省略一万个字符 imgs = [];$.when(preloadImg(list, imgs)).done( function() &#123; //预加载结束 //do something here &#125;); 在分别给每一个img绑定onload的回调函数时采用了闭包的方式，目的是为了保存住当前的递增变量i，要是不这么做，结果将会是list地址中没有本地缓存的图片都存储到imgs的最后一个元素上这次每载入一张图片，我们并没有把这张图片的地址从list数组中去掉，这样后续需要使用list数组的数据时就能够顺利获取到 thx for reading, hope u enjoy]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[浅谈Javascript中Promise对象的实现]]></title>
      <url>%2F2014%2F09%2F20%2F%E6%B5%85%E8%B0%88Javascript%E4%B8%ADPromise%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9E%E7%8E%B0%2F</url>
      <content type="text"><![CDATA[很多做前端的朋友应该都听说过Promise（或者Deferred）对象，今天我就讲一下我对Promise的认识 ##What？##Promise是CommonJS的规范之一，拥有resolve、reject、done、fail、then等方法，能够帮助我们控制代码的流程，避免函数的多层嵌套。如今异步在web开发中越来越重要，对于开发人员来说，这种非线性执行的编程会让开发者觉得难以掌控，而Promise可以让我们更好地掌控代码的执行流程,jQuery等流行的js库都已经实现了这个对象，年底即将发布的ES6也将原生实现Promise ##Why##想象这样一个场景，两个异步请求，第二个需要用到第一个请求成功的数据，那么我们代码可以这样写1234567891011ajax(&#123; url: url1, success: function(data) &#123; ajax(&#123; url: url2, data: data, success: function() &#123; &#125; &#125;); &#125; &#125;); 如果继续下去在回调函数中进行下一步操作，嵌套的层数会越来越多。我们可以进行适当的改进，把回调函数写到外面12345678910111213141516function A() &#123; ajax(&#123; url: url1, success: function(data) &#123; B(data); &#125; &#125;); &#125; function B(data) &#123; ajax(&#123; url: url2, success: function(data) &#123; ...... &#125; &#125;); &#125; 即使是改写成这样，代码还是不够直观，但是如果有了Promise对象，代码就可以写得非常清晰，一目了然，请看 1new Promise(A).done(B); 这样函数B就不用写在A的回调中了 ##How##目前的ES标准中还未支持Promise对象，那么我们就自己动手，丰衣足食吧。思路大致是这样的，用2个数组(doneList和failList)分别存储成功时的回调函数队列和失败时的回调队列 state: 当前执行状态，有pending、resolved、rejected3种取值 done: 向doneList中添加一个成功回调函数 fail: 向failList中添加一个失败回调函数 then: 分别向doneList和failList中添加回调函数 always: 添加一个无论成功还是失败都会调用的回调函数 resolve: 将状态更改为resolved,并触发绑定的所有成功的回调函数 reject: 将状态更改为rejected,并触发绑定的所有失败的回调函数 when: 参数是多个异步或者延迟函数，返回值是一个Promise兑现，当所有函数都执行成功的时候执行该对象的resolve方法，反之执行该对象的reject方法下面是我的具体实现过程：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768var Promise = function() &#123; this.doneList = []; this.failList = []; this.state = &apos;pending&apos;;&#125;;Promise.prototype = &#123; constructor: &apos;Promise&apos;, resolve: function() &#123; this.state = &apos;resolved&apos;; var list = this.doneList; for(var i = 0, len = list.length; i &lt; len; i++) &#123; list[0].call(this); list.shift(); &#125; &#125;, reject: function() &#123; this.state = &apos;rejected&apos;; var list = this.failList; for(var i = 0, len = list.length; i &lt; len; i++)&#123; list[0].call(this); list.shift(); &#125; &#125;, done: function(func) &#123; if(typeof func === &apos;function&apos;) &#123; this.doneList.push(func); &#125; return this; &#125;, fail: function(func) &#123; if(typeof func === &apos;function&apos;) &#123; this.failList.push(func); &#125; return this; &#125;, then: function(doneFn, failFn) &#123; this.done(doneFn).fail(failFn); return this; &#125;, always: function(fn) &#123; this.done(fn).fail(fn); return this; &#125;&#125;;function when() &#123; var p = new Promise(); var success = true; var len = arguments.length; for(var i = 0; i &lt; len; i++) &#123; if(!(arguments[i] instanceof Promise)) &#123; return false; &#125; else &#123; arguments[i].always(function() &#123; if(this.state != &apos;resolved&apos;)&#123; success = false; &#125; len--; if(len == 0) &#123; success ? p.resolve() : p.reject(); &#125; &#125;); &#125; &#125; return p;&#125; ##Improve##目前只是实现了Promise的基础功能，但仍然还有无法处理的情况，例如要实现3个或3个以上的异步请求的串行，目前我的Promise没有办法支持new Promise(A).then(B).then(C)这样的形式，jQuery在1.7的版本中为Deferred(Promise)对象实现了pipe函数，可以通过这个函数实现上述功能，代码为$.Deferred(A).pipe(B).then(C)，我尝试去读了jQuery这部分的代码，但是没能读懂，希望有大神能够给一些实现思路]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Underscore源码解析（四）]]></title>
      <url>%2F2014%2F06%2F07%2FUnderscore%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E5%9B%9B%EF%BC%89%2F</url>
      <content type="text"><![CDATA[我在这个系列的第一篇文章说过，我学underscore是为了在学backbone的时候少一些阻碍，从第一篇的写作时间到今天，大概也有个十几二十天，感觉拖得有点久，所以今天将会是underscore源码解析系列的最后一篇文章，我会在这篇文章中介绍underscore剩下的所有函数。先附上前三篇文章的地址：Underscore源码解析（一）、Underscore源码解析（二）、Underscore源码解析（三） _.zip1234567891011121314_.zip = function() &#123; // 将参数转换为数组, 此时args是一个二维数组 var args = slice.call(arguments); // 计算每一个数组的长度, 并返回其中最大长度值 var length = _.max(_.pluck(args, &apos;length&apos;)); // 依照最大长度值创建一个新的空数组, 该数组用于存储处理结果 var results = new Array(length); // 循环最大长度, 在每次循环将调用pluck方法获取每个数组中相同位置的数据(依次从0到最后位置) // 将获取到的数据存储在一个新的数组, 放入results并返回 for(var i = 0; i &lt; length; i++) results[i] = _.pluck(args, &quot;&quot; + i); // 返回的结果是一个二维数组 return results;&#125;; 这个函数将每个数组的相同位置的数据作为一个新的二维数组返回, 返回的数组长度以传入参数中最大的数组长度为准, 其它数组的空白位置使用undefined填充。zip函数应该包含多个参数, 且每个参数应该均为数组。 _.indexOf12345678910111213141516171819_.indexOf = function(array, item, isSorted) &#123; if(array == null) return -1; var i, l; // 若数组已经经过排序，则调用sortedIndex方法，获取元素插入数组中所处位置的索引号 if(isSorted) &#123; i = _.sortedIndex(array, item); return array[i] === item ? i : -1; &#125; // 优先调用宿主环境提供的indexOf方法 if(nativeIndexOf &amp;&amp; array.indexOf === nativeIndexOf) return array.indexOf(item); // 循环并返回元素首次出现的位置 for( i = 0, l = array.length; i &lt; l; i++) if( i in array &amp;&amp; array[i] === item) return i; // 没有找到元素, 返回-1 return -1;&#125;; 这个函数的作用是搜索一个元素在数组中首次出现的位置, 如果元素不存在则返回 -1，搜索时使用 === 对元素进行匹配 _.lastIndexOf1234567891011121314_.lastIndexOf = function(array, item) &#123; if(array == null) return -1; // 优先调用宿主环境提供的lastIndexOf方法 if(nativeLastIndexOf &amp;&amp; array.lastIndexOf === nativeLastIndexOf) return array.lastIndexOf(item); var i = array.length; // 循环并返回元素最后出现的位置 while(i--) if( i in array &amp;&amp; array[i] === item) return i; // 没有找到元素, 返回-1 return -1;&#125;; 这个函数返回一个元素在数组中最后一次出现的位置, 如果元素不存在则返回 -1，搜索时使用 === 对元素进行匹配 _.range12345678910111213141516171819202122232425_.range = function(start, stop, step) &#123; // 参数控制 if(arguments.length &lt;= 1) &#123; // 如果没有参数, 则start = 0, stop = 0, 在循环中不会生成任何数据, 将返回一个空数组 // 如果有1个参数, 则参数指定给stop, start = 0 stop = start || 0; start = 0; &#125; // 生成整数的步长值, 默认为1 step = arguments[2] || 1; // 根据区间和步长计算将生成的最大值 var len = Math.max(Math.ceil((stop - start) / step), 0); var idx = 0; var range = new Array(len); // 生成整数列表, 并存储到range数组 while(idx &lt; len) &#123; range[idx++] = start; start += step; &#125; // 返回列表结果 return range;&#125;; 这个函数根据区间和步长, 生成一系列整数, 并作为数组返回，start参数表示最小数，stop参数表示最大数，step参数表示步长 _.bind123456789101112131415161718192021_.bind = function bind(func, context) &#123; var bound, args; // 优先调用宿主环境提供的bind方法 if(func.bind === nativeBind &amp;&amp; nativeBind) return nativeBind.apply(func, slice.call(arguments, 1)); // func参数必须是一个函数(Function)类型 if(!_.isFunction(func)) throw new TypeError; // args变量存储了bind方法第三个开始的参数列表, 每次调用时都将传递给func函数 args = slice.call(arguments, 2); return bound = function() &#123; if(!(this instanceof bound)) return func.apply(context, args.concat(slice.call(arguments))); ctor.prototype = func.prototype; var self = new ctor; var result = func.apply(self, args.concat(slice.call(arguments))); if(Object(result) === result) return result; return self; &#125;;&#125;; 这个函数为一个函数绑定执行上下文, 任何情况下调用该函数, 函数中的this均指向context对象，绑定函数时, 可以同时给函数传递调用形参 _.bindAll12345678910111213_.bindAll = function(obj) &#123; // 第二个参数开始表示需要绑定的函数名称 var funcs = slice.call(arguments, 1); // 如果没有指定特定的函数名称, 则默认绑定对象本身所有类型为Function的属性 if(funcs.length == 0) funcs = _.functions(obj); // 循环并将所有的函数上下本设置为obj对象本身 // each方法本身不会遍历对象原型链中的方法, 但此处的funcs列表是通过_.functions方法获取的, 它已经包含了原型链中的方法 each(funcs, function(f) &#123; obj[f] = _.bind(obj[f], obj); &#125;); return obj;&#125;; 这个函数将指定的函数, 或对象本身的所有函数上下本绑定到对象本身, 被绑定的函数在被调用时, 上下文对象始终指向对象本身 _.memoize123456789101112_.memoize = function(func, hasher) &#123; // 用于存储缓存结果的memo对象 var memo = &#123;&#125;; // hasher参数应该是一个function, 它用于返回一个key, 该key作为读取缓存的标识 // 如果没有指定key, 则默认使用函数的第一个参数作为key, 如果函数的第一个参数是复合数据类型, 可能会返回类似[Object object]的key, 这个key可能会造成后续计算的数据不正确 hasher || ( hasher = _.identity); // 返回一个函数, 该函数首先通过检查缓存, 再对没有缓存过的数据进行调用 return function() &#123; var key = hasher.apply(this, arguments); return _.has(memo, key) ? memo[key] : (memo[key] = func.apply(this, arguments)); &#125;;&#125;; 这个函数将返回一个函数, 该函数集成了缓存功能, 将经过计算的值缓存到局部变量并在下次调用时直接返回 _.delay1234567_.delay = function(func, wait) &#123; var args = slice.call(arguments, 2); // 通过setTimeout来延时执行 return setTimeout(function() &#123; return func.apply(null, args); &#125;, wait);&#125;; 这个函数的作用是延时执行一个函数，wait单位为ms, 第3个参数开始将被依次传递给执行函数 _.defer1234_.defer = function(func) &#123; // 相当于_.delay(func, 1, [arguments]); return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));&#125;; 这个函数的作用是延迟1ms执行函数，javascript是一个单线程的程序，setTimeout(func, time)作用是把func放到处理任务的队列末尾，在其他任务都完成之后的time ms 后执行func _.throttle1234567891011121314151617181920212223242526272829303132333435363738394041424344_.throttle = function(func, wait) &#123; var context, args, timeout, throttling, more, result; // whenDone变量调用了debounce方法, 因此在多次连续调用函数时, 最后一次调用会覆盖之前调用的定时器, 清除状态函数也仅会被执行一次 // whenDone函数在最后一次函数执行的时间间隔截止时调用, 清除节流和调用过程中记录的一些状态 var whenDone = _.debounce(function() &#123; more = throttling = false; &#125;, wait); // 返回一个函数, 并在函数内进行节流控制 return function() &#123; // 保存函数的执行上下文和参数 context = this; args = arguments; // later函数在上一次函数调用时间间隔截止时执行 var later = function() &#123; // 清除timeout句柄, 方便下一次函数调用 timeout = null; // more记录了在上一次调用至时间间隔截止之间, 是否重复调用了函数 // 如果重复调用了函数, 在时间间隔截止时将自动再次调用函数 if(more) func.apply(context, args); // 调用whenDone, 用于在时间间隔后清除节流状态 whenDone(); &#125;; // timeout记录了上一次函数执行的时间间隔句柄 // timeout时间间隔截止时调用later函数, later中将清除timeout, 并检查是否需要再次调用函数 if(!timeout) timeout = setTimeout(later, wait); // throttling变量记录上次调用的时间间隔是否已经结束, 即是否处于节流过程中 // throttling在每次函数调用时设为true, 表示需要进行节流, 在时间间隔截止时设置为false(在whenDone函数中实现) if(throttling) &#123; // 节流过程中进行了多次调用, 在more中记录一个状态, 表示在时间间隔截止时需要再次自动调用函数 more = true; &#125; else &#123; // 没有处于节流过程, 可能是第一次调用函数, 或已经超过上一次调用的间隔, 可以直接调用函数 result = func.apply(context, args); &#125; // 调用whenDone, 用于在时间间隔后清除节流状态 whenDone(); // throttling变量记录函数调用时的节流状态 throttling = true; // 返回调用结果 return result; &#125;;&#125;; 这是函数节流方法, throttle方法主要用于控制函数的执行频率, 在被控制的时间间隔内, 频繁调用函数不会被多次执行，在时间间隔内如果多次调用了函数, 时间隔截止时会自动调用一次, 不需要等到时间截止后再手动调用(自动调用时不会有返回值)，throttle函数一般用于处理复杂和调用频繁的函数, 通过节流控制函数的调用频率, 节省处理资源 _.debounce123456789101112131415161718192021222324252627_.debounce = function(func, wait, immediate) &#123; // timeout用于记录函数上一次调用的执行状态(定时器句柄) // 当timeout为null时, 表示上一次调用已经结束 var timeout; // 返回一个函数, 并在函数内进行节流控制 return function() &#123; // 保持函数的上下文对象和参数 var context = this, args = arguments; var later = function() &#123; // 设置timeout为null // later函数会在允许的时间截止时被调用 // 调用该函数时, 表明上一次函数执行时间已经超过了约定的时间间隔, 此时之后再进行调用都是被允许的 timeout = null; if(!immediate) func.apply(context, args); &#125;; // 如果函数被设定为立即执行, 且上一次调用的时间间隔已经过去, 则立即调用函数 if(immediate &amp;&amp; !timeout) func.apply(context, args); // 创建一个定时器用于检查和设置函数的调用状态 // 创建定时器之前先清空上一次setTimeout句柄, 无论上一次绑定的函数是否已经被执行 // 如果本次函数在调用时, 上一次函数执行还没有开始(一般是immediate设置为false时), 则函数的执行时间会被推迟, 因此timeout句柄会被重新创建 clearTimeout(timeout); // 在允许的时间截止时调用later函数 timeout = setTimeout(later, wait); &#125;;&#125;; debounce与throttle方法类似, 用于函数节流, 它们的不同之处在于: – throttle关注函数的执行频率, 在指定频率内函数只会被执行一次 – debounce函数更关注函数执行的间隔, 即函数两次的调用时间不能小于指定时间如果两次函数的执行间隔小于wait, 定时器会被清除并重新创建, 这意味着连续频繁地调用函数, 函数一直不会被执行, 直到某一次调用与上一次调用的时间不小于wait毫秒 _.once123456789101112_.once = function(func) &#123; // ran记录函数是否被执行过 // memo记录函数最后一次执行的结果 var ran = false, memo; return function() &#123; // 如果函数已被执行过, 则直接返回第一次执行的结果 if(ran) return memo; ran = true; return memo = func.apply(this, arguments); &#125;;&#125;; 这个函数创建一个只会被执行一次的函数, 如果该函数被重复调用, 将返回第一次执行的结果 _.wrap12345678_.wrap = function(func, wrapper) &#123; return function() &#123; // 将当前函数作为第一个参数, 传递给wrapper函数 var args = [func].concat(slice.call(arguments, 0)); // 返回wrapper函数的处理结果 return wrapper.apply(this, args); &#125;;&#125;; 这个函数返回一个函数, 该函数会将当前函数作为参数传递给一个包裹函数，在包裹函数中可以通过第一个参数调用当前函数, 并返回结果 _.compose1234567891011121314_.compose = function() &#123; // 获取函数列表, 所有参数需均为Function类型 var funcs = arguments; // 返回一个供调用的函数句柄 return function() &#123; // 从后向前依次执行函数, 并将记录的返回值作为参数传递给前一个函数继续处理 var args = arguments; for(var i = funcs.length - 1; i &gt;= 0; i--) &#123; args = [funcs[i].apply(this, args)]; &#125; // 返回最后一次调用函数的返回值 return args[0]; &#125;;&#125;; 这个函数将多个函数组合到一起, 按照参数传递的顺序, 后一个函数的返回值会被依次作为参数传递给前一个函数作为参数继续处理，_.compose(A, B, C)等同于 A(B(C())) _.after123456789101112_.after = function(times, func) &#123; // 如果没有指定或指定无效次数, 则func被直接调用 if(times &lt;= 0) return func(); // 返回一个计数器函数 return function() &#123; // 每次调用计数器函数times减1, 调用times次之后执行func函数并返回func函数的返回值 if(--times &lt; 1) &#123; return func.apply(this, arguments); &#125; &#125;;&#125;; after返回一个函数, 该函数作为调用计数器, 当该函数被调用times次(或超过times次)后, func函数将被执行 _.keys1234567891011_.keys = nativeKeys ||function(obj) &#123; if(obj !== Object(obj)) throw new TypeError(&apos;Invalid object&apos;); var keys = []; // 记录并返回对象的所有属性名 for(var key in obj) if(_.has(obj, key)) keys[keys.length] = key; return keys;&#125;; 这个函数用于获取一个对象的属性名列表(不包含原型链中的属性) _.values123_.values = function(obj) &#123; return _.map(obj, _.identity);&#125;; 这个函数返回一个对象中所有属性的值列表(不包含原型链中的属性) .functions / .methods12345678_.functions = _.methods = function(obj) &#123; var names = []; for(var key in obj) &#123; if(_.isFunction(obj[key])) names.push(key); &#125; return names.sort();&#125;; 这个函数获取一个对象中所有属性值为Function类型的key列表, 并按key名进行排序(包含原型链中的属性) _.extend12345678910_.extend = function(obj) &#123; // each循环参数中的一个或多个对象 each(slice.call(arguments, 1), function(source) &#123; // 将对象中的全部属性复制或覆盖到obj对象 for(var prop in source) &#123; obj[prop] = source[prop]; &#125; &#125;); return obj;&#125;; 这个函数将一个或多个对象的属性(包含原型链中的属性), 复制到obj对象, 如果存在同名属性则覆盖 _.pick123456789101112_.pick = function(obj) &#123; // 创建一个对象, 存放复制的指定属性 var result = &#123;&#125;; // 从第二个参数开始合并为一个存放属性名列表的数组 each(_.flatten(slice.call(arguments, 1)), function(key) &#123; // 循环属性名列表, 如果obj中存在该属性, 则将其复制到result对象 if( key in obj) result[key] = obj[key]; &#125;); // 返回复制结果 return result;&#125;; 这个函数返回一个新对象, 并从obj中复制指定的属性到新对象中，第2个参数开始为指定的需要复制的属性名 _.defaults123456789101112_.defaults = function(obj) &#123; // 从第二个参数开始可指定多个对象, 这些对象中的属性将被依次复制到obj对象中(如果obj对象中不存在该属性的话) each(slice.call(arguments, 1), function(source) &#123; // 遍历每个对象中的所有属性 for(var prop in source) &#123; // 如果obj中不存在或属性值转换为Boolean类型后值为false, 则将属性复制到obj中 if(obj[prop] == null) obj[prop] = source[prop]; &#125; &#125;); return obj;&#125;; 这个函数将obj中不存在或转换为Boolean类型后值为false的属性, 从参数中指定的一个或多个对象中复制到obj，一般用于给对象指定默认值 _.clone1234567_.clone = function(obj) &#123; // 不支持非数组和对象类型的数据 if(!_.isObject(obj)) return obj; // 复制并返回数组或对象 return _.isArray(obj) ? obj.slice() : _.extend(&#123;&#125;, obj);&#125;; 这个函数创建一个obj的副本, 返回一个新的对象, 该对象包含obj中的所有属性和值的状态 _.tap1234_.tap = function(obj, interceptor) &#123; interceptor(obj); return obj;&#125;; 这个函数执行一个函数, 并将obj作为参数传递给该函数, 函数执行完毕后最终返回obj对象 eq123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125function eq(a, b, stack) &#123; // 检查两个简单数据类型的值是否相等 // 对于复合数据类型, 如果它们来自同一个引用, 则认为其相等 // 如果被比较的值其中包含0, 则检查另一个值是否为-0, 因为 0 === -0 是成立的 // 而 1 / 0 == 1 / -0 是不成立的(1 / 0值为Infinity, 1 / -0值为-Infinity, 而Infinity不等于-Infinity) if(a === b) return a !== 0 || 1 / a == 1 / b; // 将数据转换为布尔类型后如果值为false, 将判断两个值的数据类型是否相等(因为null与undefined, false, 0, 空字符串, 在非严格比较下值是相等的) if(a == null || b == null) return a === b; // 如果进行比较的数据是一个Underscore封装的对象(具有_chain属性的对象被认为是Underscore对象) // 则将对象解封后获取本身的数据(通过_wrapped访问), 然后再对本身的数据进行比较 // 它们的关系类似与一个jQuery封装的DOM对象, 和浏览器本身创建的DOM对象 if(a._chain) a = a._wrapped; if(b._chain) b = b._wrapped; // 如果对象提供了自定义的isEqual方法(此处的isEqual方法并非Undersocre对象的isEqual方法, 因为在上一步已经对Undersocre对象进行了解封) // 则使用对象自定义的isEqual方法与另一个对象进行比较 if(a.isEqual &amp;&amp; _.isFunction(a.isEqual)) return a.isEqual(b); if(b.isEqual &amp;&amp; _.isFunction(b.isEqual)) return b.isEqual(a); // 对两个数据的数据类型进行验证 // 获取对象a的数据类型(通过Object.prototype.toString方法) var className = toString.call(a); // 如果对象a的数据类型与对象b不匹配, 则认为两个数据值也不匹配 if(className != toString.call(b)) return false; // 执行到此处, 可以确保需要比较的两个数据均为复合数据类型, 且数据类型相等 // 通过switch检查数据的数据类型, 针对不同数据类型进行不同的比较 // (此处不包括对数组和对象类型, 因为它们可能包含更深层次的数据, 将在后面进行深层比较) switch (className) &#123; case &apos;[object String]&apos;: // 如果被比较的是字符串类型(其中a的是通过new String()创建的字符串) // 则将B转换为String对象后进行匹配(这里匹配并非进行严格的数据类型检查, 因为它们并非来自同一个对象的引用) // 在调用 == 进行比较时, 会自动调用对象的toString()方法, 返回两个简单数据类型的字符串 return a == String(b); case &apos;[object Number]&apos;: // 通过+a将a转成一个Number, 如果a被转换之前与转换之后不相等, 则认为a是一个NaN类型 // 因为NaN与NaN是不相等的, 因此当a值为NaN时, 无法简单地使用a == b进行匹配, 而是用相同的方法检查b是否为NaN(即 b != +b) // 当a值是一个非NaN的数据时, 则检查a是否为0, 因为当b为-0时, 0 === -0是成立的(实际上它们在逻辑上属于两个不同的数据) return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b); case &apos;[object Date]&apos;: // 对日期类型没有使用return或break, 因此会继续执行到下一步(无论数据类型是否为Boolean类型, 因为下一步将对Boolean类型进行检查) case &apos;[object Boolean]&apos;: // 将日期或布尔类型转换为数字 // 日期类型将转换为数值类型的时间戳(无效的日期格式将被换转为NaN) // 布尔类型中, true被转换为1, false被转换为0 // 比较两个日期或布尔类型被转换为数字后是否相等 return +a == +b; case &apos;[object RegExp]&apos;: // 正则表达式类型, 通过source访问表达式的字符串形式 // 检查两个表达式的字符串形式是否相等 // 检查两个表达式的全局属性是否相同(包括g, i, m) // 如果完全相等, 则认为两个数据相等 return a.source == b.source &amp;&amp; a.global == b.global &amp;&amp; a.multiline == b.multiline &amp;&amp; a.ignoreCase == b.ignoreCase; &#125; // 当执行到此时, ab两个数据应该为类型相同的对象或数组类型 if( typeof a != &apos;object&apos; || typeof b != &apos;object&apos;) return false; // stack(堆)是在isEqual调用eq函数时内部传递的空数组, 在后面比较对象和数据的内部迭代中调用eq方法也会传递 // length记录堆的长度 var length = stack.length; while(length--) &#123; // 如果堆中的某个对象与数据a匹配, 则认为相等 if(stack[length] == a) return true; &#125; // 将数据a添加到堆中 stack.push(a); // 定义一些局部变量 var size = 0, result = true; // 通过递归深层比较对象和数组 if(className == &apos;[object Array]&apos;) &#123; // 被比较的数据为数组类型 // size记录数组的长度 // result比较两个数组的长度是否一致, 如果长度不一致, 则方法的最后将返回result(即false) size = a.length; result = size == b.length; // 如果两个数组的长度一致 if(result) &#123; // 调用eq方法对数组中的元素进行迭代比较(如果数组中包含二维数组或对象, eq方法会进行深层比较) while(size--) &#123; // 在确保两个数组都存在当前索引的元素时, 调用eq方法深层比较(将堆数据传递给eq方法) // 将比较的结果存储到result变量, 如果result为false(即在比较中得到某个元素的数据不一致), 则停止迭代 if(!( result = size in a == size in b &amp;&amp; eq(a[size], b[size], stack))) break; &#125; &#125; &#125; else &#123; // 被比较的数据为对象类型 // 如果两个对象不是同一个类的实例(通过constructor属性比较), 则认为两个对象不相等 if(&apos;constructor&apos; in a != &apos;constructor&apos; in b || a.constructor != b.constructor) return false; // 深层比较两个对象中的数据 for(var key in a) &#123; if(_.has(a, key)) &#123; // size用于记录比较过的属性数量, 因为这里遍历的是a对象的属性, 并比较b对象中该属性的数据 // 当b对象中的属性数量多余a对象时, 此处的逻辑成立, 但两个对象并不相等 size++; // 迭代调用eq方法, 深层比较两个对象中的属性值 // 将比较的结果记录到result变量, 当比较到不相等的数据时停止迭代 if(!( result = _.has(b, key) &amp;&amp; eq(a[key], b[key], stack))) break; &#125; &#125; // 深层比较完毕, 这里已经可以确保在对象a中的所有数据, 对象b中也存在相同的数据 // 根据size(对象属性长度)检查对象b中的属性数量是否与对象a相等 if(result) &#123; // 遍历对象b中的所有属性 for(key in b) &#123; // 当size已经到0时(即对象a中的属性数量已经遍历完毕), 而对象b中还存在有属性, 则对象b中的属性多于对象a if(_.has(b, key) &amp;&amp; !(size--)) break; &#125; // 当对象b中的属性多于对象a, 则认为两个对象不相等 result = !size; &#125; &#125; // 函数执行完毕时, 从堆中移除第一个数据(在比较对象或数组时, 会迭代eq方法, 堆中可能存在多个数据) stack.pop(); // 返回的result记录了最终的比较结果 return result;&#125; eq函数只在isEqual方法中调用, 用于比较两个数据的值是否相等,与 === 不同在于, eq更关注数据的值,如果进行比较的是两个复合数据类型, 不仅仅比较是否来自同一个引用, 且会进行深层比较(对两个对象的结构和数据进行比较) _.isEqual123_.isEqual = function(a, b) &#123; return eq(a, b, []);&#125;; 不多说了，就是内部函数eq的外部方法 _.isEmpty1234567891011121314_.isEmpty = function(obj) &#123; // obj被转换为Boolean类型后值为false if(obj == null) return true; // 检查对象或字符串长度是否为0 if(_.isArray(obj) || _.isString(obj)) return obj.length === 0; // 检查对象(使用for in循环时将首先循环对象本身的属性, 其次是原型链中的属性), 因此如果第一个属性是属于对象本身的, 那么该对象不是一个空对象 for(var key in obj) if(_.has(obj, key)) return false; // 所有数据类型均没有通过验证, 是一个空数据 return true;&#125;; 这个函数用于检查数据是否为空值, 包含’’, false, 0, null, undefined, NaN, 空数组(数组长度为0)和空对象(对象本身没有任何属性) _.isElement123_.isElement = function(obj) &#123; return !!(obj &amp;&amp; obj.nodeType == 1);&#125;; 这个函数用于验证对象是否是一个DOM对象 _.isArray1234_.isArray = nativeIsArray ||function(obj) &#123; return toString.call(obj) == &apos;[object Array]&apos;;&#125;; 这个函数用于验证一个变量是否是数组 _.isObject123_.isObject = function(obj) &#123; return obj === Object(obj);&#125;; 这个函数用于验证对象是否是一个复合数据类型的对象(即非基本数据类型String, Boolean, Number, null, undefined) _.isArguments1234567891011_.isArguments = function(obj) &#123; return toString.call(obj) == &apos;[object Arguments]&apos;;&#125;;// 验证isArguments函数, 如果运行环境无法正常验证arguments类型的数据, 则重新定义isArguments方法if(!_.isArguments(arguments)) &#123; // 对于环境无法通过toString验证arguments类型的, 则通过调用arguments独有的callee方法来进行验证 _.isArguments = function(obj) &#123; // callee是arguments的一个属性, 指向对arguments所属函数自身的引用 return !!(obj &amp;&amp; _.has(obj, &apos;callee&apos;)); &#125;;&#125; 这个函数用于检查一个数据是否是一个arguments参数对象 .isFunction / .isString / .isNumber / .isDate / _.isRegExp这几个我就放在一起说了，他们都是通过Object.prototype.toString.call(obj)的值来进行判断的 _.isFinite123_.isFinite = function(obj) &#123; return _.isNumber(obj) &amp;&amp; isFinite(obj);&#125;; 这个函数用于检查一个数字是否为有效数字且有效范围(Number类型, 值在负无穷大 - 正无穷大之间) _.isNaN123_.isNaN = function(obj) &#123; return obj !== obj;&#125;; 在js里，所有数据中只有NaN与NaN不相等 _.isBoolean1234_.isBoolean = function(obj) &#123; // 支持字面量和对象形式的Boolean数据 return obj === true || obj === false || toString.call(obj) == &apos;[object Boolean]&apos;;&#125;; 这个函数用于检查数据是否是Boolean类型 _.isNull123_.isNull = function(obj) &#123; return obj === null;&#125;; 这个函数用于检查数据是否是Null值 _.isUndefined123_.isUndefined = function(obj) &#123; return obj === void 0;&#125;; 这个函数用于检查数据是否是Undefined值 _.has123_.has = function(obj, key) &#123; return hasOwnProperty.call(obj, key);&#125;; 这个函数检查一个属性是否属于对象本身, 而非原型链中 _.noConflict12345_.noConflict = function() &#123; // previousUnderscore变量记录了Underscore定义前_(下划线)的值 root._ = previousUnderscore; return this;&#125;; 这个函数一般用于避免命名冲突或规范命名方式，放弃_(下划线)命名的Underscore对象, 并返回Underscore对象 _.identity123_.identity = function(value) &#123; return value;&#125;; 这个函数返回与参数相同的值, 一般用于将一个数据的获取方式转换为函数获取方式(内部用于构建方法时作为默认处理器函数) _.times1234_.times = function(n, iterator, context) &#123; for(var i = 0; i &lt; n; i++) iterator.call(context, i);&#125;; 这个函数的作用是使指定的函数迭代执行n次(无参数) _.escape123_.escape = function(string) &#123; return (&apos;&apos; + string).replace(/&amp;/g, &apos;&amp;amp;&apos;).replace(/&lt;/g, &apos;&amp;lt;&apos;).replace(/&gt;/g, &apos;&amp;gt;&apos;).replace(/&quot;/g, &apos;&amp;quot;&apos;).replace(/&apos;/g, &apos;&amp;#x27;&apos;).replace(/\//g, &apos;&amp;#x2F;&apos;);&#125;; 这个函数用于将HTML字符串中的特殊字符转换为HTML实体, 包含 &amp; &lt; &gt; “ ‘ \ _.result12345678_.result = function(object, property) &#123; if(object == null) return null; // 获取对象的值 var value = object[property]; // 如果值是一个函数, 则执行并返回, 否则将直接返回 return _.isFunction(value) ? value.call(object) : value;&#125;; 这个函数指定一个对象的属性, 返回该属性对应的值, 如果该属性对应的是一个函数, 则会执行该函数并返回结果 _.mixin12345678_.mixin = function(obj) &#123; // obj是一个集合一系列自定义方法的对象, 此处通过each遍历对象的方法 each(_.functions(obj), function(name) &#123; // 通过addToWrapper函数将自定义方法添加到Underscore构建的对象中, 用于支持对象式调用 // 同时将方法添加到 _ 本身, 用于支持函数式调用 addToWrapper(name, _[name] = obj[name]); &#125;);&#125;; 这个函数添加一系列自定义方法到Underscore对象中, 用于扩展Underscore插件 _.template12345678910111213141516171819202122232425262728293031323334353637_.template = function(text, data, settings) &#123; // 模板配置, 如果没有指定配置项, 则使用templateSettings中指定的配置项 settings = _.defaults(settings || &#123;&#125;, _.templateSettings); // 开始将模板解析为可执行源码 var source = &quot;__p+=&apos;&quot; + text.replace(escaper, function(match) &#123; // 将特殊符号转移为字符串形式 return &apos;\\&apos; + escapes[match]; &#125;).replace(settings.escape || noMatch, function(match, code) &#123; // 解析escape形式标签 &lt;%- %&gt;, 将变量中包含的HTML通过_.escape函数转换为HTML实体 return &quot;&apos;+\n_.escape(&quot; + unescape(code) + &quot;)+\n&apos;&quot;; &#125;).replace(settings.interpolate || noMatch, function(match, code) &#123; // 解析interpolate形式标签 &lt;%= %&gt;, 将模板内容作为一个变量与其它字符串连接起来, 则会作为一个变量输出 return &quot;&apos;+\n(&quot; + unescape(code) + &quot;)+\n&apos;&quot;; &#125;).replace(settings.evaluate || noMatch, function(match, code) &#123; // 解析evaluate形式标签 &lt;% %&gt;, evaluate标签中存储了需要执行的JavaScript代码, 这里结束当前的字符串拼接, 并在新的一行作为JavaScript语法执行, 并将后面的内容再次作为字符串的开始, 因此evaluate标签内的JavaScript代码就能被正常执行 return &quot;&apos;;\n&quot; + unescape(code) + &quot;\n;__p+=&apos;&quot;; &#125;) + &quot;&apos;;\n&quot;; if(!settings.variable) source = &apos;with(obj||&#123;&#125;)&#123;\n&apos; + source + &apos;&#125;\n&apos;; source = &quot;var __p=&apos;&apos;;&quot; + &quot;var print=function()&#123;__p+=Array.prototype.join.call(arguments, &apos;&apos;)&#125;;\n&quot; + source + &quot;return __p;\n&quot;; // 创建一个函数, 将源码作为函数执行体, 将obj和Underscore作为参数传递给该函数 var render = new Function(settings.variable || &apos;obj&apos;, &apos;_&apos;, source); // 如果指定了模板的填充数据, 则替换模板内容, 并返回替换后的结果 if(data) return render(data, _); // 如果没有指定填充数据, 则返回一个函数, 该函数用于将接收到的数据替换到模板 // 如果在程序中会多次填充相同模板, 那么在第一次调用时建议不指定填充数据, 在获得处理函数的引用后, 再直接调用会提高运行效率 var template = function(data) &#123; return render.call(this, data, _); &#125;; // 将创建的源码字符串添加到函数对象中, 一般用于调试和测试 template.source = &apos;function(&apos; + (settings.variable || &apos;obj&apos;) + &apos;)&#123;\n&apos; + source + &apos;&#125;&apos;; // 没有指定填充数据的情况下, 返回处理函数句柄 return template;&#125;; 这个我要介绍的最后一个函数，也是我个人认为比较重要的，它是Underscore模板解析方法, 用于将数据填充到一个模板字符串中，在模板体内, 可通过argments获取2个参数, 分别为填充数据(名称为obj)和Underscore对象(名称为_) 小结今天一口气把剩下的所有函数都介绍完了，真是累感不爱啊，不过在写作这几篇博客的过程中，我也从Underscore这个框架中学到了很多东西，包括它的优雅的代码风格（至少比我自己写的优雅），还有一个优秀的库整个的架构是怎么搭建起来的。以后我还会继续为大家分享其他的前端知识和学习心得，thx for reading, hope u enjoy]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Underscore源码解析（三）]]></title>
      <url>%2F2014%2F06%2F06%2FUnderscore%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
      <content type="text"><![CDATA[前两天在微博上看到SF的微博推荐了我的前两篇文章，有点意外和惊喜。作为一个菜鸟，真的是倍受鼓舞，我写博客的动力也更充足了。没看过前两篇博客的朋友可以戳这里：Underscore源码解析（一）、Underscore源码解析（二）上一篇文章介绍了underscore的10个函数的具体实现细节，今天将继续介绍其他的函数。 _.invoke12345678_.invoke = function(obj, method) &#123; // 调用同名方法时传递的参数(从第3个参数开始) var args = slice.call(arguments, 2); // 依次调用每个元素的方法, 并将结果放入数组中返回 return _.map(obj, function(value) &#123; return (_.isFunction(method) ? method || value : value[method]).apply(value, args); &#125;);&#125;; 这个函数依次调用集合中所有元素的同名方法，从第3个参数开始的所有参数将被传入到元素的调用方法中，最后返回一个数组，该数组存储了所有方法的处理结果 _.pluck123456_.pluck = function(obj, key) &#123; // 如果某一个对象中不存在该属性, 则返回undefined return _.map(obj, function(value) &#123; return value[key]; &#125;);&#125;; 这个函数遍历了一个由对象列表组成的集合，并返回每个对象中的指定属性的值列表 _.max12345678910111213141516171819202122232425_.max = function(obj, iterator, context) &#123; // 如果集合是一个数组, 且没有使用处理器, 则使用Math.max获取最大值 // 一般会是在一个数组存储了一系列Number类型的数据 if(!iterator &amp;&amp; _.isArray(obj) &amp;&amp; obj[0] === +obj[0]) return Math.max.apply(Math, obj); // 对于空值, 直接返回负无穷大 if(!iterator &amp;&amp; _.isEmpty(obj)) return -Infinity; // 一个临时的对象, computed用于在比较过程中存储最大值(临时的) var result = &#123; computed : -Infinity &#125;; // 迭代集合中的元素 each(obj, function(value, index, list) &#123; // 如果指定了处理器参数, 则比较的数据为处理器返回的值, 否则直接使用each遍历时的默认值 var computed = iterator ? iterator.call(context, value, index, list) : value; // 如果比较值相比上一个值要大, 则将当前值放入result.value computed &gt;= result.computed &amp;&amp; ( result = &#123; value : value, computed : computed &#125;); &#125;); // 返回最大值 return result.value;&#125;; 顾名思义，这个函数用来返回集合中的最大值, 如果不存在可比较的值, 则返回undefined _.min1234567891011121314151617_.min = function(obj, iterator, context) &#123; if(!iterator &amp;&amp; _.isArray(obj) &amp;&amp; obj[0] === +obj[0]) return Math.min.apply(Math, obj); if(!iterator &amp;&amp; _.isEmpty(obj)) return Infinity; var result = &#123; computed : Infinity &#125;; each(obj, function(value, index, list) &#123; var computed = iterator ? iterator.call(context, value, index, list) : value; computed &lt; result.computed &amp;&amp; ( result = &#123; value : value, computed : computed &#125;); &#125;); return result.value;&#125;; 这个函数没有加注释，因为实现过程与max基本相同，用于返回集合中的最小值 _.shuffle123456789101112131415_.shuffle = function(obj) &#123; // shuffled变量存储处理过程及最终的结果数据 var shuffled = [], rand; // 迭代集合中的元素 each(obj, function(value, index, list) &#123; // 生成一个随机数, 随机数在&lt;0-当前已处理的数量&gt;之间 rand = Math.floor(Math.random() * (index + 1)); // 将已经随机得到的元素放到shuffled数组末尾 shuffled[index] = shuffled[rand]; // 在前面得到的随机数的位置插入最新值 shuffled[rand] = value; &#125;); // 返回一个数组, 该数组中存储了经过随机混排的集合元素 return shuffled;&#125;; 这个函数是通过随机数, 让数组无须排列，实际上是实现了一个模拟洗牌过程的算法 _.sortBy12345678910111213141516171819202122232425_.sortBy = function(obj, val, context) &#123; // val应该是对象的一个属性, 或一个处理器函数, 如果是一个处理器, 则应该返回需要进行比较的数据 var iterator = _.isFunction(val) ? val : function(obj) &#123; return obj[val]; &#125;; // 调用顺序: _.pluck(_.map().sort()); // 调用_.map()方法遍历集合, 并将集合中的元素放到value节点, 将元素中需要进行比较的数据放到criteria属性中 // 调用sort()方法将集合中的元素按照criteria属性中的数据进行顺序排序 // 调用pluck获取排序后的对象集合并返回 return _.pluck(_.map(obj, function(value, index, list) &#123; return &#123; value : value, criteria : iterator.call(context, value, index, list) &#125;; &#125;).sort(function(left, right) &#123; var a = left.criteria, b = right.criteria; if(a === void 0) return 1; if(b === void 0) return -1; return a &lt; b ? -1 : a &gt; b ? 1 : 0; &#125;), &apos;value&apos;);&#125;; 这个函数对集合中元素, 按照特定的字段或值进行排列，相比Array.prototype.sort方法, sortBy方法支持对对象排序 _.groupBy123456789101112131415_.groupBy = function(obj, val) &#123; var result = &#123;&#125;; // val将被转换为进行分组的处理器函数, 如果val不是一个Function类型的数据, 则将被作为筛选元素时的key值 var iterator = _.isFunction(val) ? val : function(obj) &#123; return obj[val]; &#125;; // 迭代集合中的元素 each(obj, function(value, index) &#123; // 将处理器的返回值作为key, 并将相同的key元素放到一个新的数组 var key = iterator(value, index); (result[key] || (result[key] = [])).push(value); &#125;); // 返回已分组的数据 return result;&#125;; 这个函数将集合中的元素, 按处理器返回的key分为多个数组 _.sortedIndex12345678910111213_.sortedIndex = function(array, obj, iterator) &#123; // 如果没有指定处理器参数, 则使用默认的处理器函数，该函数会返回参数本身 iterator || ( iterator = _.identity); var low = 0, high = array.length; // 不断与中间值对比，寻找obj的正确插入点 while(low &lt; high) &#123; // (low + high) &gt;&gt; 1 相当于 Math.floor((low + high) / 2) var mid = (low + high) &gt;&gt; 1; iterator(array[mid]) &lt; iterator(obj) ? low = mid + 1 : high = mid; &#125; // 返回obj插入array之后的索引号 return low;&#125;; 这个函数的作用是将obj插入已经排序的array中，返回obj在array中的索引号 _.toArray12345678910111213_.toArray = function(obj) &#123; if(!obj) return []; if(_.isArray(obj)) return slice.call(obj); // 将arguments转换为数组 if(_.isArguments(obj)) return slice.call(obj); if(obj.toArray &amp;&amp; _.isFunction(obj.toArray)) return obj.toArray(); // 将对象转换为数组, 数组中包含对象中所有属性的值列表(不包含对象原型链中的属性) return _.values(obj);&#125;; 这个函数很简单，作用是将一个集合转换一个数组并返回 _.size12345_.size = function(obj) &#123; // 如果集合是一个数组, 则计算数组元素数量 // 如果集合是一个对象, 则计算对象中的属性数量(不包含对象原型链中的属性) return _.isArray(obj) ? obj.length : _.keys(obj).length;&#125;; 这个函数用于计算集合中元素的数量，isArray和keys函数后面会介绍到 .first / .head / _.take123456_.first = _.head = _.take = function(array, n, guard) &#123; // 如果没有指定参数n, 则返回第一个元素 // 如果指定了n, 则返回一个新的数组, 包含顺序指定数量n个元素 // guard参数用于确定只返回第一个元素, 当guard为true时, 指定数量n无效 return (n != null) &amp;&amp; !guard ? slice.call(array, 0, n) : array[0];&#125;; 这个函数用于返回一个数组的第一个或順序指定的n个元素 _.initial123456_.initial = function(array, n, guard) &#123; // 如果没有传递参数n, 则默认返回除最后一个元素外的其它元素 // 如果传递参数n, 则返回从最后一个元素开始向前的n个元素外的其它元素 // guard用于确定只返回一个元素, 当guard为true时, 指定数量n无效 return slice.call(array, 0, array.length - ((n == null) || guard ? 1 : n));&#125;; 这个函数返回一个新数组, 包含除最后一个元素外的其它元素, 或排除从最后一个元素开始向前指定n个元素 _.last123456789_.last = function(array, n, guard) &#123; if((n != null) &amp;&amp; !guard) &#123; // 计算并指定获取的元素位置n, 直到数组末尾, 作为一个新的数组返回 return slice.call(array, Math.max(array.length - n, 0)); &#125; else &#123; // 如果没有指定数量, 或guard为true时, 只返回最后一个元素 return array[array.length - 1]; &#125;&#125;; 这个函数与first相反，返回数组的最后一个或倒序指定的n个元素 .rest / .tail123456_.rest = _.tail = function(array, index, guard) &#123; // 计算slice的第二个位置参数, 直到数组末尾 // 如果没有指定index, 或guard值为true, 则返回除第一个元素外的其它元素 // (index == null)值为true时, 作为参数传递给slice函数将被自动转换为1 return slice.call(array, (index == null) || guard ? 1 : index);&#125;; 这个函数与initial相反，用于获取除了第一个或指定前n个元素外的其它元素 _.campact12345_.compact = function(array) &#123; return _.filter(array, function(value) &#123; return !!value; &#125;);&#125;; 这个函数借助filter函数，返回数组中所有值能被转换为true的元素, 返回一个新的数组，不能被转换的值包括 false, 0, ‘’, null, undefined, NaN, 这些值将被转换为false _.flatten12345678910111213_.flatten = function(array, shallow) &#123; // 迭代数组中的每一个元素, 并将返回值作为demo传递给下一次迭代 return _.reduce(array, function(memo, value) &#123; // 如果元素依然是一个数组, 进行以下判断: // - 如果不进行深层合并, 则使用Array.prototype.concat将当前数组和之前的数据进行连接 // - 如果支持深层合并, 则迭代调用flatten方法, 直到底层元素不再是数组类型 if(_.isArray(value)) return memo.concat( shallow ? value : _.flatten(value)); // 数据(value)已经处于底层, 不再是数组类型, 则将数据合并到memo中并返回 memo[memo.length] = value; return memo; &#125;, []);&#125;; 这个函数用于将一个多维数组合成为一维数组, 支持深层合并，其中第二个参数shallow用于控制合并深度, 当shallow为true时, 只合并第一层, 默认进行深层合并 _.without123_.without = function(array) &#123; return _.difference(array, slice.call(arguments, 1));&#125;; 这个函数用于筛选并返回当前数组中与指定数据不相等的差异数据，具体可以参看我后续对difference函数的介绍 .uniq/.unique1234567891011121314151617181920212223242526_.uniq = _.unique = function(array, isSorted, iterator) &#123; // 如果使用了iterator处理器, 则先将当前数组中的数据会先经过按迭代器处理, 并返回一个处理后的新数组 // 新数组用于作为比较的基准 var initial = iterator ? _.map(array, iterator) : array; // 用于记录处理结果的临时数组 var results = []; // 如果数组中只有2个值, 则不需要使用include方法进行比较, 将isSorted设置为true能提高运行效率 if(array.length &lt; 3) isSorted = true; // 使用reduce方法迭代并累加处理结果 // initial变量是需要进行比较的基准数据, 它可能是原始数组, 也可能是处理器的结果集合(如果设置过iterator) _.reduce(initial, function(memo, value, index) &#123; // 如果isSorted参数为true, 则直接使用===比较记录中的最后一个数据 // 如果isSorted参数为false, 则使用include方法与集合中的每一个数据进行对比 if( isSorted ? _.last(memo) !== value || !memo.length : !_.include(memo, value)) &#123; // memo记录了已经比较过的无重复数据 // 根据iterator参数的状态, memo中记录的数据可能是原始数据, 也可能是处理器处理后的数据 memo.push(value); // 处理结果数组中保存的始终为原始数组中的数据 results.push(array[index]); &#125; return memo; &#125;, []); // 返回处理结果, 它只包含数组中无重复的数据 return results;&#125;; 这个函数用于对数组中的数据进行去重(使用===进行比较)，当isSorted参数不为false时, 将依次对数组中的元素调用include方法, 检查相同元素是否已经被添加到返回值(数组)中，如果调用之前确保数组中数据按顺序排列, 则可以将isSorted设为true, 它将通过与最后一个元素进行对比来排除相同值, 使用isSorted效率会高于默认的include方式，uniq方法默认将以数组中的数据进行对比, 如果声明iterator处理器, 则会根据处理器创建一个对比数组, 比较时以该数组中的数据为准, 但最终返回的唯一数据仍然是原始数组 _.union1234_.union = function() &#123; // union对参数中的多个数组进行浅层合并为一个数组对象传递给uniq方法进行处理 return _.uniq(_.flatten(arguments, true));&#125;; 这个函数与uniq作用一致, 不同之处在于union允许在参数中传入多个数组 _.intersection12345678910111213141516_.intersection = _.intersect = function(array) &#123; // rest变量记录需要进行比较的其它数组对象 var rest = slice.call(arguments, 1); // 使用uniq方法去除当前数组中的重复数据, 避免重复计算 // 对当前数组的数据通过处理器进行过滤, 并返回符合条件(比较相同元素)的数据 return _.filter(_.uniq(array), function(item) &#123; // 使用every方法验证每一个数组中都包含了需要对比的数据 // 如果所有数组中均包含对比数据, 则全部返回true, 如果任意一个数组没有包含该元素, 则返回false return _.every(rest, function(other) &#123; // other参数存储了每一个需要进行对比的数组 // item存储了当前数组中需要进行对比的数据 // 使用indexOf方法搜索数组中是否存在该元素(可参考indexOf方法注释) return _.indexOf(other, item) &gt;= 0; &#125;); &#125;);&#125;; 这个函数用于获取当前数组与其它一个或多个数组的交集元素，从第二个参数开始为需要进行比较的一个或多个数组 _.difference12345678910_.difference = function(array) &#123; // 对第2个参数开始的所有参数, 作为一个数组进行合并(仅合并第一层, 而并非深层合并) // rest变量存储验证数据, 在本方法中用于与原数据对比 var rest = _.flatten(slice.call(arguments, 1), true); // 对合并后的数组数据进行过滤, 过滤条件是当前数组中不包含参数指定的验证数据的内容 // 将符合过滤条件的数据组合为一个新的数组并返回 return _.filter(array, function(value) &#123; return !_.include(rest, value); &#125;);&#125;; 这个函数会筛选并返回当前数组中与指定数据不相等的差异数据，一般用于删除数组中指定的数据, 并得到删除后的新数组 小结今天一共介绍了21个函数的具体实现，我都写累了，大家可能也看累了吧，我觉得写太多也不利于大家消化这些知识，今天就到这儿吧。thx for reading, hope u enjoy]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Underscore源码解析（二）]]></title>
      <url>%2F2014%2F06%2F03%2FUnderscore%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
      <content type="text"><![CDATA[最近十几天都在忙毕业论文的事，所以上一次为大家介绍完underscore这个框架的结构（或者说是这个框架的设计思路）之后就一直没动静了，今天我又满血复活了，让我们继续来探索underscore的源码奥秘吧。没看过上一篇文章的朋友可以戳这里：underscore源码解析（一）今天的内容是underscore里面封装的一些函数，我将逐个介绍，咱们直接入正题吧 each / .each / .forEach1234567891011121314151617181920212223var each = _.each = _.forEach = function(obj, iterator, context) &#123; // 不处理空值 if(obj == null) return; if(nativeForEach &amp;&amp; obj.forEach === nativeForEach) &#123; // 如果宿主环境支持, 则优先调用JavaScript 1.6提供的forEach方法 obj.forEach(iterator, context); &#125; else if(obj.length === +obj.length) &#123; // 对[数组]中每一个元素执行处理器方法 for(var i = 0, l = obj.length; i &lt; l; i++) &#123; if( i in obj &amp;&amp; iterator.call(context, obj[i], i, obj) === breaker) return; &#125; &#125; else &#123; // 对&#123;对象&#125;中每一个元素执行处理器方法 for(var key in obj) &#123; if(_.has(obj, key)) &#123; if(iterator.call(context, obj[key], key, obj) === breaker) return; &#125; &#125; &#125;&#125;; 这个函数的实现思想其实很简单，如果宿主环境（一般为浏览器或者node.js）支持原生的forEach方法，就调用原生的，否则就遍历该数组或者对象，依次调用处理器方法值得一提的是在判断是否是数组的时候，这里的代码为 obj.length === +obj.length 这其实是一种鸭式辨型的判定方法，具体可以参见我在SF上提过的一个问题：点我 .map / .collect123456789101112131415161718_.map = _.collect = function(obj, iterator, context) &#123; // 用于存放返回值的数组 var results = []; if(obj == null) return results; // 优先调用宿主环境提供的map方法 if(nativeMap &amp;&amp; obj.map === nativeMap) return obj.map(iterator, context); // 迭代处理集合中的元素 each(obj, function(value, index, list) &#123; // 将每次迭代处理的返回值存储到results数组 results[results.length] = iterator.call(context, value, index, list); &#125;); // 返回处理结果 if(obj.length === +obj.length) results.length = obj.length; return results;&#125;; map/collect函数与each的区别在于map/collect会存储每次迭代的返回值, 并作为一个新的数组返回 .reduce / .foldl / _.inject1234567891011121314151617181920212223242526_.reduce = _.foldl = _.inject = function(obj, iterator, memo, context) &#123; // 通过参数数量检查是否存在初始值 var initial = arguments.length &gt; 2; if(obj == null) obj = []; // 优先调用宿主环境提供的reduce方法 if(nativeReduce &amp;&amp; obj.reduce === nativeReduce &amp;&amp; false) &#123; if(context) iterator = _.bind(iterator, context); return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator); &#125; // 迭代处理集合中的元素 each(obj, function(value, index, list) &#123; if(!initial) &#123; // 如果没有初始值, 则将第一个元素作为初始值; 如果被处理的是对象集合, 则默认值为第一个属性的值 memo = value; initial = true; &#125; else &#123; // 记录处理结果, 并将结果传递给下一次迭代 memo = iterator.call(context, memo, value, index, list); &#125; &#125;); if(!initial) throw new TypeError(&apos;Reduce of empty array with no initial value&apos;); return memo;&#125;; 这个函数的作用是将集合中每个元素放入迭代处理器, 并将本次迭代的返回值作为memo传递到下一次迭代, 一般用于累计结果或连接数据 .reduceRight / .foldr1234567891011121314151617_.reduceRight = _.foldr = function(obj, iterator, memo, context) &#123; var initial = arguments.length &gt; 2; if(obj == null) obj = []; // 优先调用宿主环境提供的reduceRight方法 if(nativeReduceRight &amp;&amp; obj.reduceRight === nativeReduceRight) &#123; if(context) iterator = _.bind(iterator, context); return initial ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator); &#125; // 逆转集合中的元素顺序 var reversed = _.toArray(obj).reverse(); if(context &amp;&amp; !initial) iterator = _.bind(iterator, context); // 通过reduce方法处理数据 return initial ? _.reduce(reversed, iterator, memo, context) : _.reduce(reversed, iterator);&#125;; 这个函数与reduce相似，不过它是逆向迭代集合中的元素 .find / .detect12345678910111213_.find = _.detect = function(obj, iterator, context) &#123; // result存放第一个能够通过验证的元素 var result; // 通过any方法遍历数据, 并记录通过验证的元素 any(obj, function(value, index, list) &#123; // 如果处理器返回的结果被转换为Boolean类型后值为true, 则记录当前值并返回当前元素 if(iterator.call(context, value, index, list)) &#123; result = value; return true; &#125; &#125;); return result;&#125;; 这个方法的作用是遍历集合中的元素, 返回能够通过处理器验证的第一个元素 .filter / .select123456789101112131415_.filter = _.select = function(obj, iterator, context) &#123; // 用于存储通过验证的元素数组 var results = []; if(obj == null) return results; // 优先调用宿主环境提供的filter方法 if(nativeFilter &amp;&amp; obj.filter === nativeFilter) return obj.filter(iterator, context); // 迭代集合中的元素, 并将通过处理器验证的元素放到数组中并返回 each(obj, function(value, index, list) &#123; if(iterator.call(context, value, index, list)) results[results.length] = value; &#125;); return results;&#125;; 这个方法与find作用类似, 但它会记录下集合中所有通过验证的元素 _.reject12345678910_.reject = function(obj, iterator, context) &#123; var results = []; if(obj == null) return results; each(obj, function(value, index, list) &#123; if(!iterator.call(context, value, index, list)) results[results.length] = value; &#125;); return results;&#125;; 这个方法的代码里面我没有加注释，因为整个代码与filter/select方法几乎一样，不同点在于向results数组里添加元素的时候判断条件是相反的，也就是说这个方法的作用是返回没有通过处理器验证的元素列表 .every / .all123456789101112131415_.every = _.all = function(obj, iterator, context) &#123; var result = true; if(obj == null) return result; // 优先调用宿主环境提供的every方法 if(nativeEvery &amp;&amp; obj.every === nativeEvery) return obj.every(iterator, context); // 迭代集合中的元素 each(obj, function(value, index, list) &#123; // 这里我不太理解，为什么药写成 result = (result &amp;&amp; iterator.call(context, value, index, list)) 而不是 result = iterator.call(context, value, index, list) if(!( result = result &amp;&amp; iterator.call(context, value, index, list))) return breaker; &#125;); return !!result;&#125;; 这个方法的作用是如果集合中所有元素均能通过处理器验证, 则返回true any / .some / .any12345678910111213141516var any = _.some = _.any = function(obj, iterator, context) &#123; // 如果没有指定处理器参数, 则使用默认的处理器函数，该函数会返回参数本身 iterator || ( iterator = _.identity); var result = false; if(obj == null) return result; // 优先调用宿主环境提供的some方法 if(nativeSome &amp;&amp; obj.some === nativeSome) return obj.some(iterator, context); // 迭代集合中的元素 each(obj, function(value, index, list) &#123; if(result || ( result = iterator.call(context, value, index, list))) return breaker; &#125;); return !!result;&#125;; 该函数的作用是检查集合中是否有任何一个元素在被转换成Boolean类型时是否为true .include / .contains12345678910111213_.include = _.contains = function(obj, target) &#123; var found = false; if(obj == null) return found; // 优先调用宿主环境提供的Array.prototype.indexOf方法 if(nativeIndexOf &amp;&amp; obj.indexOf === nativeIndexOf) return obj.indexOf(target) != -1; // 通过any方法迭代集合中的元素, 验证元素的值和类型与目标是否完全匹配 found = any(obj, function(value) &#123; return value === target; &#125;); return found;&#125;; 这个函数用于检查集合中是否有值与目标参数完全匹配，包括数据类型 小结今天先介绍以上10个函数的实现细节，之后还会继续带来其他函数的介绍，欢迎大家提出指正和建议，thx for reading, hope u enjoy]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Underscore源码解析（一）]]></title>
      <url>%2F2014%2F05%2F21%2FUnderscore%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
      <content type="text"><![CDATA[最近准备折腾一下backbone.js，在事先了解了backbone之后，我知道了backbone对underscore这个库有着强依赖，正好underscore之前也没使用过，于是我就想先把underscore彻底了解一下，这样之后折腾backbone的时候也少一点阻碍。 underscore是一个很实用且小巧的框架，提供了很多我们在编程时需要的基本功能函数，而且他没有扩展javascript的原生对象，主要涉及对Object、Array、Function的操作。 我曾经问我的朋友@小胡子哥 怎么学习一个框架？他给我的回答是：“直接看源码。”现在想想深感同意，因为研究源码是最直接的学习途径，可以深入地了解这个框架的思想和精髓，同时也能学习框架作者的编程技巧，提升自己的coding水平。 好了，题外话就说到这里，下面咱们进入正题。 简化源码看结构我这次看的underscore版本是1.3.3，整个文件也就1000多行，我把代码简化了一下，并加入了相关的注释： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133// underscore的代码包裹在一个匿名自执行函数中(function() &#123; // 创建一个全局对象, 在浏览器中表示为window对象, 在Node.js中表示global对象 var root = this; // 保存&quot;_&quot;(下划线变量)被覆盖之前的值 // 如果出现命名冲突或考虑到规范, 可通过_.noConflict()方法恢复&quot;_&quot;被Underscore占用之前的值, 并返回Underscore对象以便重新命名 var previousUnderscore = root._; // 创建一个空的对象常量, 便于内部共享使用 var breaker = &#123;&#125;; // 将内置对象的原型链缓存在局部变量 var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype; // 将内置对象原型中的常用方法缓存在局部变量 var slice = ArrayProto.slice, unshift = ArrayProto.unshift, toString = ObjProto.toString, hasOwnProperty = ObjProto.hasOwnProperty; // 这里定义了一些JavaScript 1.6提供的新方法 // 如果宿主环境中支持这些方法则优先调用, 如果宿主环境中没有提供, 则会由Underscore实现 var nativeForEach = ArrayProto.forEach, nativeMap = ArrayProto.map, nativeReduce = ArrayProto.reduce, nativeReduceRight = ArrayProto.reduceRight, nativeFilter = ArrayProto.filter, nativeEvery = ArrayProto.every, nativeSome = ArrayProto.some, nativeIndexOf = ArrayProto.indexOf, nativeLastIndexOf = ArrayProto.lastIndexOf, nativeIsArray = Array.isArray, nativeKeys = Object.keys, nativeBind = FuncProto.bind; // 创建对象式的调用方式, 将返回一个Underscore包装器, 包装器对象的原型中包含Underscore所有方法(类似与将DOM对象包装为一个jQuery对象) var _ = function(obj) &#123; // 所有Underscore对象在内部均通过wrapper对象进行构造 return new wrapper(obj); &#125;; // 针对不同的宿主环境, 将Undersocre的命名变量存放到不同的对象中 if( typeof exports !== &apos;undefined&apos;) &#123;// Node.js环境 if( typeof module !== &apos;undefined&apos; &amp;&amp; module.exports) &#123; exports = module.exports = _; &#125; exports._ = _; &#125; else &#123;// 浏览器环境中Underscore的命名变量被挂在window对象中 root[&apos;_&apos;] = _; &#125; // 版本声明 _.VERSION = &apos;1.3.3&apos;; //在_对象上定义各种方法 . . . . . . // underscore对象的包装函数 var wrapper = function(obj) &#123; // 原始数据存放在包装对象的_wrapped属性中 this._wrapped = obj; &#125;; // 将Underscore的原型对象指向wrapper的原型, 因此通过像wrapper原型中添加方法, Underscore对象也会具备同样的方法 _.prototype = wrapper.prototype; // 返回一个对象, 如果当前Underscore调用了chain()方法(即_chain属性为true), 则返回一个被包装的Underscore对象, 否则返回对象本身 // result函数用于在构造方法链时返回Underscore的包装对象 var result = function(obj, chain) &#123; return chain ? _(obj).chain() : obj; &#125;; // 将一个自定义方法添加到Underscore对象中(实际是添加到wrapper的原型中, 而Underscore对象的原型指向了wrapper的原型) var addToWrapper = function(name, func) &#123; // 向wrapper原型中添加一个name函数, 该函数调用func函数, 并支持了方法链的处理 wrapper.prototype[name] = function() &#123; // 获取func函数的参数, 并将当前的原始数据添加到第一个参数 var args = slice.call(arguments); unshift.call(args, this._wrapped); // 执行函数并返回结果, 并通过result函数对方法链进行封装, 如果当前调用了chain()方法, 则返回封装后的Underscore对象, 否则返回对象本身 return result(func.apply(_, args), this._chain); &#125;; &#125;; // 将内部定义的_(即Underscore方法集合对象)中的方法复制到wrapper的原型链中(即Underscore的原型链中) // 这是为了在构造对象式调用的Underscore对象时, 这些对象也会具有内部定义的Underscore方法 _.mixin(_); // 将Array.prototype中的相关方法添加到Underscore对象中, 因此在封装后的Underscore对象中也可以直接调用Array.prototype中的方法 // 如: _([]).push() each([&apos;pop&apos;, &apos;push&apos;, &apos;reverse&apos;, &apos;shift&apos;, &apos;sort&apos;, &apos;splice&apos;, &apos;unshift&apos;], function(name) &#123; // 获取Array.prototype中对应方法的引用 var method = ArrayProto[name]; // 将该方法添加到Underscore对象中(实际是添加到wrapper的原型对象, 因此在创建Underscore对象时同时具备了该方法) wrapper.prototype[name] = function() &#123; // _wrapped变量中存储Underscore对象的原始值 var wrapped = this._wrapped; // 调用Array对应的方法并返回结果 method.apply(wrapped, arguments); var length = wrapped.length; if((name == &apos;shift&apos; || name == &apos;splice&apos;) &amp;&amp; length === 0) delete wrapped[0]; // 即使是对于Array中的方法, Underscore同样支持方法链操作 return result(wrapped, this._chain); &#125;; &#125;); // 作用同于上一段代码, 将数组中的一些方法添加到Underscore对象, 并支持了方法链操作 // 区别在于上一段代码所添加的函数, 均返回Array对象本身(也可能是封装后的Array), concat, join, slice方法将返回一个新的Array对象(也可能是封装后的Array) each([&apos;concat&apos;, &apos;join&apos;, &apos;slice&apos;], function(name) &#123; var method = ArrayProto[name]; wrapper.prototype[name] = function() &#123; return result(method.apply(this._wrapped, arguments), this._chain); &#125;; &#125;); // 对Underscore对象进行链式操作的声明方法 wrapper.prototype.chain = function() &#123; // this._chain用来标示当前对象是否使用链式操作 // 对于支持方法链操作的数据, 一般在具体方法中会返回一个Underscore对象, 并将原始值存放在_wrapped属性中, 也可以通过value()方法获取原始值 this._chain = true; return this; &#125;; // 返回被封装的Underscore对象的原始值(存放在_wrapped属性中) wrapper.prototype.value = function() &#123; return this._wrapped; &#125;;&#125;).call(this); 小结underscore这个库的结构（或者说思路）大致是这样的： 创建一个包装器, 将一些原始数据进行包装，所有的undersocre对象, 内部均通过wrapper函数进行构造和封装 underscore与wrapper的内部关系是: - 内部定义变量*_*, 将*underscore*相关的方法添加到*_*, 这样就可以支持函数式的调用, 如*_.bind()* - 内部定义*wrapper*类, 将*_*的原型对象指向*wrapper*类的原型 - 将*underscore*相关的方法添加到*wrapper*原型, 创建的*_*对象就具备了*underscore*的方法 - 将*Array*.*prototype*相关方法添加到*wrapper*原型, 创建的*_*对象就具备了*Array.prototype*中的方法 - *new _()*时实际创建并返回了一个*wrapper()*对象, 并将原始数组存储到*_wrapped*变量, 并将原始值作为第一个参数调用对应方法 之后我会对underscore中所有方法的具体实现进行介绍，感谢关注]]></content>
    </entry>

    
  
  
</search>
